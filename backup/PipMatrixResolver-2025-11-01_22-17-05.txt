#===============================================================================
# Project: PipMatrixResolver
# Generated on: 2025-11-01 21:06:00
# OS: WSL on Ubuntu: 24.04
# This file is used to show full source code, cmake, read me, and file locates.
#===============================================================================

#-------------------------------------------------------------------------------
# File: CMakeLists.txt
#-------------------------------------------------------------------------------
cmake_minimum_required(VERSION 3.24)
project(PipMatrixResolverQt VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

find_package(Qt6 6.10 REQUIRED COMPONENTS Core Gui Widgets LinguistTools Network Concurrent Svg)

qt_standard_project_setup()

# --------------------------------------------------
# Translations
# --------------------------------------------------
set(TS_FILES
    translations/PipMatrixResolverQt_en.ts
    translations/PipMatrixResolverQt_es.ts
    translations/MatrixUtility_en.ts
    translations/MatrixUtility_es.ts
    translations/MatrixHistory_en.ts
    translations/MatrixHistory_es.ts
)

qt_add_translation(QM_FILES ${TS_FILES})

# --------------------------------------------------
# Resources (icons + translations)
# --------------------------------------------------
qt_add_resources(APP_RESOURCES PipMatrixResolverQt.qrc)

# --------------------------------------------------
# Executable
# --------------------------------------------------
qt_add_executable(PipMatrixResolverQt
    src/main.cpp
    src/MainWindow.cpp
    src/MainWindow.h
    src/MainWindow.ui
    src/ResolverEngine.cpp
    src/ResolverEngine.h
    src/VenvManager.cpp
    src/VenvManager.h
    src/PipToolsRunner.cpp
    src/PipToolsRunner.h
    src/BatchRunner.cpp
    src/BatchRunner.h
    src/MatrixUtility.h src/MatrixUtility.cpp
    src/MatrixHistory.h src/MatrixHistory.cpp

    ${APP_RESOURCES}
    ${QM_FILES}   # ensures .qm files are built before linking
)

target_link_libraries(PipMatrixResolverQt PRIVATE
    Qt6::Core
    Qt6::Gui
    Qt6::Widgets
    Qt6::Network
    Qt6::Concurrent
    Qt6::Svg
)

target_include_directories(PipMatrixResolverQt PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)
# --------------------------------------------------
# Deployment logic
# --------------------------------------------------
if(WIN32)
    find_program(WINDEPLOYQT_EXECUTABLE NAMES windeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(WINDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${WINDEPLOYQT_EXECUTABLE} --verbose 0 --no-compiler-runtime "$<TARGET_FILE:PipMatrixResolverQt>"
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (Windows)"
        )
    endif()
elseif(APPLE)
    find_program(MACDEPLOYQT_EXECUTABLE NAMES macdeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(MACDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${MACDEPLOYQT_EXECUTABLE} "$<TARGET_BUNDLE_DIR:PipMatrixResolverQt>" -verbose=1
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (macOS)"
        )
    endif()
elseif(UNIX)
    message(STATUS "✅ Linux build — Qt runtime deployment handled by system packages.")
endif()

install(TARGETS PipMatrixResolverQt)

#-------------------------------------------------------------------------------
# File: PipMatrixResolverQt.qrc
#-------------------------------------------------------------------------------
<RCC>
    <!-- Icons -->
    <qresource prefix="/icons">
        <file>icons/app.svg</file>
        <file>icons/open.svg</file>
        <file>icons/url.svg</file>
        <file>icons/venv.svg</file>
        <file>icons/resolve.svg</file>
        <file>icons/pause.svg</file>
        <file>icons/resume.svg</file>
        <file>icons/stop.svg</file>
        <file>icons/batch.svg</file>
        <file>icons/info.svg</file>
        <file>icons/readme.svg</file>
    </qresource>

    <!-- Translations -->
    <qresource prefix="/translations">
        <file>translations/PipMatrixResolverQt_en.qm</file>
        <file>translations/PipMatrixResolverQt_es.qm</file>
        <file>translations/MatrixUtility_en.qm</file>
        <file>translations/MatrixUtility_es.qm</file>
        <file>translations/MatrixHistory_en.qm</file>
        <file>translations/MatrixHistory_es.qm</file>
    </qresource>
    <!-- Docs -->
    <qresource prefix="/docs">
        <file>README.md</file>
    </qresource>

</RCC>
#-------------------------------------------------------------------------------
# File: README.md
#-------------------------------------------------------------------------------
# PipMatrixResolverQt

## Status:
* Not working.
* Just starting this project, and it will take time to get to a working version.

### A cross platform Qt 6.10 C++ GUI for resolving Python requirements.txt matrices, managing virtual environments, and running batch multimedia conversions.

Features

* Resolve Python dependency matrices with pip-tools
* Manage virtual environments (create, upgrade pip and pip-tools)
* Batch convert audio + image to MP4 with ffmpeg
* Qt GUI with menus, log view, progress bar
* Translation support (English and Spanish)

## Build Instructions
```
cmake -S . -B build -DCMAKE\_PREFIX\_PATH="C:/Qt/6.10.0/mingw\_64"
cmake --build build
```

## On Windows, windeployqt is run automatically after build.

Project Tree

```
Qt/
├── build
├── icons
│   ├── app.svg
│   ├── batch.svg
│   ├── cancel.svg
│   ├── info.svg
│   ├── open.svg
│   ├── pause.svg
│   ├── readme.svg
│   ├── resolve.svg
│   ├── resume.svg
│   ├── stop.svg
│   ├── url.svg
│   └── venv.svg
├── src
│   ├── BatchRunner.cpp
│   ├── BatchRunner.h
│   ├── MainWindow.cpp
│   ├── MainWindow.h
│   ├── MainWindow.ui
│   ├── MatrixHistory.cpp
│   ├── MatrixHistory.h
│   ├── MatrixUtility.cpp
│   ├── MatrixUtility.h
│   ├── PipToolsRunner.cpp
│   ├── PipToolsRunner.h
│   ├── ResolverEngine.cpp
│   ├── ResolverEngine.h
│   ├── VenvManager.cpp
│   ├── VenvManager.h
│   └── main.cpp
├── src_text
│   ├── BatchRunner.cpp.txt
│   ├── BatchRunner.h.txt
│   ├── MainWindow.cpp.txt
│   ├── MainWindow.h.txt
│   ├── MainWindow.ui.autosave.txt
│   ├── MainWindow.ui.txt
│   ├── MatrixHistory.cpp.txt
│   ├── MatrixHistory.h.txt
│   ├── MatrixHistory.ui.txt
│   ├── MatrixUtility.cpp.txt
│   ├── MatrixUtility.h.txt
│   ├── PipMatrixResolverQt.qrc.txt
│   ├── PipToolsRunner.cpp.txt
│   ├── PipToolsRunner.h.txt
│   ├── ResolverEngine.cpp.txt
│   ├── ResolverEngine.h.txt
│   ├── VenvManager.cpp.txt
│   ├── VenvManager.h.txt
│   └── main.cpp.txt
├── tests
│   ├── gtest_resolver.cpp
│   ├── qt_test_main.cpp
│   ├── qtest_mainwindow.cpp
│   ├── test_main.cpp
│   ├── test_mainwindow.cpp
│   └── test_resolver.cpp
├── translations
│   ├── MatrixHistory_en.qm
│   ├── MatrixHistory_en.ts
│   ├── MatrixHistory_es.qm
│   ├── MatrixHistory_es.ts
│   ├── MatrixUtility_en.qm
│   ├── MatrixUtility_en.ts
│   ├── MatrixUtility_es.qm
│   ├── MatrixUtility_es.ts
│   ├── PipMatrixResolverQt_en.qm
│   ├── PipMatrixResolverQt_en.ts
│   ├── PipMatrixResolverQt_es.qm
│   └── PipMatrixResolverQt_es.ts
├── .gitignore
├── CMakeLists.txt
├── CMakeLists.txt.user
├── LICENSE
├── PipMatrixResolverQt.qrc
├── README.md
├── cleanbash.sh
├── requirements.txt
├── source_files.txt
├── src2txt.bat
└── src2txt.sh
```

## File Descriptions

Root
```
CMakeLists.txt – Build script: compiles sources, generates qm from ts, bundles resources
PipMatrixResolverQt.qrc – Qt resource file embedding icons and compiled translations
```

resources/icons
```
SVG icons used in menus and toolbars
```

src
```
main.cpp – Application entry point. Sets up QApplication, loads translations, shows MainWindow
MainWindow.h/.cpp/.ui – Main GUI window. Defines menus, log view, progress bar, and user actions
ResolverEngine.h/.cpp – Core engine for iterating over package version combinations. Emits logs, progress, and success signals
PipToolsRunner.h/.cpp – Wrapper around pip-compile. Runs with retries, logs output, analyzes errors
VenvManager.h/.cpp – Creates and manages Python virtual environments. Upgrades pip and pip-tools
BatchRunner.h/.cpp – Automates ffmpeg jobs. Enqueues tasks, parses progress, emits job completion signals
```

translations
```
PipMatrixResolverQt\_en.ts – English translation source
PipMatrixResolverQt\_es.ts – Spanish translation source
Both are compiled into qm at build time and embedded
```

build
```
Out of source build directory. Keeps generated files separate from source tree
```

Usage

```
File → Open requirements file – Load a local requirements.txt
Tools → Create/Update venv – Create or update a Python virtual environment
Tools → Resolve matrix – Start iterative resolution of package versions
Batch → Run batch conversion to mp4 – Combine audio and image into MP4
Help → About – Show app info
```

## License: 
    Unlicensed, MIT or your chosen license

#-------------------------------------------------------------------------------
# File: src/BatchRunner.cpp
#-------------------------------------------------------------------------------
#include "BatchRunner.h"
#include <QRegularExpression>
#include <QFileInfo>

BatchRunner::BatchRunner(QObject *parent) : QObject(parent), m_running(false)
{
    connect(&m_process, &QProcess::readyReadStandardError, this, &BatchRunner::handleReadyRead);
    connect(&m_process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            this, &BatchRunner::handleFinished);
}

void BatchRunner::enqueue(const BatchJob &job)
{
    m_jobs.enqueue(job);
}

void BatchRunner::start()
{
    if (m_running || m_jobs.isEmpty())
    {
        return;
    }
    m_running = true;
    runNextJob();
}

void BatchRunner::stop()
{
    if (m_running)
    {
        m_process.kill();
        m_jobs.clear();
        m_running = false;
    }
}

void BatchRunner::runNextJob()
{
    if (m_jobs.isEmpty())
    {
        m_running = false;
        emit allJobsFinished();
        return;
    }

    m_currentJob = m_jobs.dequeue();
    emit logMessage(QString("Starting batch job: %1 + %2 → %3")
                    .arg(m_currentJob.imagePath, m_currentJob.audioPath, m_currentJob.outputPath));

    QStringList args = {
        "-y",
        "-i", m_currentJob.audioPath,
        "-i", m_currentJob.imagePath,
        "-c:v", "libx264",
        "-c:a", "aac",
        "-shortest",
        m_currentJob.outputPath
    };

    m_process.setProgram("ffmpeg");
    m_process.setArguments(args);
    m_process.start();
}

void BatchRunner::handleReadyRead()
{
    const QString output = QString::fromUtf8(m_process.readAllStandardError());
    emit logMessage(output);

    // Parse ffmpeg progress lines like: "frame=  100 fps=25 q=28.0 size=..."
    const QStringList lines = output.split('\n');
    for (const QString &line : lines)
    {
        int percent = parseProgress(line);
        if (percent >= 0)
        {
            emit progressChanged(percent);
        }
    }
}

void BatchRunner::handleFinished(int exitCode, QProcess::ExitStatus status)
{
    if (status == QProcess::NormalExit && exitCode == 0)
    {
        emit logMessage(QString("Job finished successfully: %1").arg(m_currentJob.outputPath));
        emit jobFinished(m_currentJob.outputPath);
    }
    else
    {
        emit logMessage(QString("Job failed: %1").arg(m_currentJob.outputPath));
    }

    runNextJob();
}

int BatchRunner::parseProgress(const QString &line)
{
    // Very basic parser: look for "time=" and estimate percent
    QRegularExpression re("time=(\\d+):(\\d+):(\\d+\\.\\d+)");
    QRegularExpressionMatch match = re.match(line);
    if (match.hasMatch())
    {
        int hours = match.captured(1).toInt();
        int minutes = match.captured(2).toInt();
        double seconds = match.captured(3).toDouble();
        double elapsed = hours * 3600 + minutes * 60 + seconds;

        // For demo: assume 60 seconds total
        double percent = (elapsed / 60.0) * 100.0;
        if (percent > 100.0) percent = 100.0;
        return static_cast<int>(percent);
    }
    return -1;
}
#-------------------------------------------------------------------------------
# File: src/BatchRunner.h
#-------------------------------------------------------------------------------
#pragma once
#include <QObject>
#include <QQueue>
#include <QProcess>

struct BatchJob
{
    QString imagePath;
    QString audioPath;
    QString outputPath;
};

class BatchRunner : public QObject
{
    Q_OBJECT
public:
    explicit BatchRunner(QObject *parent = nullptr);

    void enqueue(const BatchJob &job);
    void start();
    void stop();

signals:
    void logMessage(const QString &line);
    void progressChanged(int percent);
    void jobFinished(const QString &outputPath);
    void allJobsFinished();

private slots:
    void handleReadyRead();
    void handleFinished(int exitCode, QProcess::ExitStatus status);

private:
    void runNextJob();
    int parseProgress(const QString &line);

    QQueue<BatchJob> m_jobs;
    QProcess m_process;
    BatchJob m_currentJob;
    bool m_running;
};
#-------------------------------------------------------------------------------
# File: src/MainWindow.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.cpp
 * @brief Implements the main application window.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.6
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Implements the main window logic: settings, history, menus,
 * file and URL loaders, logging, and UI dialog wiring. All
 * design stays in .ui; this file wires UI to behavior.
 ***************************************************************/

#include "MainWindow.h"
#include "ui_MainWindow.h"

#include <QFileDialog>
#include <QMessageBox>
#include <QInputDialog>
#include <QSettings>
#include <QStandardItemModel>
#include <QTableView>
#include <QPlainTextEdit>
#include <QProgressBar>
#include <QMenu>
#include <QAction>
#include <QDateTime>
#include <QDialog>
#include <QTextBrowser>
#include <QVBoxLayout>
#include <QPushButton>
#include <QFile>
#include <QDir>
#include <QFileInfo>
#include <QDialogButtonBox>
#include <limits>

/****************************************************************
 * @section External utilities assumed present
 * These functions are declared elsewhere in your project.
 ***************************************************************/
namespace MatrixUtility
{
QStringList readTextFileLines(const QString &path);
bool validateRequirementsWithErrors(const QStringList &lines,
                                    QStringList &errors);
void writeTableToModel(QStandardItemModel *model,
                       const QStringList &lines);
void ensureViewScrollable(QTableView *view);
QString normalizeRawUrl(const QString &inputUrl);
bool downloadText(const QString &url, QByteArray &out);
QString logsDir();
}

/****************************************************************
 * @brief Constructor.
 * @param parent Parent widget pointer.
 ***************************************************************/
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent),
    ui(new Ui::MainWindow),
    resolver(nullptr),
    venv(nullptr),
    batch(nullptr),
    requirementsModel(new QStandardItemModel(this)),
    requirementsView(nullptr),
    logView(nullptr),
    progress(nullptr),
    recentLocalMenu(nullptr),
    recentWebMenu(nullptr),
    historyWidget(nullptr),
    maxHistoryItems(10),
    appVersion(QStringLiteral("1.0"))
{
    ui->setupUi(this);

    // Hook up UI elements created in Designer
    requirementsView = ui->requirementsView;
    logView = ui->logView;
    progress = ui->progressBar;
    recentLocalMenu = ui->menuRecentLocal;
    recentWebMenu = ui->menuRecentWeb;
    historyWidget = ui->matrixHistoryWidget;

    // Load settings and history
    loadAppSettings();
    loadHistory();
    refreshRecentMenus();

    // Connect menu actions from Designer
    connect(ui->actionOpenRequirements, &QAction::triggered,
            this, &MainWindow::openLocalRequirements);
    connect(ui->actionFetchRequirements, &QAction::triggered,
            this, &MainWindow::fetchRequirementsFromUrl);

    // Preferences button box in settings dialog (if present)
    if (ui->buttonBoxPreferences)
    {
        connect(ui->buttonBoxPreferences, &QDialogButtonBox::accepted,
                this, &MainWindow::saveAppSettings);
        QPushButton *applyBtn =
            ui->buttonBoxPreferences->button(QDialogButtonBox::Apply);
        if (applyBtn)
        {
            connect(applyBtn, &QPushButton::clicked,
                    this, &MainWindow::saveAppSettings);
        }
    }
}

/****************************************************************
 * @brief Destructor.
 ***************************************************************/
MainWindow::~MainWindow()
{
    delete ui;
}

/****************************************************************
 * @brief Open requirements from a local file.
 ***************************************************************/
void MainWindow::openLocalRequirements()
{
    QString path = QFileDialog::getOpenFileName(
        this,
        tr("Open requirements.txt"),
        QString(),
        tr("Text Files (*.txt)")
        );

    if (path.isEmpty())
    {
        return;
    }

    loadRequirementsFromFile(path);
}

/****************************************************************
 * @brief Fetch requirements from a URL via dialog.
 ***************************************************************/
void MainWindow::fetchRequirementsFromUrl()
{
    bool ok = false;
    QString inputUrl = QInputDialog::getText(
        this,
        tr("Fetch requirements"),
        tr("Enter URL:"),
        QLineEdit::Normal,
        "",
        &ok
        );

    if (!ok || inputUrl.isEmpty())
    {
        return;
    }

    const QString rawUrl = MatrixUtility::normalizeRawUrl(inputUrl);
    loadRequirementsFromUrl(rawUrl);
}

/****************************************************************
 * @brief Load requirements from a local file.
 * @param path Absolute or canonical file path.
 ***************************************************************/
void MainWindow::loadRequirementsFromFile(const QString &path)
{
    if (path.isEmpty())
    {
        return;
    }

    if (!QFile::exists(path))
    {
        QMessageBox::warning(
            this,
            tr("File missing"),
            tr("File no longer exists:\n%1").arg(path)
            );
        // Auto-remove invalid entry
        historyRecentLocal.removeAll(path);
        refreshRecentMenus();
        saveHistory();
        return;
    }

    const QStringList lines = MatrixUtility::readTextFileLines(path);

    QStringList errors;
    if (!MatrixUtility::validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(
            this,
            tr("Invalid requirements.txt"),
            tr("Validation failed:\n%1").arg(errors.join("\n"))
            );
        return;
    }

    requirementsView->setModel(requirementsModel);
    MatrixUtility::writeTableToModel(requirementsModel, lines);
    MatrixUtility::ensureViewScrollable(requirementsView);
    applyToolsEnabled(true);

    // Update local history with max setting
    historyRecentLocal.removeAll(path);
    historyRecentLocal.prepend(path);
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();

    appendLog(
        tr("Loaded %1 requirements from %2")
            .arg(requirementsModel->rowCount())
            .arg(path)
        );
}

/****************************************************************
 * @brief Load requirements from a URL.
 * @param url Normalized URL string.
 ***************************************************************/
void MainWindow::loadRequirementsFromUrl(const QString &url)
{
    if (url.isEmpty())
    {
        return;
    }

    QByteArray content;
    if (!MatrixUtility::downloadText(url, content))
    {
        QMessageBox::warning(
            this,
            tr("Download failed"),
            tr("Failed to fetch requirements from URL:\n%1").arg(url)
            );
        // Auto-remove invalid entry
        historyRecentWeb.removeAll(url);
        refreshRecentMenus();
        saveHistory();
        return;
    }

    const QStringList lines =
        QString::fromUtf8(content).split('\n', Qt::KeepEmptyParts);

    QStringList errors;
    if (!MatrixUtility::validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(
            this,
            tr("Invalid requirements.txt"),
            tr("Fetched content failed validation:\n%1")
                .arg(errors.join("\n"))
            );
        return;
    }

    requirementsView->setModel(requirementsModel);
    MatrixUtility::writeTableToModel(requirementsModel, lines);
    MatrixUtility::ensureViewScrollable(requirementsView);
    applyToolsEnabled(true);

    // Update web history with max setting
    historyRecentWeb.removeAll(url);
    historyRecentWeb.prepend(url);
    if (maxHistoryItems != -1)
    {
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();

    appendLog(
        tr("Fetched %1 requirements from URL: %2")
            .arg(requirementsModel->rowCount())
            .arg(url)
        );
}

/****************************************************************
 * @brief Refresh recent file and URL menus, with Clear actions.
 ***************************************************************/
void MainWindow::refreshRecentMenus()
{
    recentLocalMenu->clear();
    recentWebMenu->clear();

    // Local history
    for (int i = 0; i < historyRecentLocal.size(); ++i)
    {
        const QString &path = historyRecentLocal.at(i);
        if (!QFile::exists(path))
        {
            continue;
        }

        QAction *act = recentLocalMenu->addAction(path);
        connect(
            act, &QAction::triggered, this,
            [this, path]()
            {
                loadRequirementsFromFile(path);
            }
            );
    }

    if (!historyRecentLocal.isEmpty())
    {
        recentLocalMenu->addSeparator();
        QAction *clearLocal = recentLocalMenu->addAction(tr("Clear Recent"));
        connect(
            clearLocal, &QAction::triggered, this,
            [this]()
            {
                historyRecentLocal.clear();
                refreshRecentMenus();
                saveHistory();
                appendLog(tr("Cleared recent local history"));
            }
            );
    }

    // Web history
    for (int i = 0; i < historyRecentWeb.size(); ++i)
    {
        const QString &url = historyRecentWeb.at(i);
        QAction *act = recentWebMenu->addAction(url);
        connect(
            act, &QAction::triggered, this,
            [this, url]()
            {
                loadRequirementsFromUrl(url);
            }
            );
    }

    if (!historyRecentWeb.isEmpty())
    {
        recentWebMenu->addSeparator();
        QAction *clearWeb = recentWebMenu->addAction(tr("Clear Recent"));
        connect(
            clearWeb, &QAction::triggered, this,
            [this]()
            {
                historyRecentWeb.clear();
                refreshRecentMenus();
                saveHistory();
                appendLog(tr("Cleared recent web history"));
            }
            );
    }
}

/****************************************************************
 * @brief Clear all history (local + web).
 ***************************************************************/
void MainWindow::clearAllHistory()
{
    historyRecentLocal.clear();
    historyRecentWeb.clear();
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Cleared all history"));
}

/****************************************************************
 * @brief Save persistent history to QSettings.
 ***************************************************************/
void MainWindow::saveHistory()
{
    QSettings s;
    s.setValue("history/recentLocal", historyRecentLocal);
    s.setValue("history/recentWeb", historyRecentWeb);
}

/****************************************************************
 * @brief Load persistent history from QSettings.
 ***************************************************************/
void MainWindow::loadHistory()
{
    QSettings s;
    historyRecentLocal = s.value("history/recentLocal").toStringList();
    historyRecentWeb = s.value("history/recentWeb").toStringList();

    // Trim to current max setting
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
}

/****************************************************************
 * @brief Load application settings and reflect in UI.
 ***************************************************************/
void MainWindow::loadAppSettings()
{
    QSettings settings;

    // Defaults: maxItems=10, version="1.0"
    maxHistoryItems = settings.value("app/maxItems", 10).toInt();
    appVersion = settings.value("app/version", "1.0").toString();

    validateAppSettings();
    updateUiFromSettings();
}

/****************************************************************
 * @brief Save application settings from UI to QSettings.
 ***************************************************************/
void MainWindow::saveAppSettings()
{
    applySettingsFromUi();
    validateAppSettings();

    QSettings settings;
    settings.setValue("app/maxItems", maxHistoryItems);
    settings.setValue("app/version", appVersion);

    statusBar()->showMessage(tr("Settings saved"), 2000);

    // Re-apply trimming using new max
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
}

/****************************************************************
 * @brief Validate and clamp all settings to safe ranges.
 ***************************************************************/
void MainWindow::validateAppSettings()
{
    // maxHistoryItems: -1=unlimited, 0 invalid, all others positive
    if (maxHistoryItems == 0)
    {
        maxHistoryItems = 10; // fallback default
    }
    else if (maxHistoryItems < -1)
    {
        maxHistoryItems = 1; // clamp to minimum positive
    }

    // appVersion: text; forbid "0" segments
    QStringList parts = appVersion.split('.');
    bool valid = true;
    for (int i = 0; i < parts.size(); ++i)
    {
        const QString seg = parts.at(i).trimmed();
        if (seg == QStringLiteral("0"))
        {
            valid = false;
            break;
        }
    }
    if (!valid || appVersion.trimmed().isEmpty())
    {
        appVersion = QStringLiteral("1.0");
    }
}

/****************************************************************
 * @brief Apply settings from UI widgets to internal state.
 ***************************************************************/
void MainWindow::applySettingsFromUi()
{
    // Designer widgets:
    // QSpinBox* ui->spinMaxItems (min -1, max INT_MAX)
    // QLineEdit* ui->editVersion
    maxHistoryItems = ui->spinMaxItems->value();
    appVersion = ui->editVersion->text();
}

/****************************************************************
 * @brief Update UI widgets to reflect current settings.
 ***************************************************************/
void MainWindow::updateUiFromSettings()
{
    ui->spinMaxItems->setMinimum(-1);
    ui->spinMaxItems->setMaximum(std::numeric_limits<int>::max());
    ui->spinMaxItems->setToolTip(tr("-1 = unlimited, 0 not allowed, ≥1 valid"));
    ui->spinMaxItems->setValue(maxHistoryItems);

    ui->editVersion->setToolTip(tr("Version string, no segment may be \"0\""));
    ui->editVersion->setText(appVersion);
}

/****************************************************************
 * @brief Start matrix resolution.
 ***************************************************************/
void MainWindow::startResolve()
{
    appendLog(tr("Starting matrix resolution..."));
    if (resolver)
    {
        resolver->start();
    }
}

/****************************************************************
 * @brief Pause matrix resolution.
 ***************************************************************/
void MainWindow::pauseResolve()
{
    appendLog(tr("Pausing..."));
    if (resolver)
    {
        resolver->pause();
    }
}

/****************************************************************
 * @brief Resume matrix resolution.
 ***************************************************************/
void MainWindow::resumeResolve()
{
    appendLog(tr("Resuming..."));
    if (resolver)
    {
        resolver->resume();
    }
}

/****************************************************************
 * @brief Stop matrix resolution.
 ***************************************************************/
void MainWindow::stopResolve()
{
    appendLog(tr("Stopping..."));
    if (resolver)
    {
        resolver->stop();
    }
}

/****************************************************************
 * @brief Append a line to the log view.
 * @param line The message line to append.
 ***************************************************************/
void MainWindow::appendLog(const QString &line)
{
    QString time = QDateTime::currentDateTime().toString("HH:mm:ss");
    logView->appendPlainText(QString("[%1] %2").arg(time, line));
}

/****************************************************************
 * @brief Update progress bar.
 * @param percent The progress value (0-100).
 ***************************************************************/
void MainWindow::updateProgress(int percent)
{
    progress->setValue(percent);
}

/****************************************************************
 * @brief Show compiled result message.
 * @param path The compiled output path.
 ***************************************************************/
void MainWindow::showCompiledResult(const QString &path)
{
    appendLog(tr("Successfully compiled: %1").arg(path));
    statusBar()->showMessage(tr("Compiled successfully"));
}

/****************************************************************
 * @brief Show About dialog.
 ***************************************************************/
void MainWindow::showAboutBox()
{
    QMessageBox::about(
        this,
        tr("About Pip Matrix Resolver"),
        tr("<b>Pip Matrix Resolver</b><br>"
           "Cross-platform Qt tool to resolve "
           "Python dependency matrices.<br>"
           "Version %1").arg(appVersion)
        );
}

/****************************************************************
 * @brief Show README dialog.
 ***************************************************************/
void MainWindow::showReadmeDialog()
{
    QFile file(":/docs/README.md");
    QString markdown;

    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        markdown = QString::fromUtf8(file.readAll());
    }
    else
    {
        markdown = tr("README.md not found in resources.");
    }

    QDialog dialog(this);
    dialog.setWindowTitle(tr("README"));
    dialog.resize(700, 500);

    QVBoxLayout layout(&dialog);
    QTextBrowser viewer(&dialog);
    viewer.setMarkdown(markdown);
    viewer.setOpenExternalLinks(true);

    QPushButton closeButton(tr("Close"), &dialog);
    layout.addWidget(&viewer);
    layout.addWidget(&closeButton);

    connect(&closeButton, &QPushButton::clicked,
            &dialog, &QDialog::accept);

    dialog.exec();
}

/****************************************************************
 * @brief Open matrix history tab.
 ***************************************************************/
void MainWindow::openMatrixHistory()
{
    ui->mainTabs->setCurrentWidget(ui->tabHistory);
}

/************** End of MainWindow.cpp **************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.h
 * @brief Declares the main application window class.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.6
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Main window interface for PipMatrixResolver Qt application.
 * Includes forward declarations, settings API, history, menus,
 * and shared loaders for files and URLs. Uses C-style braces.
 ***************************************************************/

#pragma once

#include <QMainWindow>
#include <QStringList>

/****************************************************************
 * @class ResolverEngine
 * @brief Forward declaration for resolver engine.
 ***************************************************************/
class ResolverEngine;

/****************************************************************
 * @class VenvManager
 * @brief Forward declaration for venv manager.
 ***************************************************************/
class VenvManager;

/****************************************************************
 * @class BatchRunner
 * @brief Forward declaration for batch runner.
 ***************************************************************/
class BatchRunner;

/****************************************************************
 * @class MatrixHistory
 * @brief Forward declaration for history widget.
 ***************************************************************/
class MatrixHistory;

/****************************************************************
 * @class QStandardItemModel
 * @brief Forward declaration for model.
 ***************************************************************/
class QStandardItemModel;

/****************************************************************
 * @class QPlainTextEdit
 * @brief Forward declaration for log view.
 ***************************************************************/
class QPlainTextEdit;

/****************************************************************
 * @class QProgressBar
 * @brief Forward declaration for progress bar.
 ***************************************************************/
class QProgressBar;

/****************************************************************
 * @class QTableView
 * @brief Forward declaration for table view.
 ***************************************************************/
class QTableView;

/****************************************************************
 * @class QMenu
 * @brief Forward declaration for menu.
 ***************************************************************/
class QMenu;

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE

/****************************************************************
 * @class MainWindow
 * @brief Central application window for PipMatrixResolver.
 ***************************************************************/
class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    /************************************************************
     * @brief Construct the main window.
     * @param parent Parent widget pointer.
     ***********************************************************/
    explicit MainWindow(QWidget *parent = nullptr);

    /************************************************************
     * @brief Destroy the main window.
     ***********************************************************/
    ~MainWindow();

private slots:
    /************************************************************
     * @brief Open requirements from a local file via dialog.
     ***********************************************************/
    void openLocalRequirements();

    /************************************************************
     * @brief Fetch requirements from a URL via dialog.
     ***********************************************************/
    void fetchRequirementsFromUrl();

    /************************************************************
     * @brief Refresh recent menus for local and web items.
     ***********************************************************/
    void refreshRecentMenus();

    /************************************************************
     * @brief Clear both local and web recent history lists.
     ***********************************************************/
    void clearAllHistory();

    /************************************************************
     * @brief Load application settings from QSettings to UI.
     ***********************************************************/
    void loadAppSettings();

    /************************************************************
     * @brief Save application settings from UI to QSettings.
     ***********************************************************/
    void saveAppSettings();

    /************************************************************
     * @brief Validate and clamp settings to safe ranges.
     ***********************************************************/
    void validateAppSettings();

    /************************************************************
     * @brief Apply settings from UI widgets to member state.
     ***********************************************************/
    void applySettingsFromUi();

    /************************************************************
     * @brief Update UI widgets to reflect current settings.
     ***********************************************************/
    void updateUiFromSettings();

    /************************************************************
     * @brief Start matrix resolution (existing behavior).
     ***********************************************************/
    void startResolve();

    /************************************************************
     * @brief Pause matrix resolution (existing behavior).
     ***********************************************************/
    void pauseResolve();

    /************************************************************
     * @brief Resume matrix resolution (existing behavior).
     ***********************************************************/
    void resumeResolve();

    /************************************************************
     * @brief Stop matrix resolution (existing behavior).
     ***********************************************************/
    void stopResolve();

    /************************************************************
     * @brief Append a line to the log view with timestamp.
     * @param line The message line to append.
     ***********************************************************/
    void appendLog(const QString &line);

    /************************************************************
     * @brief Update progress bar percent.
     * @param percent The progress value (0-100).
     ***********************************************************/
    void updateProgress(int percent);

    /************************************************************
     * @brief Show compiled result message path.
     * @param path The compiled output path.
     ***********************************************************/
    void showCompiledResult(const QString &path);

    /************************************************************
     * @brief Show About dialog using current appVersion.
     ***********************************************************/
    void showAboutBox();

    /************************************************************
     * @brief Show README dialog from resources.
     ***********************************************************/
    void showReadmeDialog();

    /************************************************************
     * @brief Navigate to MatrixHistory tab in main UI.
     ***********************************************************/
    void openMatrixHistory();

private:
    /************************************************************
     * @brief Load requirements directly from file path.
     * @param path Absolute or canonical file path.
     ***********************************************************/
    void loadRequirementsFromFile(const QString &path);

    /************************************************************
     * @brief Load requirements directly from URL.
     * @param url Normalized URL string.
     ***********************************************************/
    void loadRequirementsFromUrl(const QString &url);

    /************************************************************
     * @brief Save recent history lists to QSettings.
     ***********************************************************/
    void saveHistory();

    /************************************************************
     * @brief Load recent history lists from QSettings.
     ***********************************************************/
    void loadHistory();

private:
    Ui::MainWindow *ui;

    // Engines
    ResolverEngine *resolver;
    VenvManager *venv;
    BatchRunner *batch;

    // Models/Views
    QStandardItemModel *requirementsModel;
    QTableView *requirementsView;
    QPlainTextEdit *logView;
    QProgressBar *progress;

    // Menus
    QMenu *recentLocalMenu;
    QMenu *recentWebMenu;

    // History widget
    MatrixHistory *historyWidget;

    // State
    QStringList historyRecentLocal;
    QStringList historyRecentWeb;

    // Settings
    int maxHistoryItems;     // -1=unlimited, 0 invalid, ≥1 valid
    QString appVersion;
};

/************** End of MainWindow.h **************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.ui
#-------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>900</width>
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Pip Matrix Resolver</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <widget class="QTabWidget" name="mainTabs">
      <property name="currentIndex">
       <number>2</number>
      </property>
      <widget class="QWidget" name="tabMain">
       <attribute name="title">
        <string>Main</string>
       </attribute>
       <layout class="QVBoxLayout" name="mainLayout">
        <item>
         <widget class="QSplitter" name="splitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QTableView" name="requirementsView"/>
          <widget class="QTableView" name="matrixView"/>
         </widget>
        </item>
        <item>
         <widget class="QSplitter" name="bottomSplitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QPlainTextEdit" name="logView">
           <property name="readOnly">
            <bool>true</bool>
           </property>
          </widget>
          <widget class="QProgressBar" name="progressBar"/>
         </widget>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabHistory">
       <attribute name="title">
        <string>History</string>
       </attribute>
       <layout class="QVBoxLayout" name="historyLayout">
        <item>
         <widget class="MatrixHistory" name="matrixHistoryWidget" native="true"/>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabSettings">
       <attribute name="title">
        <string>Settings</string>
       </attribute>
       <layout class="QVBoxLayout" name="settingsLayout">
        <item>
         <layout class="QFormLayout" name="formLayout">
          <item row="0" column="0">
           <widget class="QLabel" name="labelPythonVersion">
            <property name="text">
             <string>Python version:</string>
            </property>
           </widget>
          </item>
          <item row="0" column="1">
           <widget class="QLineEdit" name="pythonVersionEdit"/>
          </item>
          <item row="1" column="0">
           <widget class="QLabel" name="labelPipVersion">
            <property name="text">
             <string>pip version:</string>
            </property>
           </widget>
          </item>
          <item row="1" column="1">
           <widget class="QLineEdit" name="pipVersionEdit"/>
          </item>
          <item row="2" column="0">
           <widget class="QLabel" name="labelPipToolsVersion">
            <property name="text">
             <string>pip-tools version:</string>
            </property>
           </widget>
          </item>
          <item row="2" column="1">
           <widget class="QLineEdit" name="pipToolsVersionEdit"/>
          </item>
          <item row="3" column="0">
           <widget class="QLabel" name="labelMaxItems">
            <property name="text">
             <string>Maximum number of items:</string>
            </property>
           </widget>
          </item>
          <item row="3" column="1">
           <widget class="QSpinBox" name="spinMaxItems">
            <property name="toolTip">
             <string>-1 = unlimited, 0 not allowed, ≥1 valid</string>
            </property>
            <property name="minimum">
             <number>-1</number>
            </property>
            <property name="maximum">
             <number>2147483647</number>
            </property>
            <property name="value">
             <number>10</number>
            </property>
           </widget>
          </item>
          <item row="4" column="0">
           <widget class="QLabel" name="labelAppVersion">
            <property name="text">
             <string>App version:</string>
            </property>
           </widget>
          </item>
          <item row="4" column="1">
           <widget class="QLineEdit" name="editVersion">
            <property name="toolTip">
             <string>Version string, no segment may be &quot;0&quot;</string>
            </property>
            <property name="text">
             <string>1.0</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QPushButton" name="saveSettingsButton">
          <property name="text">
           <string>Save Settings</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="restoreDefaultsButton">
          <property name="text">
           <string>Restore Defaults</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QDialogButtonBox" name="buttonBoxPreferences">
          <property name="standardButtons">
           <set>QDialogButtonBox::StandardButton::Apply|QDialogButtonBox::StandardButton::Cancel|QDialogButtonBox::StandardButton::Ok</set>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>900</width>
     <height>20</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>&amp;File</string>
    </property>
    <addaction name="actionOpenRequirements"/>
    <addaction name="actionFetchRequirements"/>
    <addaction name="actionOpenHistory"/>
    <!-- Added recent submenus -->
    <addaction name="menuRecentLocal"/>
    <addaction name="menuRecentWeb"/>
    <addaction name="separator"/>
    <addaction name="actionExit"/>
   </widget>
   <widget class="QMenu" name="menuTools">
    <property name="title">
     <string>&amp;Tools</string>
    </property>
    <addaction name="actionCreateVenv"/>
    <addaction name="actionResolveMatrix"/>
    <addaction name="actionPause"/>
    <addaction name="actionResume"/>
    <addaction name="actionStop"/>
   </widget>
   <widget class="QMenu" name="menuBatch">
    <property name="title">
     <string>&amp;Batch</string>
    </property>
    <addaction name="actionRunBatch"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>&amp;Help</string>
    </property>
    <addaction name="actionAbout"/>
    <addaction name="actionViewReadme"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuTools"/>
   <addaction name="menuBatch"/>
   <addaction name="menuHelp"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="mainToolBar">
   <property name="windowTitle">
    <string>Main Toolbar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="actionOpenRequirements"/>
   <addaction name="actionFetchRequirements"/>
   <addaction name="actionCreateVenv"/>
   <addaction name="actionResolveMatrix"/>
   <addaction name="actionPause"/>
   <addaction name="actionResume"/>
   <addaction name="actionStop"/>
   <addaction name="actionRunBatch"/>
   <addaction name="actionAbout"/>
   <addaction name="actionViewReadme"/>
  </widget>
  <action name="actionOpenRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/open.svg</normaloff>:/icons/icons/open.svg</iconset>
   </property>
   <property name="text">
    <string>Open requirements file...</string>
   </property>
  </action>
  <action name="actionFetchRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/url.svg</normaloff>:/icons/icons/url.svg</iconset>
   </property>
   <property name="text">
    <string>Fetch requirements from URL...</string>
   </property>
  </action>
  <action name="actionOpenHistory">
   <property name="text">
    <string>Open History</string>
   </property>
  </action>
  <action name="actionExit">
   <property name="text">
    <string>Exit</string>
   </property>
  </action>
  <action name="menuRecentLocal">
   <property name="text">
    <string>Recent Local</string>
   </property>
  </action>
  <action name="menuRecentWeb">
   <property name="text">
    <string>Recent Web</string>
   </property>
</action>
  <action name="actionCreateVenv">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/venv.svg</normaloff>:/icons/icons/venv.svg</iconset>
   </property>
   <property name="text">
    <string>Create/Update venv</string>
   </property>
  </action>
  <action name="actionResolveMatrix">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resolve.svg</normaloff>:/icons/icons/resolve.svg</iconset>
   </property>
   <property name="text">
    <string>Resolve matrix</string>
   </property>
  </action>
  <action name="actionPause">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/pause.svg</normaloff>:/icons/icons/pause.svg</iconset>
   </property>
   <property name="text">
    <string>Pause</string>
   </property>
  </action>
  <action name="actionResume">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resume.svg</normaloff>:/icons/icons/resume.svg</iconset>
   </property>
   <property name="text">
    <string>Resume</string>
   </property>
  </action>
  <action name="actionStop">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/stop.svg</normaloff>:/icons/icons/stop.svg</iconset>
   </property>
   <property name="text">
    <string>Stop</string>
   </property>
  </action>
  <action name="actionRunBatch">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/batch.svg</normaloff>:/icons/icons/batch.svg</iconset>
   </property>
   <property name="text">
    <string>Run batch conversion to mp4</string>
   </property>
  </action>
  <action name="actionAbout">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/info.svg</normaloff>:/icons/icons/info.svg</iconset>
   </property>
   <property name="text">
    <string>About</string>
   </property>
  </action>
  <action name="actionViewReadme">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/readme.svg</normaloff>:/icons/icons/readme.svg</iconset>
   </property>
   <property name="text">
    <string>View README</string>
   </property>
  </action>
  <action name="separator">
   <property name="separator" stdset="0">
    <bool>true</bool>
   </property>
  </action>
 </widget>
 <customwidgets>
  <customwidget>
   <class>MatrixHistory</class>
   <extends>QWidget</extends>
   <header>MatrixHistory.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources>
  <include location="../PipMatrixResolverQt.qrc"/>
 </resources>
 <connections/>
</ui>

#-------------------------------------------------------------------------------
# File: src/MatrixHistory.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MatrixHistory.cpp
 * @brief Implements the MatrixHistory widget for
 *        PipMatrixResolverQt.
 *
 * @author Jeffrey
 * @version 0.6
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Provides a widget to display and manage recent requirements
 * history (local and web). Emits signals when history changes.
 ***************************************************************/

#include "MatrixHistory.h"

#include <QListWidget>
#include <QVBoxLayout>

/****************************************************************
 * @brief Constructor.
 ***************************************************************/
MatrixHistory::MatrixHistory(QWidget *parent)
    : QWidget(parent),
    listWidget(new QListWidget(this))
{
    auto *layout = new QVBoxLayout(this);
    layout->addWidget(listWidget);
    setLayout(layout);
}

/****************************************************************
 * @brief Destructor.
 ***************************************************************/
MatrixHistory::~MatrixHistory() = default;

/****************************************************************
 * @brief Set the history list to display.
 ***************************************************************/
void MatrixHistory::setHistory(const QStringList &history)
{
    if (history == currentHistory)
    {
        return;
    }

    currentHistory = history;
    rebuildList();
    emit historyChanged();
}

/****************************************************************
 * @brief Get the current history list.
 ***************************************************************/
QStringList MatrixHistory::history() const
{
    return currentHistory;
}

/****************************************************************
 * @brief Rebuild the list widget from current history.
 ***************************************************************/
void MatrixHistory::rebuildList()
{
    listWidget->clear();
    for (int i = 0; i < currentHistory.size(); ++i)
    {
        listWidget->addItem(currentHistory.at(i));
    }
}

/************** End of MatrixHistory.cpp **************************/

#-------------------------------------------------------------------------------
# File: src/MatrixHistory.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MatrixHistory.h
 * @brief Declares the MatrixHistory widget for
 *        PipMatrixResolverQt.
 *
 * @author Jeffrey
 * @version 0.6
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Provides a widget to display and manage recent requirements
 * history (local and web). Emits signals when history changes.
 ***************************************************************/

#pragma once

#include <QWidget>
#include <QStringList>

QT_BEGIN_NAMESPACE
class QListWidget;
QT_END_NAMESPACE

/****************************************************************
 * @class MatrixHistory
 * @brief Widget for displaying and managing requirements
 *        history.
 ***************************************************************/
class MatrixHistory : public QWidget
{
    Q_OBJECT

public:
    explicit MatrixHistory(QWidget *parent = nullptr);
    ~MatrixHistory();

    /************************************************************
     * @brief Set the history list to display.
     * @param history Combined list of local and web entries.
     ************************************************************/
    void setHistory(const QStringList &history);

    /************************************************************
     * @brief Get the current history list.
     * @return QStringList of history entries.
     ************************************************************/
    QStringList history() const;

signals:
    /************************************************************
     * @brief Emitted when the history list changes.
     ************************************************************/
    void historyChanged();

private:
    QListWidget *listWidget;
    QStringList currentHistory;

    void rebuildList();
};

/************** End of MatrixHistory.h **************************/

#-------------------------------------------------------------------------------
# File: src/MatrixUtility.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MatrixUtility.cpp
 * @brief Implementation of utility functions for
 *        PipMatrixResolverQt.
 *
 * @author Jeffrey
 * @version 0.4
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Implements helpers for reading requirements files, writing
 * them into models, validating entries, ensuring view
 * scrollability, and downloading text resources.
 ***************************************************************/

#include "MatrixUtility.h"

#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QStandardItemModel>
#include <QStandardItem>
#include <QScrollBar>
#include <QUrl>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QEventLoop>
#include <QRegularExpression>
#include <QTableView>
#include <QDebug>

/************************************************************
 * @brief Return logs directory, create if missing.
 ************************************************************/
QString MatrixUtility::logsDir()
{
    QDir dir("logs");
    if (!dir.exists())
    {
        dir.mkpath(".");
    }
    return dir.absolutePath();
}

/************************************************************
 * @brief Return history directory, create if missing.
 ************************************************************/
QString MatrixUtility::historyDir()
{
    QDir dir("requirement-history");
    if (!dir.exists())
    {
        dir.mkpath(".");
    }
    return dir.absolutePath();
}

/************************************************************
 * @brief Normalize GitHub blob URLs to raw URLs.
 ************************************************************/
QString MatrixUtility::normalizeRawUrl(const QString &url)
{
    const QUrl u(url);
    const QString host = u.host().toLower();
    if (host == "github.com")
    {
        const QStringList parts = u.path().split('/', Qt::SkipEmptyParts);
        if (parts.size() >= 5 && parts[2] == "blob")
        {
            const QString owner = parts[0];
            const QString repo  = parts[1];
            const QString branch = parts[3];
            QString rest = parts.mid(4).join('/');
            return QString("https://raw.githubusercontent.com/%1/%2/%3/%4")
                .arg(owner, repo, branch, rest);
        }
    }
    return url;
}

/************************************************************
 * @brief Read file lines, strip blanks and comments.
 ************************************************************/
QStringList MatrixUtility::readTextFileLines(const QString &path)
{
    QStringList lines;
    QFile f(path);
    if (f.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        while (!f.atEnd())
        {
            QString line = QString::fromUtf8(f.readLine()).trimmed();
            if (line.isEmpty()) continue;
            if (line.startsWith('#')) continue;
            lines << line;
        }
        f.close();
    }
    return lines;
}

/************************************************************
 * @brief Write requirements into a one-column model.
 ************************************************************/
void MatrixUtility::writeTableToModel(QStandardItemModel *model,
                                      const QStringList &lines)
{
    if (!model) return;

    model->clear();
    model->setColumnCount(1);
    model->setHorizontalHeaderLabels(
        { QObject::tr("requirements.txt") });

    for (const QString &line : lines)
    {
        const QString trimmed = line.trimmed();
        if (trimmed.isEmpty()) continue;
        auto *item = new QStandardItem(trimmed);
        item->setEditable(false);
        model->appendRow(item);
    }
}

/************************************************************
 * @brief Ensure scrollbars and column sizing for a view.
 ************************************************************/
void MatrixUtility::ensureViewScrollable(QTableView *view)
{
    if (!view) return;
    view->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    view->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    view->resizeColumnsToContents();
}

/************************************************************
 * @brief Download text from local or remote URL.
 ************************************************************/
bool MatrixUtility::downloadText(const QString &url, QByteArray &out)
{
    const QUrl u(url);
    if (u.isLocalFile() || QFileInfo::exists(url))
    {
        QFile f(u.isLocalFile() ? u.toLocalFile() : url);
        if (f.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            out = f.readAll();
            f.close();
            return true;
        }
        return false;
    }

    QNetworkAccessManager mgr;
    QNetworkRequest req{ QUrl(url) };
    QEventLoop loop;
    QNetworkReply *reply = mgr.get(req);
    QObject::connect(reply, &QNetworkReply::finished,
                     &loop, &QEventLoop::quit);
    loop.exec();
    if (reply->error() == QNetworkReply::NoError)
    {
        out = reply->readAll();
        reply->deleteLater();
        return true;
    }
    reply->deleteLater();
    return false;
}

/************************************************************
 * @brief Validate requirements quickly.
 ************************************************************/
bool MatrixUtility::validateRequirements(const QStringList &lines)
{
    QStringList errors;
    return validateRequirementsWithErrors(lines, errors);
}

/************************************************************
 * @brief Validate with detailed error reporting.
 ************************************************************/
bool MatrixUtility::validateRequirementsWithErrors(
    const QStringList &lines,
    QStringList &errors)
{
    errors.clear();
    if (lines.isEmpty())
    {
        errors << "Empty input: no lines to validate.";
        return false;
    }

    static const QRegularExpression re(R"(^([A-Za-z0-9_.-]+)(\[[A-Za-z0-9_.\-,\s]+\])?\s*(?:([=><!~]{1,2})\s*([^\s#;]+))?(?:\s*;[^#]+)?$)");

    bool anyMeaningful = false;
    for (int i = 0; i < lines.size(); ++i)
    {
        const QString raw = lines.at(i);
        const QString trimmed = raw.trimmed();
        if (trimmed.isEmpty() || trimmed.startsWith('#')) continue;
        anyMeaningful = true;
        if (!re.match(trimmed).hasMatch())
        {
            errors << QString("Line %1 failed: \"%2\"")
            .arg(i + 1).arg(raw);
        }
    }
    if (!anyMeaningful)
    {
        errors << "No meaningful requirement lines found.";
        return false;
    }
    return errors.isEmpty();
}

/************** End of MatrixUtility.cpp *************************/

#-------------------------------------------------------------------------------
# File: src/MatrixUtility.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MatrixUtility.h
 * @brief Utility functions for PipMatrixResolverQt.
 *
 * @author Jeffrey
 * @version 0.4
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Provides helpers for reading requirements files, writing them
 * into models, validating entries, ensuring view scrollability,
 * and downloading text resources.
 ***************************************************************/

#pragma once

#include <QString>
#include <QStringList>
#include <QByteArray>

class QStandardItemModel;
class QTableView;

namespace MatrixUtility
{
/************************************************************
     * @brief Return logs directory, create if missing.
     ************************************************************/
QString logsDir();

/************************************************************
     * @brief Return history directory, create if missing.
     ************************************************************/
QString historyDir();

/************************************************************
     * @brief Normalize GitHub blob URLs to raw URLs.
     ************************************************************/
QString normalizeRawUrl(const QString &url);

/************************************************************
     * @brief Read file lines, strip blanks and comments.
     ************************************************************/
QStringList readTextFileLines(const QString &path);

/************************************************************
     * @brief Write requirements into a one-column model.
     ************************************************************/
void writeTableToModel(QStandardItemModel *model,
                       const QStringList &lines);

/************************************************************
     * @brief Ensure scrollbars and column sizing for a view.
     ************************************************************/
void ensureViewScrollable(QTableView *view);

/************************************************************
     * @brief Download text from local or remote URL.
     ************************************************************/
bool downloadText(const QString &url, QByteArray &out);

/************************************************************
     * @brief Validate requirements quickly.
     ************************************************************/
bool validateRequirements(const QStringList &lines);

/************************************************************
     * @brief Validate with detailed error reporting.
     ************************************************************/
bool validateRequirementsWithErrors(const QStringList &lines,
                                    QStringList &errors);
}

/************** End of MatrixUtility.h **************************/

#-------------------------------------------------------------------------------
# File: src/PipToolsRunner.cpp
#-------------------------------------------------------------------------------
#include "PipToolsRunner.h"
#include <QProcess>
#include <QFile>
#include <QThread>

PipToolsRunner::PipToolsRunner(const QString &python, QObject *parent) : QObject(parent), m_python(python)
{
}

bool PipToolsRunner::runOnce(const QString &inFile, const QString &outFile)
{
    QProcess p;
    p.setProgram("pip-compile");
    p.setArguments({
        "--resolver=backtracking",
        "--prefer-binary",
        "--upgrade",
        "--output-file", outFile,
        inFile
    });

    connect(&p, &QProcess::readyReadStandardOutput, [&]()
    {
        emit logMessage(QString::fromUtf8(p.readAllStandardOutput()));
    });
    connect(&p, &QProcess::readyReadStandardError, [&]()
    {
        emit logMessage(QString::fromUtf8(p.readAllStandardError()));
    });

    p.start();
    if (!p.waitForStarted())
    {
        emit logMessage("Failed to start pip-compile process.");
        return false;
    }

    p.waitForFinished(-1);
    return p.exitStatus() == QProcess::NormalExit && p.exitCode() == 0;
}

bool PipToolsRunner::pipCompile(const QString &inFile, const QString &outFile, int retries)
{
    for (int attempt = 1; attempt <= retries; ++attempt)
    {
        emit logMessage(QString("Attempting pip-compile (try %1/%2)").arg(attempt).arg(retries));
        if (runOnce(inFile, outFile))
        {
            emit logMessage("pip-compile succeeded.");
            return true;
        }

        analyzeLog("logs/pip_compile.log");
        if (attempt < retries)
        {
            emit logMessage("Retrying in 5 seconds...");
            QThread::sleep(5);
        }
    }
    return false;
}

void PipToolsRunner::analyzeLog(const QString &logPath)
{
    QFile f(logPath);
    if (!f.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        emit logMessage("No pip-compile log found to analyze.");
        return;
    }

    const QString text = QString::fromUtf8(f.readAll());
    if (text.contains("No matching distribution found for"))
    {
        emit logMessage("Detected missing distribution; consider adjusting baseline.");
    }
    else if (text.contains("requires"))
    {
        emit logMessage("Dependency conflict detected; consider adjusting dependent baseline.");
    }
}
#-------------------------------------------------------------------------------
# File: src/PipToolsRunner.h
#-------------------------------------------------------------------------------
#pragma once
#include <QObject>

class PipToolsRunner : public QObject
{
    Q_OBJECT
public:
    explicit PipToolsRunner(const QString &python, QObject *parent = nullptr);
    bool pipCompile(const QString &inFile, const QString &outFile, int retries);

signals:
    void logMessage(const QString &line);

private:
    QString m_python;
    bool runOnce(const QString &inFile, const QString &outFile);
    void analyzeLog(const QString &logPath);
};
#-------------------------------------------------------------------------------
# File: src/ResolverEngine.cpp
#-------------------------------------------------------------------------------
#include "ResolverEngine.h"
#include "PipToolsRunner.h"

#include <QFile>
#include <QTextStream>
#include <QThread>
#include <QtMath>   // for qRound

ResolverEngine::ResolverEngine(QObject *parent)
    : QObject(parent),
    m_running(false),
    m_paused(false),
    m_stateFile("logs/ITERATION_STATE.txt"),
    valid(true)
{
}

void ResolverEngine::loadRequirementsFromFile(const QString &path)
{
    emit logMessage(QString("Loading requirements from file: %1").arg(path));
    // TODO: parse requirements.txt into m_pkgs
}

void ResolverEngine::loadRequirementsFromUrl(const QString &url)
{
    emit logMessage(QString("Fetching requirements from URL: %1").arg(url));
    // TODO: download and parse into m_pkgs
}

void ResolverEngine::start()
{
    m_running = true;
    m_paused = false;

    int combinationCount = 0;
    QFile sf(m_stateFile);
    if (sf.open(QIODevice::ReadOnly))
    {
        QTextStream ts(&sf);
        ts >> combinationCount;
        sf.close();
    }

    while (m_running)
    {
        if (m_paused)
        {
            QThread::msleep(200);
            continue;
        }

        ++combinationCount;
        QFile sfw(m_stateFile);
        if (sfw.open(QIODevice::WriteOnly | QIODevice::Truncate))
        {
            QTextStream ts(&sfw);
            ts << combinationCount;
        }

        QString inFile, comboStr;
        buildNextConstraints(inFile, comboStr);
        emit logMessage(QString("Attempt #%1: %2").arg(combinationCount).arg(comboStr));

        QString outFile = QString("logs/tmp/compiled_requirements_%1.txt").arg(combinationCount);
        PipToolsRunner runner(QString(), this);
        if (runner.pipCompile(inFile, outFile, 3))
        {
            emit successCompiled(outFile);
            break;
        }

        if (!incrementOdometer())
        {
            emit logMessage("All combinations exhausted.");
            stop();
        }

        emit progressChanged(qRound((double)combinationCount / 1000.0 * 100.0));
    }
}

void ResolverEngine::pause()
{
    m_paused = true;
}

void ResolverEngine::resume()
{
    m_paused = false;
}

void ResolverEngine::stop()
{
    m_running = false;
}

void ResolverEngine::buildNextConstraints(QString &inFile, QString &comboStr)
{
    // TODO: build constraints.in file from current indices
    inFile = "logs/tmp/temp_constraints.in";
    comboStr = "example==1.0.0";
}

bool ResolverEngine::incrementOdometer()
{
    for (int j = m_indices.size() - 1; j >= 0; --j)
    {
        m_indices[j]++;
        if (m_indices[j] <= m_maxIndices[j])
        {
            return true;
        }
        m_indices[j] = 0;
    }
    return false;
}

bool ResolverEngine::isValid() const
{
    return valid;
}

bool ResolverEngine::resolve(const QString &path)
{
    // Stub implementation: succeed if path is non-empty
    return !path.isEmpty();
}

#-------------------------------------------------------------------------------
# File: src/ResolverEngine.h
#-------------------------------------------------------------------------------
#pragma once

#include <QObject>
#include <QVector>
#include <QStringList>
#include <QString>

struct PackageCandidates
{
    QString pkg;
    QStringList versions;
};

class ResolverEngine : public QObject
{
    Q_OBJECT
public:
    explicit ResolverEngine(QObject *parent = nullptr);

    void loadRequirementsFromFile(const QString &path);
    void loadRequirementsFromUrl(const QString &url);

    void start();
    void pause();
    void resume();
    void stop();

    // Example methods for unit tests
    bool isValid() const;
    bool resolve(const QString &path);

signals:
    void logMessage(const QString &line);
    void progressChanged(int percent);
    void successCompiled(const QString &compiledPath);

private:
    QVector<PackageCandidates> m_pkgs;
    QVector<int> m_indices;
    QVector<int> m_maxIndices;
    bool m_running;
    bool m_paused;
    QString m_stateFile;
    bool valid;

    void buildNextConstraints(QString &inFile, QString &comboStr);
    bool incrementOdometer();
};

#-------------------------------------------------------------------------------
# File: src/VenvManager.cpp
#-------------------------------------------------------------------------------
#include "VenvManager.h"
#include <QDebug>

VenvManager::VenvManager(QObject *parent) : QObject(parent)
{
}

bool VenvManager::createVenv(const QString &dir, const QString &pythonVer)
{
    // TODO: implement actual venv creation logic
    emit logMessage(QString("Creating venv at %1 with Python %2").arg(dir, pythonVer));
    return true;
}

bool VenvManager::upgradePip(const QString &pipVer, const QString &pipToolsVer)
{
    // TODO: implement actual pip upgrade logic
    emit logMessage(QString("Upgrading pip to %1 and pip-tools to %2").arg(pipVer, pipToolsVer));
    return true;
}

bool VenvManager::createOrUpdate(const QString &dir,
                                 const QString &pythonVer,
                                 const QString &pipVer,
                                 const QString &pipToolsVer)
{
    emit logMessage("Starting createOrUpdate workflow...");

    if (!createVenv(dir, pythonVer)) {
        emit logMessage("createVenv failed");
        return false;
    }

    if (!upgradePip(pipVer, pipToolsVer)) {
        emit logMessage("upgradePip failed");
        return false;
    }

    emit logMessage("createOrUpdate completed successfully");
    return true;
}

#-------------------------------------------------------------------------------
# File: src/VenvManager.h
#-------------------------------------------------------------------------------
#pragma once
#include <QObject>
#include <QString>

class VenvManager : public QObject
{
    Q_OBJECT
public:
    explicit VenvManager(QObject *parent = nullptr);

    // Existing API
    bool createVenv(const QString &dir, const QString &pythonVer);
    bool upgradePip(const QString &pipVer, const QString &pipToolsVer);

    // New convenience wrapper
    bool createOrUpdate(const QString &dir = "venv",
                        const QString &pythonVer = "3.11",
                        const QString &pipVer = "24.0",
                        const QString &pipToolsVer = "7.4.1");

signals:
    void logMessage(const QString &line);
};

#-------------------------------------------------------------------------------
# File: src/main.cpp
#-------------------------------------------------------------------------------
#include <QApplication>
#include <QTranslator>
#include <QLocale>
#include <QFile>
#include <QDebug>
#include <QIcon>
#include "MainWindow.h"

int main(int argc, char *argv[])
{
        QApplication theApplication(argc, argv);

        // Register compiled resources
        Q_INIT_RESOURCE(PipMatrixResolverQt);

        // Enable icons in menus globally
        theApplication.setAttribute(Qt::AA_DontShowIconsInMenus, false);

        // Set application icon
        QApplication::setWindowIcon(QIcon(":/icons/icons/app.svg"));

        // Diagnostics
        qDebug() << "[RESOURCE CHECK] :/icons/icons/open.svg exists:" << QFile::exists(":/icons/icons/open.svg");

        // Translation loading
        const QString languageCode = QLocale::system().name().split('_').first();
        auto loadTranslator = [&](const QString &baseName) -> bool
        {
            QTranslator *tr = new QTranslator(&theApplication);
            const QString qmFile = QString(":/translations/%1_%2.qm").arg(baseName, languageCode);
            if (tr->load(qmFile))
            {
                theApplication.installTranslator(tr);
                qDebug() << "Loaded translation:" << qmFile;
                return true;
            }
            delete tr;
            return false;
        };

        loadTranslator("PipMatrixResolverQt");
        loadTranslator("MatrixUtility");
        loadTranslator("MatrixHistory");

        MainWindow w;
        w.show();
        return theApplication.exec();
}

#-------------------------------------------------------------------------------
# File: tests/gtest_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity)
{
    ResolverEngine engine;
    // Replace with a real method from your class
    EXPECT_TRUE(engine.isValid());
}

#-------------------------------------------------------------------------------
# File: tests/qt_test_main.cpp
#-------------------------------------------------------------------------------
#include <QTest>
#include "test_mainwindow.h"

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    int status = 0;
    status |= QTest::qExec(new TestMainWindow, argc, argv);
    return status;
}

#-------------------------------------------------------------------------------
# File: tests/qtest_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject {
    Q_OBJECT

private slots:
    void initTestCase() {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

QTEST_MAIN(TestMainWindow)
#include "qtest_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_main.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>

int main(int argc, char **argv) 
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

#-------------------------------------------------------------------------------
# File: tests/test_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase() 
    {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

#include "test_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity) 
{
    ResolverEngine engine;
    EXPECT_TRUE(engine.isValid());
}

# Directory Structure
#-------------------------------------------------------------------------------
├── icons
│   ├── app.svg
│   ├── batch.svg
│   ├── cancel.svg
│   ├── info.svg
│   ├── open.svg
│   ├── pause.svg
│   ├── readme.svg
│   ├── resolve.svg
│   ├── resume.svg
│   ├── stop.svg
│   ├── url.svg
│   └── venv.svg
├── src
│   ├── BatchRunner.cpp
│   ├── BatchRunner.h
│   ├── MainWindow.cpp
│   ├── MainWindow.h
│   ├── MainWindow.ui
│   ├── MatrixHistory.cpp
│   ├── MatrixHistory.h
│   ├── MatrixUtility.cpp
│   ├── MatrixUtility.h
│   ├── PipToolsRunner.cpp
│   ├── PipToolsRunner.h
│   ├── ResolverEngine.cpp
│   ├── ResolverEngine.h
│   ├── VenvManager.cpp
│   ├── VenvManager.h
│   └── main.cpp
├── src_text
│   ├── BatchRunner.cpp.txt
│   ├── BatchRunner.h.txt
│   ├── MainWindow.cpp.txt
│   ├── MainWindow.h.txt
│   ├── MainWindow.ui.autosave.txt
│   ├── MainWindow.ui.txt
│   ├── MatrixHistory.cpp.txt
│   ├── MatrixHistory.h.txt
│   ├── MatrixHistory.ui.txt
│   ├── MatrixUtility.cpp.txt
│   ├── MatrixUtility.h.txt
│   ├── PipMatrixResolverQt.qrc.txt
│   ├── PipToolsRunner.cpp.txt
│   ├── PipToolsRunner.h.txt
│   ├── ResolverEngine.cpp.txt
│   ├── ResolverEngine.h.txt
│   ├── VenvManager.cpp.txt
│   ├── VenvManager.h.txt
│   └── main.cpp.txt
├── tests
│   ├── gtest_resolver.cpp
│   ├── qt_test_main.cpp
│   ├── qtest_mainwindow.cpp
│   ├── test_main.cpp
│   ├── test_mainwindow.cpp
│   └── test_resolver.cpp
├── translations
│   ├── MatrixHistory_en.qm
│   ├── MatrixHistory_en.ts
│   ├── MatrixHistory_es.qm
│   ├── MatrixHistory_es.ts
│   ├── MatrixUtility_en.qm
│   ├── MatrixUtility_en.ts
│   ├── MatrixUtility_es.qm
│   ├── MatrixUtility_es.ts
│   ├── PipMatrixResolverQt_en.qm
│   ├── PipMatrixResolverQt_en.ts
│   ├── PipMatrixResolverQt_es.qm
│   └── PipMatrixResolverQt_es.ts
├── .gitignore
├── CMakeLists.txt
├── CMakeLists.txt.user
├── LICENSE
├── PipMatrixResolverQt.qrc
├── Project-Source.txt
├── README.md
├── cleanbash.sh
├── requirements.txt
├── source_files.txt
├── src2txt.bat
└── src2txt.sh

#*** End of file PipMatrixResolver ***
