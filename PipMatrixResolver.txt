#===============================================================================
# Project: PipMatrixResolver
# Generated on: 2025-11-04 11:20:26
# OS: WSL on Ubuntu: 24.04
# This file is used to show full source code, cmake, read me, and file locates.
#================================C

#-------------------------------------------------------------------------------
# File: CMakeLists.txt
#-------------------------------------------------------------------------------
cmake_minimum_required(VERSION 3.24)
project(PipMatrixResolverQt VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

find_package(Qt6 6.10 REQUIRED COMPONENTS Core Gui Widgets LinguistTools Network Concurrent Svg)
qt_standard_project_setup()

# Translations
set(TS_FILES
    translations/PipMatrixResolverQt_en.ts
    translations/PipMatrixResolverQt_es.ts
)
qt_add_translation(QM_FILES ${TS_FILES})

# Resources (icons + translations)
qt_add_resources(APP_RESOURCES PipMatrixResolverQt.qrc)

# Executable
qt_add_executable(PipMatrixResolverQt
    src/main.cpp
    src/MainWindow.cpp src/MainWindow.h
    src/CommandsTab.cpp src/CommandsTab.h
    ${APP_RESOURCES}
    ${QM_FILES}
)

target_link_libraries(PipMatrixResolverQt PRIVATE
    Qt6::Core
    Qt6::Gui
    Qt6::Widgets
    Qt6::Network
    Qt6::Concurrent
    Qt6::Svg
)
target_include_directories(PipMatrixResolverQt PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Install the executable
install(TARGETS PipMatrixResolverQt DESTINATION bin)

# Install Python scripts and requirements files
install(FILES
    src/venv_manager.py
    src/requirements.in
    src/requirements.txt
    DESTINATION share/pipmatrixresolverqt/python
)

# Optionally, show a message after install
install(CODE "message(\"\nPython scripts installed to: \${CMAKE_INSTALL_PREFIX}/share/pipmatrixresolverqt/python\nPlease ensure you have Python 3 and pip installed on your system.\")")

# Deployment logic
if(WIN32)
    find_program(WINDEPLOYQT_EXECUTABLE NAMES windeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(WINDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${WINDEPLOYQT_EXECUTABLE} --verbose 0 --no-compiler-runtime "$<TARGET_FILE:PipMatrixResolverQt>"
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (Windows)"
        )
    endif()
elseif(APPLE)
    find_program(MACDEPLOYQT_EXECUTABLE NAMES macdeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(MACDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${MACDEPLOYQT_EXECUTABLE} "$<TARGET_BUNDLE_DIR:PipMatrixResolverQt>" -verbose=1
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (macOS)"
        )
    endif()
elseif(UNIX)
    message(STATUS "âœ… Linux build â€” Qt runtime deployment handled by system packages.")
endif()

# Packaging with CPack (Qt Installer, NSIS, DEB/RPM)
include(InstallRequiredSystemLibraries)
set(CPACK_PACKAGE_NAME "PipMatrixResolverQt")
set(CPACK_PACKAGE_VENDOR "AM-Tower")
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Python venv and pip-tools GUI manager")
set(CPACK_PACKAGE_VERSION_MAJOR "0")
set(CPACK_PACKAGE_VERSION_MINOR "1")
set(CPACK_PACKAGE_VERSION_PATCH "0")
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")
set(CPACK_RESOURCE_FILE_README "${CMAKE_CURRENT_SOURCE_DIR}/README.md")
set(CPACK_PACKAGE_EXECUTABLES "PipMatrixResolverQt" "PipMatrixResolverQt")

if(WIN32)
    set(CPACK_GENERATOR "NSIS")
    set(CPACK_NSIS_DISPLAY_NAME "PipMatrixResolverQt")
    set(CPACK_NSIS_PACKAGE_NAME "PipMatrixResolverQt")
    set(CPACK_NSIS_CONTACT "Occupant.AM.Tower@gmail.com")
elseif(APPLE)
    set(CPACK_GENERATOR "DragNDrop")
else()
    set(CPACK_GENERATOR "DEB;RPM")
    set(CPACK_DEBIAN_PACKAGE_MAINTAINER "Jeffrey Scott Flesher")
endif()

include(CPack)

#-------------------------------------------------------------------------------
# File: PipMatrixResolverQt.qrc
#-------------------------------------------------------------------------------
<RCC>
    <!-- Icons -->
    <qresource prefix="/icons">
        <file>icons/app.svg</file>
        <file>icons/open.svg</file>
        <file>icons/url.svg</file>
        <file>icons/venv.svg</file>
        <file>icons/resolve.svg</file>
        <file>icons/pause.svg</file>
        <file>icons/resume.svg</file>
        <file>icons/stop.svg</file>
        <file>icons/batch.svg</file>
        <file>icons/info.svg</file>
        <file>icons/readme.svg</file>
    </qresource>

    <!-- Translations -->
    <qresource prefix="/translations">
        <file>translations/PipMatrixResolverQt_en.qm</file>
        <file>translations/PipMatrixResolverQt_es.qm</file>
    </qresource>

    <!-- Docs -->
    <qresource prefix="/docs">
        <file>README.md</file>
    </qresource>

</RCC>
#-------------------------------------------------------------------------------
# File: README.md
#-------------------------------------------------------------------------------
# Pip-Matrix-Resolver
This is a Qt C++ GUI,
that allows you to open requirements.txt
and create a working Python environment terminal.
* It has tabs to show the function it provides.
* It has a Python Terminal to run commands and applications.
* You can create batch files to process Python calls.

A cross-platform Qt C++ GUI for resolving Python requirements.txt matrixes/matrices
to build a Python environment to run Python applications.
and managing virtual environments, 
for running batch commands.

## Use-Case
The best use case for this application,
is when you find it hard to install the Python application.
You get stuck in Dependency Hell.
Every computer OS, release, and verion, can have a different environment.
This application will read a requirements.txt locally, 
or over the web, normally from a GitHub repository.
I assignes a matrix for all packages and their versions.
You can adjust from the base, how much range you want to give it.
By default it has 3 versions, but you can change the levels.

The matrix will read the file requirements.sh, 
and will update the matrix resolver values that resolve. 
It will use the operator == to pin exact version.


The time to run the test will vary, but here is the math.
If you have 18 packages, each with 3 possible versions, 
that gives you 18 independent variables with 3 options each. 
The total number of possible combinations is 
318=387,420,4893^18 = 387,420,489. 
If each test takes 5 seconds, 
running all combinations would require about 1.9 billion seconds, 
or roughly 61.4 years of nonstop testingâ€”assuming no parallelism, 
no caching, and no skipped failures. 
Clearly, exhaustive testing is impractical. 
To optimize, we can use tools like pipâ€‘tools to resolve dependencies up front, 
prune invalid combinations, and lock down a consistent set of requirements, 
dramatically reducing the number of cases we actually need to test.

The reason I wrote this application:

I wrote this to use SadTalker and MuseTalk.
The are Pyton applications that take an image and wav file as arguments.
I will animate the face in the image, to lip sync the wav file.
This is called a talking heads video.
It will allow me to install it and keep it updated on GitHub.
I can create a batch file to process images and wav files into videos.

## Status:
* Not working.
* Open requirements.txt in Local and Web modes works.
* Terminal is in work.
* Just starting this project, and it will take time to get to a working version.

#### Features
* Resolve Python dependency matrices with pip-tools
* Manage virtual environments (create, upgrade pip and pip-tools)
* Batch convert audio + image to MP4 with ffmpeg
* Qt GUI with menus, log view, progress bar
* Translation support (English and Spanish)

## Build Instructions
Use Qt build or:
```
cmake -S . -B build
cmake --build build
```
### Create the installer/package:
* cpack

On Windows, windeployqt is run automatically after build.

## Qt Project Structure
```
/
â”œâ”€â”€ ðŸ“‚ build
â”œâ”€â”€ ðŸ“‚ icons
â”‚   â”œâ”€â”€ ðŸ“„ app.svg
â”‚   â”œâ”€â”€ ðŸ“„ batch.svg
â”‚   â”œâ”€â”€ ðŸ“„ cancel.svg
â”‚   â”œâ”€â”€ ðŸ“„ info.svg
â”‚   â”œâ”€â”€ ðŸ“„ open.svg
â”‚   â”œâ”€â”€ ðŸ“„ pause.svg
â”‚   â”œâ”€â”€ ðŸ“„ readme.svg
â”‚   â”œâ”€â”€ ðŸ“„ resolve.svg
â”‚   â”œâ”€â”€ ðŸ“„ resume.svg
â”‚   â”œâ”€â”€ ðŸ“„ stop.svg
â”‚   â”œâ”€â”€ ðŸ“„ url.svg
â”‚   â””â”€â”€ ðŸ“„ venv.svg
â”œâ”€â”€ ðŸ“‚ src
â”‚   â”œâ”€â”€ ðŸ“„ MainWindow.cpp
â”‚   â”œâ”€â”€ ðŸ“„ MainWindow.h
â”‚   â”œâ”€â”€ ðŸ“„ CommandsTab.cpp
â”‚   â”œâ”€â”€ ðŸ“„ CommandsTab.h
â”‚   â””â”€â”€ ðŸ“„ main.cpp
â”œâ”€â”€ ðŸ“‚ tests
â”‚   â”œâ”€â”€ ðŸ“„ gtest_resolver.cpp
â”‚   â”œâ”€â”€ ðŸ“„ qt_test_main.cpp
â”‚   â”œâ”€â”€ ðŸ“„ qtest_mainwindow.cpp
â”‚   â”œâ”€â”€ ðŸ“„ test_main.cpp
â”‚   â”œâ”€â”€ ðŸ“„ test_mainwindow.cpp
â”‚   â””â”€â”€ ðŸ“„ test_resolver.cpp
â”œâ”€â”€ ðŸ“‚ translations
â”‚   â”œâ”€â”€ ðŸ“„ PipMatrixResolverQt_en.qm
â”‚   â”œâ”€â”€ ðŸ“„ PipMatrixResolverQt_en.ts
â”‚   â”œâ”€â”€ ðŸ“„ PipMatrixResolverQt_es.qm
â”‚   â””â”€â”€ ðŸ“„ PipMatrixResolverQt_es.ts
â”œâ”€â”€ ðŸ“„ .gitignore
â”œâ”€â”€ ðŸ“„ CMakeLists.txt
â”œâ”€â”€ ðŸ“„ LICENSE
â”œâ”€â”€ ðŸ“„ PipMatrixResolverQt.qrc
â”œâ”€â”€ ðŸ“„ README.md
â”œâ”€â”€ ðŸ“„ cleanbash.sh
â”œâ”€â”€ ðŸ“„ requirements.txt
â”œâ”€â”€ ðŸ“„ src2txt.bat
â””â”€â”€ ðŸ“„ src2txt.sh
```
## File Descriptions

#### Root
* CMakeLists.txt â€“ Build script: compiles sources, generates qm from ts, bundles resources
* PipMatrixResolverQt.qrc â€“ Qt resource file embedding icons and compiled translations


#### resources/icons
* SVG icons used in menus and toolbars


#### src
* main.cpp â€“ Application entry point. Sets up QApplication, loads translations, shows MainWindow
* MainWindow.h/.cpp â€“ Main GUI window. Defines menus, log view, progress bar, and user actions.
* CommandsTab.h/cpp -

#### translations
* PipMatrixResolverQt_en.ts â€“ English translation source
* PipMatrixResolverQt_es.ts â€“ Spanish translation source
* Both are compiled into qm at build time and embedded

#### Usage

* File â†’ Open requirements file â€“ Load a local requirements.txt
* Tools â†’ Create/Update venv â€“ Create or update a Python virtual environment
* Tools â†’ Resolve matrix â€“ Start iterative resolution of package versions
* Batch â†’ Run batch conversion to mp4 â€“ Combine audio and image into MP4
* Help â†’ About â€“ Show app info

## Terminal Tab â€” What You Can Do
* Run Python scripts:
    * python myscript.py

* Install a package:
    * pip install package_name

* Uninstall a package:
    * pip uninstall package_name

* List installed packages:
    * pip list

* Show package details:
    * pip show package_name

* Upgrade a package:
    * pip install --upgrade package_name

* Run pip-tools commands:
    * pip-compile requirements.in
    * pip-sync

* Check Python version:
    * python --version

* Check pip version:
    * pip --version

* Run any shell command:
    * On Windows: dir
    * On Linux/macOS: ls

* View contents of a file:
    * On Windows: type filename.txt
    * On Linux/macOS: cat filename.txt

* Check environment variables:
    * On Windows: set
    * On Linux/macOS: env

* Run batch or shell scripts:
    * bash script.sh (Linux/macOS)
    * script.bat (Windows)

* Deactivate the virtual environment (if you started a shell session manually):
    * deactivate

## License:
* Unlicensed, MIT or your chosen license

## End of Readme

#-------------------------------------------------------------------------------
# File: src/CommandsTab.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file CommandsTab.cpp
 * @brief Implements the CommandsTab class for dynamic command UI,
 *        batch execution, project editing, and JSON persistence.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.7
 * @date    2025-11-03
 * @section License MIT
 * @section DESCRIPTION
 * This file contains the implementation of CommandsTab widget.
 ***************************************************************/
#include "CommandsTab.h"
#include <QFileInfo>
#include <QMessageBox>
#include <QInputDialog>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QDialogButtonBox>
#include <QScrollArea>
#include <QTextStream>

/****************************************************************
 * @brief Constructor: Builds the UI and loads initial state.
 ***************************************************************/
CommandsTab::CommandsTab(QWidget *parent) : QWidget(parent)
{
    buildUI();
    loadProjects("projects.json");
}

/****************************************************************
 * @brief Builds the static UI components.
 ***************************************************************/
void CommandsTab::buildUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);

    // Project selector and management buttons
    QHBoxLayout *projLayout = new QHBoxLayout;
    projectDropdown = new QComboBox;
    connect(projectDropdown, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &CommandsTab::onProjectChanged);
    addProjectButton = new QPushButton("Add");
    editProjectButton = new QPushButton("Edit");
    deleteProjectButton = new QPushButton("Delete");
    connect(addProjectButton, &QPushButton::clicked, this, &CommandsTab::onAddProject);
    connect(editProjectButton, &QPushButton::clicked, this, &CommandsTab::onEditProject);
    connect(deleteProjectButton, &QPushButton::clicked, this, &CommandsTab::onDeleteProject);
    projLayout->addWidget(new QLabel("Project:"));
    projLayout->addWidget(projectDropdown);
    projLayout->addWidget(addProjectButton);
    projLayout->addWidget(editProjectButton);
    projLayout->addWidget(deleteProjectButton);
    mainLayout->addLayout(projLayout);

    // Dynamic inputs area
    inputsLayout = new QVBoxLayout;
    mainLayout->addLayout(inputsLayout);

    // Extra arguments
    extraArgsEdit = new QLineEdit;
    connect(extraArgsEdit, &QLineEdit::textChanged, this, &CommandsTab::updatePreview);
    mainLayout->addWidget(new QLabel("Extra Arguments:"));
    mainLayout->addWidget(extraArgsEdit);

    // Command preview + clear button
    QHBoxLayout *previewLayout = new QHBoxLayout;
    commandPreview = new QLineEdit;
    commandPreview->setReadOnly(true);
    clearButton = new QToolButton;
    clearButton->setText("X");
    connect(clearButton, &QToolButton::clicked, this, &CommandsTab::onClearCommand);
    previewLayout->addWidget(commandPreview);
    previewLayout->addWidget(clearButton);
    mainLayout->addLayout(previewLayout);

    // Batch file selector
    QHBoxLayout *batchLayout = new QHBoxLayout;
    batchFileEdit = new QLineEdit;
    batchFileEdit->setPlaceholderText("Batch file (one path per line)");
    QPushButton *browseBatchBtn = new QPushButton("Browse");
    connect(browseBatchBtn, &QPushButton::clicked, this, &CommandsTab::onBrowseBatchFile);
    batchLayout->addWidget(batchFileEdit);
    batchLayout->addWidget(browseBatchBtn);
    mainLayout->addLayout(batchLayout);

    // Output console
    outputConsole = new QTextEdit;
    outputConsole->setReadOnly(true);
    mainLayout->addWidget(new QLabel("Command Output:"));
    mainLayout->addWidget(outputConsole);

    // Run buttons
    QHBoxLayout *runLayout = new QHBoxLayout;
    runButton = new QPushButton("Run Command");
    runBatchButton = new QPushButton("Run Batch");
    connect(runButton, &QPushButton::clicked, this, &CommandsTab::onRunCommand);
    connect(runBatchButton, &QPushButton::clicked, this, &CommandsTab::onRunBatch);
    runLayout->addWidget(runButton);
    runLayout->addWidget(runBatchButton);
    mainLayout->addLayout(runLayout);
}

/****************************************************************
 * @brief Loads projects from a JSON file.
 ***************************************************************/
bool CommandsTab::loadProjects(const QString &jsonPath)
{
    QFile file(jsonPath);
    if (!file.open(QIODevice::ReadOnly))
    {
        return false;
    }

    QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
    QJsonArray projArray = doc["projects"].toArray();

    projects.clear();
    projectDropdown->clear();

    for (int i = 0; i < projArray.size(); ++i)
    {
        QJsonObject obj = projArray.at(i).toObject();
        ProjectDef proj;
        proj.name = obj["name"].toString();
        proj.scriptPath = obj["script"].toString();
        proj.extraArgs = obj["extra_args"].toString();

        QJsonArray inputsArr = obj["inputs"].toArray();
        for (int j = 0; j < inputsArr.size(); ++j)
        {
            QJsonObject inObj = inputsArr.at(j).toObject();
            proj.inputs.append({inObj["label"].toString(), inObj["switch"].toString()});
        }

        projects.append(proj);
        projectDropdown->addItem(proj.name);
    }
    if (!projects.isEmpty())
    {
        onProjectChanged(0);
    }
    return true;
}

/****************************************************************
 * @brief Saves projects to a JSON file.
 ***************************************************************/
bool CommandsTab::saveProjects(const QString &jsonPath)
{
    QJsonArray arr;
    for (int i = 0; i < projects.size(); ++i)
    {
        const ProjectDef &proj = projects.at(i);
        QJsonObject obj;
        obj["name"] = proj.name;
        obj["script"] = proj.scriptPath;
        obj["extra_args"] = proj.extraArgs;
        QJsonArray inputsArr;
        for (int j = 0; j < proj.inputs.size(); ++j)
        {
            const InputDef &input = proj.inputs.at(j);
            QJsonObject inObj;
            inObj["label"] = input.label;
            inObj["switch"] = input.switchName;
            inputsArr.append(inObj);
        }
        obj["inputs"] = inputsArr;
        arr.append(obj);
    }
    QJsonObject root;
    root["projects"] = arr;
    QFile file(jsonPath);
    if (!file.open(QIODevice::WriteOnly))
    {
        return false;
    }
    file.write(QJsonDocument(root).toJson());
    return true;
}

/****************************************************************
 * @brief Handles project selection change.
 ***************************************************************/
void CommandsTab::onProjectChanged(int index)
{
    if (index < 0 || index >= projects.size())
    {
        return;
    }
    rebuildInputs(projects.at(index));
    extraArgsEdit->setText(projects.at(index).extraArgs);
    updatePreview();
}

/****************************************************************
 * @brief Rebuilds input fields dynamically.
 ***************************************************************/
void CommandsTab::rebuildInputs(const ProjectDef &proj)
{
    QLayoutItem *child;
    while ((child = inputsLayout->takeAt(0)) != nullptr)
    {
        delete child->widget();
        delete child;
    }
    inputEdits.clear();

    for (int i = 0; i < proj.inputs.size(); ++i)
    {
        const InputDef &input = proj.inputs.at(i);
        auto lbl = new QLabel(input.label);
        auto edit = new QLineEdit;
        connect(edit, &QLineEdit::textChanged, this, &CommandsTab::updatePreview);
        inputsLayout->addWidget(lbl);
        inputsLayout->addWidget(edit);
        inputEdits.append(edit);
    }
}

/****************************************************************
 * @brief Builds the full command string.
 ***************************************************************/
QString CommandsTab::buildCommand() const
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        return QString();
    }

    const ProjectDef &proj = projects.at(index);
    QString cmd = QString("python \"%1\" ").arg(proj.scriptPath);

    for (int i = 0; i < inputEdits.size(); ++i)
    {
        QString val = inputEdits.at(i)->text().trimmed();
        if (!val.isEmpty())
        {
            cmd += QString("%1 \"%2\" ").arg(proj.inputs.at(i).switchName, val);
        }
    }

    if (!extraArgsEdit->text().isEmpty())
    {
        cmd += extraArgsEdit->text();
    }

    return cmd.trimmed();
}

/****************************************************************
 * @brief Validates script and input files exist.
 ***************************************************************/
bool CommandsTab::validateFiles(QString &errorMsg) const
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        errorMsg = "Invalid project selected.";
        return false;
    }

    QFileInfo scriptInfo(projects.at(index).scriptPath);
    if (!scriptInfo.exists())
    {
        errorMsg = "Script file does not exist.";
        return false;
    }

    for (int i = 0; i < inputEdits.size(); ++i)
    {
        if (!inputEdits.at(i)->text().isEmpty())
        {
            QFileInfo fi(inputEdits.at(i)->text());
            if (!fi.exists())
            {
                errorMsg = QString("Input file missing: %1").arg(inputEdits.at(i)->text());
                return false;
            }
        }
    }
    return true;
}

/****************************************************************
 * @brief Updates the command preview.
 ***************************************************************/
void CommandsTab::updatePreview()
{
    commandPreview->setText(buildCommand());
}

/****************************************************************
 * @brief Runs the command using QProcess.
 ***************************************************************/
void CommandsTab::onRunCommand()
{
    QString errorMsg;
    if (!validateFiles(errorMsg))
    {
        QMessageBox::critical(this, "Validation Error", errorMsg);
        return;
    }

    QString cmd = buildCommand();
    outputConsole->append(QString("Running: %1").arg(cmd));
    executeCommand(cmd);
}

/****************************************************************
 * @brief Runs batch commands from a file.
 ***************************************************************/
void CommandsTab::onRunBatch()
{
    QString batchFile = batchFileEdit->text();
    QFile file(batchFile);
    if (!file.open(QIODevice::ReadOnly))
    {
        QMessageBox::critical(this, "Error", "Cannot open batch file.");
        return;
    }

    QTextStream in(&file);
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        QMessageBox::critical(this, "Error", "No project selected.");
        return;
    }
    const ProjectDef &proj = projects.at(index);

    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
        if (line.isEmpty()) continue;

        QStringList batchInputs = line.split(' ', Qt::SkipEmptyParts);
        for (int i = 0; i < inputEdits.size(); ++i)
        {
            if (i < batchInputs.size())
            {
                inputEdits.at(i)->setText(batchInputs.at(i));
            }
            else
            {
                inputEdits.at(i)->clear();
            }
        }
        QString cmd = buildCommand();
        outputConsole->append(QString("Batch Running: %1").arg(cmd));
        executeCommand(cmd);
    }
}

/****************************************************************
 * @brief Executes a command and streams output.
 ***************************************************************/
void CommandsTab::executeCommand(const QString &cmd)
{
    QProcess *proc = new QProcess(this);
    proc->setProcessChannelMode(QProcess::MergedChannels);
    connect(proc, &QProcess::readyReadStandardOutput, [this, proc]()
            {
                outputConsole->append(proc->readAllStandardOutput());
            });
    connect(proc, &QProcess::readyReadStandardError, [this, proc]()
            {
                outputConsole->append(proc->readAllStandardError());
            });
    proc->start(cmd);
}

/****************************************************************
 * @brief Clears the command preview.
 ***************************************************************/
void CommandsTab::onClearCommand()
{
    commandPreview->clear();
}

/****************************************************************
 * @brief Opens a file dialog to select batch file.
 ***************************************************************/
void CommandsTab::onBrowseBatchFile()
{
    QString fileName = QFileDialog::getOpenFileName(this, "Select Batch File", QString(), "Text Files (*.txt);;All Files (*)");
    if (!fileName.isEmpty())
    {
        batchFileEdit->setText(fileName);
    }
}

/****************************************************************
 * @brief Shows the project editor dialog for add/edit.
 ***************************************************************/
bool CommandsTab::showProjectDialog(ProjectDef &proj, bool isEdit)
{
    QDialog dialog(this);
    dialog.setWindowTitle(isEdit ? "Edit Project" : "Add Project");
    QFormLayout *form = new QFormLayout(&dialog);

    QLineEdit *nameEdit = new QLineEdit(proj.name, &dialog);
    QLineEdit *scriptEdit = new QLineEdit(proj.scriptPath, &dialog);
    QLineEdit *extraArgsEditDlg = new QLineEdit(proj.extraArgs, &dialog);
    QSpinBox *inputCountSpin = new QSpinBox(&dialog);
    inputCountSpin->setRange(1, 10);
    inputCountSpin->setValue(proj.inputs.isEmpty() ? 2 : proj.inputs.size());

    QVector<QLineEdit*> labelEdits;
    QVector<QLineEdit*> switchEdits;
    QVBoxLayout *inputsVBox = new QVBoxLayout;
    for (int i = 0; i < inputCountSpin->value(); ++i)
    {
        QHBoxLayout *row = new QHBoxLayout;
        QLineEdit *lblEdit = new QLineEdit(i < proj.inputs.size() ? proj.inputs.at(i).label : QString("input%1").arg(i+1), &dialog);
        QLineEdit *swEdit = new QLineEdit(i < proj.inputs.size() ? proj.inputs.at(i).switchName : "", &dialog);
        row->addWidget(new QLabel("Label:"));
        row->addWidget(lblEdit);
        row->addWidget(new QLabel("Switch:"));
        row->addWidget(swEdit);
        inputsVBox->addLayout(row);
        labelEdits.append(lblEdit);
        switchEdits.append(swEdit);
    }
    connect(inputCountSpin, QOverload<int>::of(&QSpinBox::valueChanged),
            [inputsVBox, &labelEdits, &switchEdits, &dialog](int count)
            {
                QLayoutItem *child;
                while ((child = inputsVBox->takeAt(0)) != nullptr)
                {
                    delete child->widget();
                    delete child;
                }
                labelEdits.clear();
                switchEdits.clear();
                for (int i = 0; i < count; ++i)
                {
                    QHBoxLayout *row = new QHBoxLayout;
                    QLineEdit *lblEdit = new QLineEdit(QString("input%1").arg(i+1), &dialog);
                    QLineEdit *swEdit = new QLineEdit("", &dialog);
                    row->addWidget(new QLabel("Label:"));
                    row->addWidget(lblEdit);
                    row->addWidget(new QLabel("Switch:"));
                    row->addWidget(swEdit);
                    inputsVBox->addLayout(row);
                    labelEdits.append(lblEdit);
                    switchEdits.append(swEdit);
                }
            }
            );

    form->addRow("Project Name:", nameEdit);
    form->addRow("Script Path:", scriptEdit);
    form->addRow("Extra Args:", extraArgsEditDlg);
    form->addRow("Number of Inputs:", inputCountSpin);
    form->addRow("Inputs:", inputsVBox);

    QDialogButtonBox *buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, &dialog);
    form->addRow(buttons);
    connect(buttons, &QDialogButtonBox::accepted, &dialog, &QDialog::accept);
    connect(buttons, &QDialogButtonBox::rejected, &dialog, &QDialog::reject);

    if (dialog.exec() == QDialog::Accepted)
    {
        proj.name = nameEdit->text();
        proj.scriptPath = scriptEdit->text();
        proj.extraArgs = extraArgsEditDlg->text();
        proj.inputs.clear();
        for (int i = 0; i < labelEdits.size(); ++i)
        {
            proj.inputs.append({labelEdits.at(i)->text(), switchEdits.at(i)->text()});
        }
        return true;
    }
    return false;
}

/****************************************************************
 * @brief Adds a new project.
 ***************************************************************/
void CommandsTab::onAddProject()
{
    ProjectDef proj;
    if (showProjectDialog(proj, false))
    {
        projects.append(proj);
        saveProjects("projects.json");
        refreshProjectDropdown();
        projectDropdown->setCurrentIndex(projects.size() - 1);
    }
}

/****************************************************************
 * @brief Edits the selected project.
 ***************************************************************/
void CommandsTab::onEditProject()
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        return;
    }
    ProjectDef proj = projects.at(index);
    if (showProjectDialog(proj, true))
    {
        projects[index] = proj;
        saveProjects("projects.json");
        refreshProjectDropdown();
        projectDropdown->setCurrentIndex(index);
    }
}

/****************************************************************
 * @brief Deletes the selected project.
 ***************************************************************/
void CommandsTab::onDeleteProject()
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        return;
    }
    if (QMessageBox::question(this, "Delete Project", "Are you sure you want to delete this project?") == QMessageBox::Yes)
    {
        projects.remove(index);
        saveProjects("projects.json");
        refreshProjectDropdown();
        if (!projects.isEmpty())
        {
            projectDropdown->setCurrentIndex(0);
        }
    }
}

/****************************************************************
 *es.
 ***************************************************************/
void CommandsTab::refreshProjectDropdown()
{
    projectDropdown->clear();
    for (int i = 0; i < projects.size(); ++i)
    {
        projectDropdown->addItem(projects.at(i).name);
    }
}
/************** End of CommandsTab.cpp **************************/

#-------------------------------------------------------------------------------
# File: src/CommandsTab.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file CommandsTab.h
 * @brief Declares the CommandsTab class for dynamic command UI,
 *        batch execution, project editing, and JSON persistence.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.7
 * @date    2025-11-03
 * @section License MIT
 * @section DESCRIPTION
 * This file defines the CommandsTab widget for PipMatrixResolverQt.
 * Features:
 *   - Dynamic UI from JSON schema
 *   - Batch command execution
 *   - Project add/edit/delete dialogs
 *   - JSON save/load
 *   - Real-time output streaming
 *   - Doxygen headers and C-style braces
 ***************************************************************/
#ifndef COMMANDSTAB_H
#define COMMANDSTAB_H

#include <QWidget>
#include <QComboBox>
#include <QLineEdit>
#include <QPushButton>
#include <QToolButton>
#include <QTextEdit>
#include <QVBoxLayout>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QFile>
#include <QProcess>
#include <QLabel>
#include <QVector>
#include <QDialog>
#include <QSpinBox>
#include <QFileDialog>

/****************************************************************
 * @struct InputDef
 * @brief Defines a single input argument for a command.
 ***************************************************************/
struct InputDef
{
    QString label;
    QString switchName;
};

/****************************************************************
 * @struct ProjectDef
 * @brief Defines a project with script, inputs, and extra args.
 ***************************************************************/
struct ProjectDef
{
    QString name;
    QString scriptPath;
    QVector<InputDef> inputs;
    QString extraArgs;
};

/****************************************************************
 * @class CommandsTab
 * @brief Implements the dynamic command management tab.
 ***************************************************************/
class CommandsTab : public QWidget
{
    Q_OBJECT

public:
    explicit CommandsTab(QWidget *parent = nullptr);
    bool loadProjects(const QString &jsonPath);
    bool saveProjects(const QString &jsonPath);

private slots:
    void onProjectChanged(int index);
    void onRunCommand();
    void onRunBatch();
    void onClearCommand();
    void onAddProject();
    void onEditProject();
    void onDeleteProject();
    void updatePreview();
    void onBrowseBatchFile();

private:
    QVector<ProjectDef> projects;

    QComboBox *projectDropdown;
    QVBoxLayout *inputsLayout;
    QVector<QLineEdit *> inputEdits;
    QLineEdit *extraArgsEdit;
    QLineEdit *commandPreview;
    QTextEdit *outputConsole;
    QLineEdit *batchFileEdit;
    QPushButton *runButton;
    QPushButton *runBatchButton;
    QPushButton *addProjectButton;
    QPushButton *editProjectButton;
    QPushButton *deleteProjectButton;
    QToolButton *clearButton;

    void buildUI();
    void rebuildInputs(const ProjectDef &proj);
    QString buildCommand() const;
    bool validateFiles(QString &errorMsg) const;
    void executeCommand(const QString &cmd);

    // Project editor dialog helpers
    bool showProjectDialog(ProjectDef &proj, bool isEdit = false);
    void refreshProjectDropdown();
};

#endif // COMMANDSTAB_H
/************** End of CommandsTab.h ***************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.cpp
 * @brief Implements the main application window.
 *
 * @author Jeffrey Scott Flesher with Copilot
 * @version 0.7
 * @date    2025-11-03
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Implements the main window logic: settings, history, menus,
 * file and URL loaders, logging, and UI dialog wiring.
 * Now with dynamic UI setup instead of .ui file.
 ***************************************************************/

#include "MainWindow.h"
#include <QApplication>
#include <QFileDialog>
#include <QHeaderView>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QEventLoop>
#include <QUrl>
#include <utility>
#include <QSysInfo>
#include <QProcess>
#include <QLabel>

/****************************************************************
 * @brief Globals for MainWindow.
 ***************************************************************/
QString MainWindow::appVersion = "1.0"; // Change in main
const QString DEFAULT_PYTHON_VERSION = "3.11";
const QString DEFAULT_PIP_VERSION = "23.2";
const QString DEFAULT_PIPTOOLS_VERSION = "6.13";
const int DEFAULT_MAX_ITEMS = 10;
const QString DEFAULT_APP_VERSION = "1.0";
const QString MainWindow::kOrganizationName = "AM-Tower";
const QString MainWindow::kApplicationName = "PipMatrixResolver";

/****************************************************************
 * @brief Constructor for MainWindow.
 ***************************************************************/
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent),
    requirementsModel(new QStandardItemModel(this)),
    localHistoryModel(new QStandardItemModel(this)),
    webHistoryModel(new QStandardItemModel(this)),
    maxHistoryItems(10)
{
    setupUi();

    loadAppSettings();
    loadHistory();

    // Connect actions
    connect(actionOpenRequirements, &QAction::triggered, this, &MainWindow::openLocalRequirements);
    connect(actionFetchRequirements, &QAction::triggered, this, &MainWindow::fetchRequirementsFromUrl);
    connect(actionExit, &QAction::triggered, this, &MainWindow::exitApp);
    connect(actionAbout, &QAction::triggered, this, &MainWindow::showAboutBox);
    connect(actionViewReadme, &QAction::triggered, this, &MainWindow::showReadmeDialog);
    connect(actionCreateVenv, &QAction::triggered, this, &MainWindow::onCreateVenv);
    connect(actionResolveMatrix, &QAction::triggered, this, &MainWindow::startResolve);
    connect(actionPause, &QAction::triggered, this, &MainWindow::pauseResolve);
    connect(actionResume, &QAction::triggered, this, &MainWindow::resumeResolve);
    connect(actionStop, &QAction::triggered, this, &MainWindow::stopResolve);

    // Connect settings buttons
    if (buttonBoxPreferences)
    {
        connect(buttonBoxPreferences, &QDialogButtonBox::accepted, this, &MainWindow::saveAppSettings);
        QPushButton *applyBtn = buttonBoxPreferences->button(QDialogButtonBox::Apply);
        if (applyBtn)
        {
            connect(applyBtn, &QPushButton::clicked, this, &MainWindow::saveAppSettings);
        }
    }

    // Connect history table selection changes
    connect(localHistoryTable->selectionModel(), &QItemSelectionModel::selectionChanged,
            this, &MainWindow::updateLocalHistoryButtons);
    connect(webHistoryTable->selectionModel(), &QItemSelectionModel::selectionChanged,
            this, &MainWindow::updateWebHistoryButtons);

    // Connect Terminal tab
    connect(runCommandBtn, &QPushButton::clicked, this, &MainWindow::onRunCommand);
    connect(clearTerminalBtn, &QPushButton::clicked, this, &MainWindow::onClearTerminal);

    // Connect Package Manager tab
    connect(searchPackageBtn, &QPushButton::clicked, this, &MainWindow::onSearchPackage);
    connect(installPackageBtn, &QPushButton::clicked, this, &MainWindow::onInstallPackage);
    connect(uninstallPackageBtn, &QPushButton::clicked, this, &MainWindow::onUninstallPackage);

    connect(mainTabs, &QTabWidget::currentChanged, this, [this](int index)
            {
                if (mainTabs->widget(index)->objectName() == "tabPackageManager")
                {
                    refreshInstalledPackages();
                }
            });
    connect(installedPackagesList, &QListWidget::doubleClicked, this, &MainWindow::onInstalledPackagesListDoubleClicked);

    // Refresh tables on startup
    refreshRecentMenus();
    refreshHistoryTables();
    checkAndRestoreSettings();

    detectSystem();
    restoreCpuCudaSettings();
    setupVenvPaths();
}

/****************************************************************
 * @brief Destructor for MainWindow.
 ***************************************************************/
MainWindow::~MainWindow()
{
}

/****************************************************************
 * @brief Sets up the entire UI dynamically.
 ***************************************************************/
void MainWindow::setupUi()
{
    // Main window setup
    resize(900, 600);
    setWindowTitle(tr("Pip Matrix Resolver"));

    // Central widget
    centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);

    // Main layout
    QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);

    // Tab widget
    mainTabs = new QTabWidget(centralWidget);
    mainTabs->setCurrentIndex(3);
    mainLayout->addWidget(mainTabs);

    // === TAB: MAIN ===
    tabMain = new QWidget();
    tabMain->setObjectName("tabMain");
    QVBoxLayout *mainTabLayout = new QVBoxLayout(tabMain);

    splitter = new QSplitter(Qt::Horizontal, tabMain);
    requirementsView = new QTableView(splitter);
    matrixView = new QTableView(splitter);
    splitter->addWidget(requirementsView);
    splitter->addWidget(matrixView);
    mainTabLayout->addWidget(splitter);

    bottomSplitter = new QSplitter(Qt::Horizontal, tabMain);
    logView = new QPlainTextEdit(bottomSplitter);
    logView->setReadOnly(true);
    progress = new QProgressBar(bottomSplitter);
    bottomSplitter->addWidget(logView);
    bottomSplitter->addWidget(progress);
    mainTabLayout->addWidget(bottomSplitter);

    requirementsView->setModel(requirementsModel);
    requirementsView->setAlternatingRowColors(true);
    requirementsView->setSelectionBehavior(QAbstractItemView::SelectRows);
    requirementsView->setSelectionMode(QAbstractItemView::ExtendedSelection);

    mainTabs->addTab(tabMain, tr("Main"));

    // === TAB: HISTORY ===
    tabHistory = new QWidget();
    tabHistory->setObjectName("tabHistory");
    QVBoxLayout *historyLayout = new QVBoxLayout(tabHistory);

    localHistoryTable = new QTableView(tabHistory);
    localHistoryTable->setModel(localHistoryModel);
    historyLayout->addWidget(localHistoryTable);

    QHBoxLayout *localHistoryButtonBar = new QHBoxLayout();
    localAddButton = new QPushButton(tr("Add"), tabHistory);
    localEditButton = new QPushButton(tr("Edit"), tabHistory);
    localDeleteButton = new QPushButton(tr("Delete"), tabHistory);
    localUpButton = new QPushButton(tr("Up"), tabHistory);
    localDownButton = new QPushButton(tr("Down"), tabHistory);
    localHistoryButtonBar->addWidget(localAddButton);
    localHistoryButtonBar->addWidget(localEditButton);
    localHistoryButtonBar->addWidget(localDeleteButton);
    localHistoryButtonBar->addWidget(localUpButton);
    localHistoryButtonBar->addWidget(localDownButton);
    historyLayout->addLayout(localHistoryButtonBar);

    connect(localAddButton, &QPushButton::clicked, this, &MainWindow::on_localAddButton_clicked);
    connect(localEditButton, &QPushButton::clicked, this, &MainWindow::on_localEditButton_clicked);
    connect(localDeleteButton, &QPushButton::clicked, this, &MainWindow::on_localDeleteButton_clicked);
    connect(localUpButton, &QPushButton::clicked, this, &MainWindow::on_localUpButton_clicked);
    connect(localDownButton, &QPushButton::clicked, this, &MainWindow::on_localDownButton_clicked);

    webHistoryTable = new QTableView(tabHistory);
    webHistoryTable->setModel(webHistoryModel);
    historyLayout->addWidget(webHistoryTable);

    QHBoxLayout *webHistoryButtonBar = new QHBoxLayout();
    webAddButton = new QPushButton(tr("Add"), tabHistory);
    webEditButton = new QPushButton(tr("Edit"), tabHistory);
    webDeleteButton = new QPushButton(tr("Delete"), tabHistory);
    webUpButton = new QPushButton(tr("Up"), tabHistory);
    webDownButton = new QPushButton(tr("Down"), tabHistory);
    webHistoryButtonBar->addWidget(webAddButton);
    webHistoryButtonBar->addWidget(webEditButton);
    webHistoryButtonBar->addWidget(webDeleteButton);
    webHistoryButtonBar->addWidget(webUpButton);
    webHistoryButtonBar->addWidget(webDownButton);
    historyLayout->addLayout(webHistoryButtonBar);

    connect(webAddButton, &QPushButton::clicked, this, &MainWindow::on_webAddButton_clicked);
    connect(webEditButton, &QPushButton::clicked, this, &MainWindow::on_webEditButton_clicked);
    connect(webDeleteButton, &QPushButton::clicked, this, &MainWindow::on_webDeleteButton_clicked);
    connect(webUpButton, &QPushButton::clicked, this, &MainWindow::on_webUpButton_clicked);
    connect(webDownButton, &QPushButton::clicked, this, &MainWindow::on_webDownButton_clicked);

    mainTabs->addTab(tabHistory, tr("History"));

    // === TAB: TERMINAL ===
    tabTerminal = new QWidget();
    tabTerminal->setObjectName("tabTerminal");
    QVBoxLayout *terminalLayout = new QVBoxLayout(tabTerminal);

    terminalOutput = new QPlainTextEdit(tabTerminal);
    terminalLayout->addWidget(terminalOutput);

    QHBoxLayout *terminalCommandLayout = new QHBoxLayout();
    commandInput = new QLineEdit(tabTerminal);
    runCommandBtn = new QPushButton(tr("Run Command"), tabTerminal);
    clearTerminalBtn = new QPushButton(tr("Clear"), tabTerminal);
    terminalCommandLayout->addWidget(commandInput);
    terminalCommandLayout->addWidget(runCommandBtn);
    terminalCommandLayout->addWidget(clearTerminalBtn);
    terminalLayout->addLayout(terminalCommandLayout);

    mainTabs->addTab(tabTerminal, tr("Terminal"));

    // === TAB: PACKAGE MANAGER ===
    tabPackageManager = new QWidget();
    tabPackageManager->setObjectName("tabPackageManager");
    QVBoxLayout *packageManagerLayout = new QVBoxLayout(tabPackageManager);

    QHBoxLayout *packageManagerCommandLayout = new QHBoxLayout();
    packageNameInput = new QLineEdit(tabPackageManager);
    searchPackageBtn = new QPushButton(tr("Search"), tabPackageManager);
    installPackageBtn = new QPushButton(tr("Install"), tabPackageManager);
    uninstallPackageBtn = new QPushButton(tr("Uninstall"), tabPackageManager);
    packageManagerCommandLayout->addWidget(packageNameInput);
    packageManagerCommandLayout->addWidget(searchPackageBtn);
    packageManagerCommandLayout->addWidget(installPackageBtn);
    packageManagerCommandLayout->addWidget(uninstallPackageBtn);
    packageManagerLayout->addLayout(packageManagerCommandLayout);

    installedPackagesList = new QListWidget(tabPackageManager);
    packageManagerLayout->addWidget(installedPackagesList);

    packageOutput = new QPlainTextEdit(tabPackageManager);
    packageManagerLayout->addWidget(packageOutput);

    mainTabs->addTab(tabPackageManager, tr("Package Manager"));

    // === TAB: COMMANDS ===
    tabCommands = new QWidget();
    tabCommands->setObjectName("tabCommands");
    QVBoxLayout *commandsLayout = new QVBoxLayout(tabCommands);

    commandsTab = new CommandsTab(tabCommands);
    commandsLayout->addWidget(commandsTab);

    mainTabs->addTab(tabCommands, tr("Commands"));

    // === TAB: SETTINGS ===
    tabSettings = new QWidget();
    tabSettings->setObjectName("tabSettings");
    QVBoxLayout *settingsLayout = new QVBoxLayout(tabSettings);

    QFormLayout *formLayout = new QFormLayout();

    pythonVersionEdit = new QLineEdit(tabSettings);
    formLayout->addRow(tr("Python version:"), pythonVersionEdit);

    pipVersionEdit = new QLineEdit(tabSettings);
    formLayout->addRow(tr("pip version:"), pipVersionEdit);

    pipToolsVersionEdit = new QLineEdit(tabSettings);
    formLayout->addRow(tr("pip-tools version:"), pipToolsVersionEdit);

    spinMaxItems = new QSpinBox(tabSettings);
    spinMaxItems->setMinimum(-1);
    spinMaxItems->setMaximum(std::numeric_limits<int>::max());
    spinMaxItems->setValue(10);
    spinMaxItems->setToolTip(tr("-1 = unlimited, 0 not allowed, â‰¥1 valid"));
    formLayout->addRow(tr("Maximum number of items:"), spinMaxItems);

    gpuDetectedCheckBox = new QCheckBox(tabSettings);
    gpuDetectedCheckBox->setEnabled(false);
    formLayout->addRow(tr("GPU Detected:"), gpuDetectedCheckBox);

    useCpuCheckBox = new QCheckBox(tabSettings);
    formLayout->addRow(tr("Use CPU:"), useCpuCheckBox);

    cudaCheckBox = new QCheckBox(tabSettings);
    formLayout->addRow(tr("Cuda:"), cudaCheckBox);

    osEdit = new QLineEdit(tabSettings);
    osEdit->setReadOnly(true);
    formLayout->addRow(tr("OS:"), osEdit);

    osReleaseEdit = new QLineEdit(tabSettings);
    osReleaseEdit->setReadOnly(true);
    formLayout->addRow(tr("Release:"), osReleaseEdit);

    osVersionEdit = new QLineEdit(tabSettings);
    osVersionEdit->setReadOnly(true);
    formLayout->addRow(tr("Version:"), osVersionEdit);

    settingsLayout->addLayout(formLayout);

    saveSettingsButton = new QPushButton(tr("Save Settings"), tabSettings);
    settingsLayout->addWidget(saveSettingsButton);

    restoreDefaultsButton = new QPushButton(tr("Restore Defaults"), tabSettings);
    settingsLayout->addWidget(restoreDefaultsButton);

    buttonBoxPreferences = new QDialogButtonBox(
        QDialogButtonBox::Ok | QDialogButtonBox::Apply | QDialogButtonBox::Cancel,
        tabSettings
        );
    settingsLayout->addWidget(buttonBoxPreferences);

    mainTabs->addTab(tabSettings, tr("Settings"));

    // === MENU BAR ===
    menuBar = new QMenuBar(this);
    setMenuBar(menuBar);

    // File menu
    menuFile = new QMenu(tr("&File"), this);
    menuBar->addMenu(menuFile);

    actionOpenRequirements = new QAction(QIcon(":/icons/icons/open.svg"), tr("Open requirements file..."), this);
    menuFile->addAction(actionOpenRequirements);

    actionFetchRequirements = new QAction(QIcon(":/icons/icons/url.svg"), tr("Fetch requirements from URL..."), this);
    menuFile->addAction(actionFetchRequirements);

    menuFile->addSeparator();

    // Recent Local and Recent Web submenus
    recentLocalMenu = new QMenu(tr("Recent Local"), this);
    menuFile->addMenu(recentLocalMenu);

    recentWebMenu = new QMenu(tr("Recent Web"), this);
    menuFile->addMenu(recentWebMenu);

    menuFile->addSeparator();

    actionExit = new QAction(tr("Exit"), this);
    menuFile->addAction(actionExit);

    // Tools menu
    menuTools = new QMenu(tr("&Tools"), this);
    menuBar->addMenu(menuTools);

    actionCreateVenv = new QAction(QIcon(":/icons/icons/venv.svg"), tr("Create/Update venv"), this);
    menuTools->addAction(actionCreateVenv);

    actionResolveMatrix = new QAction(QIcon(":/icons/icons/resolve.svg"), tr("Resolve matrix"), this);
    menuTools->addAction(actionResolveMatrix);

    actionPause = new QAction(QIcon(":/icons/icons/pause.svg"), tr("Pause"), this);
    menuTools->addAction(actionPause);

    actionResume = new QAction(QIcon(":/icons/icons/resume.svg"), tr("Resume"), this);
    menuTools->addAction(actionResume);

    actionStop = new QAction(QIcon(":/icons/icons/stop.svg"), tr("Stop"), this);
    menuTools->addAction(actionStop);

    // Batch menu
    menuBatch = new QMenu(tr("&Batch"), this);
    menuBar->addMenu(menuBatch);

    actionRunBatch = new QAction(QIcon(":/icons/icons/batch.svg"), tr("Run batch"), this);
    menuBatch->addAction(actionRunBatch);

    // Help menu
    menuHelp = new QMenu(tr("&Help"), this);
    menuBar->addMenu(menuHelp);

    actionAbout = new QAction(QIcon(":/icons/icons/info.svg"), tr("About"), this);
    menuHelp->addAction(actionAbout);

    actionViewReadme = new QAction(QIcon(":/icons/icons/readme.svg"), tr("View README"), this);
    menuHelp->addAction(actionViewReadme);

    // === TOOLBAR ===
    mainToolBar = new QToolBar(tr("Main Toolbar"), this);
    addToolBar(Qt::TopToolBarArea, mainToolBar);

    mainToolBar->addAction(actionOpenRequirements);
    mainToolBar->addAction(actionFetchRequirements);
    mainToolBar->addAction(actionCreateVenv);
    mainToolBar->addAction(actionResolveMatrix);
    mainToolBar->addAction(actionPause);
    mainToolBar->addAction(actionResume);
    mainToolBar->addAction(actionStop);
    mainToolBar->addAction(actionRunBatch);
    mainToolBar->addAction(actionAbout);
    mainToolBar->addAction(actionViewReadme);

    // === STATUS BAR ===
    statusBar = new QStatusBar(this);
    setStatusBar(statusBar);
}

/****************************************************************
 * @brief Exits the application.
 ***************************************************************/
void MainWindow::exitApp()
{
    QApplication::quit();
}

/****************************************************************
 * @brief Opens requirements from a local file via dialog.
 ***************************************************************/
void MainWindow::openLocalRequirements()
{
    QString path = QFileDialog::getOpenFileName(this, tr("Open requirements.txt"), QString(), tr("Text Files (*.txt)"));
    if (path.isEmpty())
    {
        return;
    }
    loadRequirementsFromFile(path);
}

/****************************************************************
 * @brief Fetches requirements from a URL via dialog.
 ***************************************************************/
void MainWindow::fetchRequirementsFromUrl()
{
    bool ok = false;
    QString inputUrl = QInputDialog::getText(
        this,
        tr("Fetch requirements"),
        tr("Enter URL:"),
        QLineEdit::Normal,
        "",
        &ok
        );
    if (!ok || inputUrl.isEmpty())
    {
        return;
    }
    const QString rawUrl = normalizeRawUrl(inputUrl);
    loadRequirementsFromUrl(rawUrl);
}

/****************************************************************
 * @brief Loads requirements from a local file.
 ***************************************************************/
void MainWindow::loadRequirementsFromFile(const QString &path)
{
    if (path.isEmpty())
    {
        return;
    }
    if (!QFile::exists(path))
    {
        QMessageBox::warning(this, tr("File missing"), tr("File no longer exists:\n%1").arg(path));
        historyRecentLocal.removeAll(path);
        refreshRecentMenus();
        saveHistory();
        return;
    }
    const QStringList lines = readTextFileLines(path);
    QStringList errors;
    if (!validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(
            this,
            tr("Invalid requirements.txt"),
            tr("Validation failed:\n%1").arg(errors.join("\n"))
            );
        return;
    }
    if (requirementsModel)
    {
        requirementsModel->clear();
        writeTableToModel(lines);
    }
    applySettingsFromUi();
    historyRecentLocal.removeAll(path);
    historyRecentLocal.prepend(path);
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Loaded %1 requirements from %2").arg(requirementsModel->rowCount()).arg(path));
}

/****************************************************************
 * @brief Loads requirements from a URL.
 ***************************************************************/
void MainWindow::loadRequirementsFromUrl(const QString &url)
{
    if (url.isEmpty())
    {
        return;
    }
    QByteArray content;
    if (!downloadText(url, content))
    {
        QMessageBox::warning(this, tr("Download failed"), tr("Failed to fetch requirements from URL:\n%1").arg(url));
        historyRecentWeb.removeAll(url);
        refreshRecentMenus();
        saveHistory();
        return;
    }
    const QStringList lines = QString::fromUtf8(content).split('\n', Qt::KeepEmptyParts);
    QStringList errors;
    if (!validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(this, tr("Invalid requirements.txt"), tr("Fetched content failed validation:\n%1").arg(errors.join("\n")));
        return;
    }
    if (requirementsModel)
    {
        requirementsModel->clear();
        writeTableToModel(lines);
    }
    applySettingsFromUi();
    historyRecentWeb.removeAll(url);
    historyRecentWeb.prepend(url);
    if (maxHistoryItems != -1)
    {
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Fetched %1 requirements from URL: %2")
                  .arg(requirementsModel->rowCount())
                  .arg(url));
}

/****************************************************************
 * @brief Populates the local and web history tables in the
 *        History tab with the current history data from QSettings.
 ***************************************************************/
void MainWindow::refreshHistoryTables()
{
    QSettings s(kOrganizationName, kApplicationName);
    QStringList localList = s.value("history/recentLocal").toStringList();
    QStringList webList = s.value("history/recentWeb").toStringList();

    localHistoryModel->clear();
    localHistoryModel->setHorizontalHeaderLabels({tr("Recent Local Files")});
    for (const QString &path : std::as_const(localList))
    {
        QList<QStandardItem*> row;
        row << new QStandardItem(path);
        localHistoryModel->appendRow(row);
    }
    localHistoryTable->resizeColumnsToContents();

    webHistoryModel->clear();
    webHistoryModel->setHorizontalHeaderLabels({tr("Recent Web URLs")});
    for (const QString &url : std::as_const(webList))
    {
        QList<QStandardItem*> row;
        row << new QStandardItem(url);
        webHistoryModel->appendRow(row);
    }
    webHistoryTable->resizeColumnsToContents();
    updateLocalHistoryButtons();
    updateWebHistoryButtons();
}

/****************************************************************
 * @brief Refreshes recent file and URL menus safely.
 ***************************************************************/
void MainWindow::refreshRecentMenus()
{
    if (!recentLocalMenu || !recentWebMenu)
    {
        qWarning() << "refreshRecentMenus: menus not available, skipping";
        return;
    }
    recentLocalMenu->clear();
    recentWebMenu->clear();

    // Populate Recent Local
    for (int i = 0; i < historyRecentLocal.size(); ++i)
    {
        const QString &path = historyRecentLocal.at(i);
        QAction *act = recentLocalMenu->addAction(path);
        connect(act, &QAction::triggered, this, [this, path]()
                {
                    loadRequirementsFromFile(path);
                });
    }
    if (!historyRecentLocal.isEmpty())
    {
        recentLocalMenu->addSeparator();
        QAction *clearLocal = recentLocalMenu->addAction(tr("Clear Local History"));
        connect(clearLocal, &QAction::triggered, this, [this]()
                {
                    historyRecentLocal.clear();
                    refreshRecentMenus();
                    saveHistory();
                });
    }

    // Populate Recent Web
    for (int i = 0; i < historyRecentWeb.size(); ++i)
    {
        const QString &url = historyRecentWeb.at(i);
        QAction *act = recentWebMenu->addAction(url);
        connect(act, &QAction::triggered, this, [this, url]()
                {
                    loadRequirementsFromUrl(url);
                });
    }
    if (!historyRecentWeb.isEmpty())
    {
        recentWebMenu->addSeparator();
        QAction *clearWeb = recentWebMenu->addAction(tr("Clear Web History"));
        connect(clearWeb, &QAction::triggered, this, [this]()
                {
                    historyRecentWeb.clear();
                    refreshRecentMenus();
                    saveHistory();
                });
    }
}

/****************************************************************
 * @brief Clears both local and web recent history lists.
 ***************************************************************/
void MainWindow::clearAllHistory()
{
    historyRecentLocal.clear();
    historyRecentWeb.clear();
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Cleared all history"));
}

/****************************************************************
 * @brief Loads application settings from QSettings to UI.
 ***************************************************************/
void MainWindow::loadAppSettings()
{
    QSettings settings;
    maxHistoryItems = settings.value("app/maxItems", 10).toInt();
    validateAppSettings();
    updateUiFromSettings();
}

/****************************************************************
 * @brief Saves application settings from UI to QSettings.
 ***************************************************************/
void MainWindow::saveAppSettings()
{
    applySettingsFromUi();
    validateAppSettings();
    QSettings settings;
    settings.setValue("app/maxItems", maxHistoryItems);
    statusBar->showMessage(tr("Settings saved"), 2000);
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
}

/****************************************************************
 * @brief Validates and clamps settings to safe ranges.
 ***************************************************************/
void MainWindow::validateAppSettings()
{
    if (maxHistoryItems == 0)
    {
        maxHistoryItems = 10;
    }
    else if (maxHistoryItems < -1)
    {
        maxHistoryItems = 1;
    }
}

/****************************************************************
 * @brief Applies settings from UI widgets to member state.
 ***************************************************************/
void MainWindow::applySettingsFromUi()
{
    maxHistoryItems = spinMaxItems->value();
}

/****************************************************************
 * @brief Updates UI widgets to reflect current settings.
 ***************************************************************/
void MainWindow::updateUiFromSettings()
{
    spinMaxItems->setValue(maxHistoryItems);
}

/****************************************************************
 * @brief Writes requirements into a one-column model.
 ***************************************************************/
void MainWindow::writeTableToModel(const QStringList &lines)
{
    if (!requirementsModel || !requirementsView) { return; }
    requirementsModel->clear();
    requirementsModel->setColumnCount(1);
    requirementsModel->setHorizontalHeaderLabels({tr("requirements.txt")});
    requirementsView->resizeRowsToContents();

    for (const QString &line : lines)
    {
        const QString trimmed = line.trimmed();
        if (trimmed.isEmpty())
        {
            continue;
        }
        auto *item = new QStandardItem(trimmed);
        item->setEditable(false);
        requirementsModel->appendRow(item);
    }
    requirementsView->resizeColumnsToContents();
    requirementsView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
    requirementsView->horizontalHeader()->setSectionResizeMode(QHeaderView::Interactive);
    requirementsView->resizeColumnsToContents();
    requirementsView->resizeRowsToContents();

    // Get the actual width of requirementsView and add 66px
    int reqWidth = requirementsView->verticalHeader()->width();
    for (int col = 0; col < requirementsModel->columnCount(); ++col)
    {
        reqWidth += requirementsView->columnWidth(col);
    }
    reqWidth += 66;

    // Set the splitter sizes
    if (splitter)
    {
        QList<int> sizes;
        sizes << reqWidth << qMax(100, splitter->width() - reqWidth);
        splitter->setSizes(sizes);
    }
    refreshHistoryTables();
}

/****************************************************************
 * @brief Appends a line to the log view with timestamp.
 * @param line The message line to append.
 ***************************************************************/
void MainWindow::appendLog(const QString &line)
{
    QString time = QDateTime::currentDateTime().toString("HH:mm:ss");
    logView->appendPlainText(QString("[%1] %2").arg(time, line));
}

/****************************************************************
 * @brief Updates progress bar percent.
 * @param percent The progress value (0-100).
 ***************************************************************/
void MainWindow::updateProgress(int percent)
{
    progress->setValue(percent);
}

/****************************************************************
 * @brief Shows compiled result message path.
 * @param path The compiled output path.
 ***************************************************************/
void MainWindow::showCompiledResult(const QString &path)
{
    appendLog(tr("Successfully compiled: %1").arg(path));
    statusBar->showMessage(tr("Compiled successfully"));
}

/****************************************************************
 * @brief Shows About dialog using current appVersion.
 ***************************************************************/
void MainWindow::showAboutBox()
{
    QMessageBox::about(this,
                       tr("About Pip Matrix Resolver"),
                       tr("<b>Pip Matrix Resolver</b><br>"
                          "Cross-platform Qt tool to resolve "
                          "Python dependency matrices.<br>"
                          "Version %1").arg(appVersion)
                       );
}

/****************************************************************
 * @brief Shows README dialog from resources.
 ***************************************************************/
void MainWindow::showReadmeDialog()
{
    QFile file(":/docs/README.md");
    QString markdown;
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        markdown = QString::fromUtf8(file.readAll());
    }
    else
    {
        markdown = tr("README.md not found in resources.");
    }

    QDialog dialog(this);
    dialog.setWindowTitle(tr("README"));
    dialog.resize(700, 500);

    QVBoxLayout layout(&dialog);
    QTextBrowser viewer(&dialog);
    viewer.setMarkdown(markdown);
    viewer.setOpenExternalLinks(true);

    QPushButton closeButton(tr("Close"), &dialog);
    layout.addWidget(&viewer);
    layout.addWidget(&closeButton);

    connect(&closeButton, &QPushButton::clicked, &dialog, &QDialog::accept);

    dialog.exec();
}

/****************************************************************
 * @brief Loads persistent history from QSettings.
 ***************************************************************/
void MainWindow::loadHistory()
{
    QSettings s(kOrganizationName, kApplicationName);
    historyRecentLocal = s.value("history/recentLocal").toStringList();
    historyRecentWeb = s.value("history/recentWeb").toStringList();

    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
}

/****************************************************************
 * @brief Saves persistent history to QSettings.
 ***************************************************************/
void MainWindow::saveHistory()
{
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("history/recentLocal", historyRecentLocal);
    s.setValue("history/recentWeb", historyRecentWeb);
}

/****************************************************************
 * @brief Normalizes a raw URL string.
 ***************************************************************/
QString MainWindow::normalizeRawUrl(const QString &inputUrl)
{
    QString url = inputUrl.trimmed();
    if (!url.startsWith("http://") && !url.startsWith("https://"))
    {
        url.prepend("https://");
    }
    return url;
}

/****************************************************************
 * @brief Reads all lines from a text file.
 ***************************************************************/
QStringList MainWindow::readTextFileLines(const QString &path)
{
    QStringList lines;
    QFile file(path);
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        while (!file.atEnd())
        {
            lines << QString::fromUtf8(file.readLine()).trimmed();
        }
        file.close();
    }
    return lines;
}

/****************************************************************
 * @brief Validates requirements.txt lines.
 ***************************************************************/
bool MainWindow::validateRequirementsWithErrors(const QStringList &lines, QStringList &errors)
{
    errors.clear();
    bool valid = true;
    for (const QString &line : lines)
    {
        if (line.isEmpty())
        {
            continue;
        }
        // Example validation: must not start with a dash or space
        if (line.startsWith('-') || line.startsWith(' '))
        {
            errors << tr("Invalid line: %1").arg(line);
            valid = false;
        }
        // Add more validation rules as needed
    }
    return valid;
}

/****************************************************************
 * @brief Downloads text from a URL.
 ***************************************************************/
bool MainWindow::downloadText(const QString &url, QByteArray &out)
{
    QNetworkAccessManager manager;
    QNetworkRequest request{QUrl(url)};
    QNetworkReply *reply = manager.get(request);
    QEventLoop loop;
    connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
    loop.exec();
    if (reply->error() != QNetworkReply::NoError)
    {
        reply->deleteLater();
        return false;
    }
    out = reply->readAll();
    reply->deleteLater();
    return true;
}

/****************************************************************
 * @brief Returns the logs directory path.
 ***************************************************************/
QString MainWindow::logsDir()
{
    QString dir = QDir::homePath() + "/PipMatrixResolverLogs";
    QDir().mkpath(dir);
    return dir;
}

/****************************************************************
 * @brief Starts matrix resolution (stub).
 ***************************************************************/
void MainWindow::startResolve()
{
    appendLog(tr("Starting matrix resolution..."));
    // Add your matrix resolution logic here
}

/****************************************************************
 * @brief Pauses matrix resolution (stub).
 ***************************************************************/
void MainWindow::pauseResolve()
{
    appendLog(tr("Pausing..."));
    // Add your pause logic here
}

/****************************************************************
 * @brief Resumes matrix resolution (stub).
 ***************************************************************/
void MainWindow::resumeResolve()
{
    appendLog(tr("Resuming..."));
    // Add your resume logic here
}

/****************************************************************
 * @brief Stops matrix resolution (stub).
 ***************************************************************/
void MainWindow::stopResolve()
{
    appendLog(tr("Stopping..."));
    // Add your stop logic here
}

/****************************************************************
 * @brief Adds a new entry to the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localAddButton_clicked()
{
    bool ok;
    QString path = QInputDialog::getText(this, tr("Add Local File"), tr("File path:"), QLineEdit::Normal, "", &ok);
    if (ok && !path.isEmpty())
    {
        QSettings s(kOrganizationName, kApplicationName);
        QStringList list = s.value("history/recentLocal").toStringList();
        list.prepend(path);
        s.setValue("history/recentLocal", list);
        refreshHistoryTables();
    }
}

/****************************************************************
 * @brief Edits the selected entry in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localEditButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    QString oldValue = list.at(idx.row());
    bool ok;
    QString newValue = QInputDialog::getText(this, tr("Edit Local File"), tr("File path:"), QLineEdit::Normal, oldValue, &ok);
    if (!ok) return; // User cancelled, do nothing
    if (newValue.isEmpty()) return; // Optionally, do nothing if empty
    list[idx.row()] = newValue;
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Deletes the selected entry from the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localDeleteButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    list.removeAt(idx.row());
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Moves the selected entry up in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localUpButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid() || idx.row() == 0) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    list.swapItemsAt(idx.row(), idx.row() - 1);
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
    localHistoryTable->selectRow(idx.row() - 1);
}

/****************************************************************
 * @brief Moves the selected entry down in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localDownButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    if (!idx.isValid() || idx.row() >= list.size() - 1) return;
    list.swapItemsAt(idx.row(), idx.row() + 1);
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
    localHistoryTable->selectRow(idx.row() + 1);
}

/****************************************************************
 * @brief Adds a new entry to the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webAddButton_clicked()
{
    bool ok;
    QString url = QInputDialog::getText(this, tr("Add Web URL"), tr("URL:"), QLineEdit::Normal, "", &ok);
    if (ok && !url.isEmpty())
    {
        QSettings s(kOrganizationName, kApplicationName);
        QStringList list = s.value("history/recentWeb").toStringList();
        list.prepend(url);
        s.setValue("history/recentWeb", list);
        refreshHistoryTables();
    }
}

/****************************************************************
 * @brief Edits the selected entry in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webEditButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    QString oldValue = list.at(idx.row());
    bool ok;
    QString newValue = QInputDialog::getText(this, tr("Edit Web URL"), tr("URL:"), QLineEdit::Normal, oldValue, &ok);
    if (!ok) return; // User cancelled, do nothing
    if (newValue.isEmpty()) return; // Optionally, do nothing if empty
    list[idx.row()] = newValue;
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Deletes the selected entry from the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webDeleteButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    list.removeAt(idx.row());
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Moves the selected entry up in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webUpButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid() || idx.row() == 0) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    list.swapItemsAt(idx.row(), idx.row() - 1);
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
    webHistoryTable->selectRow(idx.row() - 1);
}

/****************************************************************
 * @brief Moves the selected entry down in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webDownButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    if (!idx.isValid() || idx.row() >= list.size() - 1) return;
    list.swapItemsAt(idx.row(), idx.row() + 1);
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
    webHistoryTable->selectRow(idx.row() + 1);
}

/****************************************************************
 * @brief Enables/disables local history buttons based on selection and table size.
 ***************************************************************/
void MainWindow::updateLocalHistoryButtons()
{
    QItemSelectionModel *sel = localHistoryTable->selectionModel();
    int rowCount = localHistoryModel->rowCount();
    bool hasSelection = sel->hasSelection();

    localEditButton->setEnabled(hasSelection);
    localDeleteButton->setEnabled(hasSelection);

    // Up: enabled if selected and not first row, and more than 1 item
    bool canUp = hasSelection && rowCount > 1;
    if (canUp)
    {
        QModelIndex idx = sel->currentIndex();
        canUp = idx.isValid() && idx.row() > 0;
    }
    localUpButton->setEnabled(canUp);

    // Down: enabled if selected and not last row, and more than 1 item
    bool canDown = hasSelection && rowCount > 1;
    if (canDown)
    {
        QModelIndex idx = sel->currentIndex();
        canDown = idx.isValid() && idx.row() < rowCount - 1;
    }
    localDownButton->setEnabled(canDown);
}

/****************************************************************
 * @brief Enables/disables web history buttons based on selection and table size.
 ***************************************************************/
void MainWindow::updateWebHistoryButtons()
{
    QItemSelectionModel *sel = webHistoryTable->selectionModel();
    int rowCount = webHistoryModel->rowCount();
    bool hasSelection = sel->hasSelection();

    webEditButton->setEnabled(hasSelection);
    webDeleteButton->setEnabled(hasSelection);

    // Up: enabled if selected and not first row, and more than 1 item
    bool canUp = hasSelection && rowCount > 1;
    if (canUp)
    {
        QModelIndex idx = sel->currentIndex();
        canUp = idx.isValid() && idx.row() > 0;
    }
    webUpButton->setEnabled(canUp);

    // Down: enabled if selected and not last row, and more than 1 item
    bool canDown = hasSelection && rowCount > 1;
    if (canDown)
    {
        QModelIndex idx = sel->currentIndex();
        canDown = idx.isValid() && idx.row() < rowCount - 1;
    }
    webDownButton->setEnabled(canDown);
}

/****************************************************************
 * @brief save Settings.
 ***************************************************************/
void MainWindow::saveSettings()
{
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("settings/pythonVersion", pythonVersionEdit->text());
    s.setValue("settings/pipVersion", pipVersionEdit->text());
    s.setValue("settings/pipToolsVersion", pipToolsVersionEdit->text());
    s.setValue("settings/maxItems", spinMaxItems->value());
    s.setValue("settings/useCpu", useCpuCheckBox->isChecked());
    s.setValue("settings/cuda", cudaCheckBox->isChecked());
}

/****************************************************************
 * @brief check And Restore Settings.
 ***************************************************************/
void MainWindow::checkAndRestoreSettings()
{
    QSettings s(kOrganizationName, kApplicationName);

    // Python version
    QString pythonVersion = s.value("settings/pythonVersion", DEFAULT_PYTHON_VERSION).toString();
    if (pythonVersion.isEmpty())
    {
        pythonVersion = DEFAULT_PYTHON_VERSION;
        s.setValue("settings/pythonVersion", pythonVersion);
    }
    pythonVersionEdit->setText(pythonVersion);

    // pip version
    QString pipVersion = s.value("settings/pipVersion", DEFAULT_PIP_VERSION).toString();
    if (pipVersion.isEmpty())
    {
        pipVersion = DEFAULT_PIP_VERSION;
        s.setValue("settings/pipVersion", pipVersion);
    }
    pipVersionEdit->setText(pipVersion);

    // pip-tools version
    QString pipToolsVersion = s.value("settings/pipToolsVersion", DEFAULT_PIPTOOLS_VERSION).toString();
    if (pipToolsVersion.isEmpty())
    {
        pipToolsVersion = DEFAULT_PIPTOOLS_VERSION;
        s.setValue("settings/pipToolsVersion", pipToolsVersion);
    }
    pipToolsVersionEdit->setText(pipToolsVersion);

    // Max items
    int maxItems = s.value("settings/maxItems", DEFAULT_MAX_ITEMS).toInt();
    if (maxItems == 0)
    {
        maxItems = DEFAULT_MAX_ITEMS;
        s.setValue("settings/maxItems", maxItems);
    }
    spinMaxItems->setValue(maxItems);
}

/****************************************************************
 * @brief Restores CPU and Cuda settings from QSettings to UI.
 ***************************************************************/
void MainWindow::restoreCpuCudaSettings()
{
    QSettings s(kOrganizationName, kApplicationName);
    useCpuCheckBox->setChecked(s.value("settings/useCpu", false).toBool());
    cudaCheckBox->setChecked(s.value("settings/cuda", true).toBool());
}

/****************************************************************
 * @brief Detect OS System.
 ***************************************************************/
void MainWindow::detectSystem()
{
    // GPU detection (simple: check for NVIDIA)
    bool gpuDetected = false;
    QString os, release, version;
#if defined(Q_OS_WIN)
    os = "Windows";
    release = QSysInfo::productType();
    version = QSysInfo::productVersion();
#elif defined(Q_OS_MAC)
    os = "Mac";
    release = QSysInfo::productType();
    version = QSysInfo::productVersion();
#elif defined(Q_OS_LINUX)
    os = "Linux";
    QFile f("/etc/os-release");
    if (f.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        while (!f.atEnd())
        {
            QString line = f.readLine();
            if (line.startsWith("ID=")) release = line.mid(3).trimmed().replace("\"", "");
            if (line.startsWith("VERSION_ID=")) version = line.mid(11).trimmed().replace("\"", "");
        }
    }
#endif
    osEdit->setText(os);
    osReleaseEdit->setText(release);
    osVersionEdit->setText(version);

#if defined(Q_OS_WIN)
    QProcess proc;
    proc.start("wmic path win32_VideoController get name");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive)) gpuDetected = true;
#elif defined(Q_OS_LINUX)
    QProcess proc;
    proc.start("lspci");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive)) gpuDetected = true;
#elif defined(Q_OS_MAC)
    QProcess proc;
    proc.start("system_profiler SPDisplaysDataType");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive)) gpuDetected = true;
#endif
    if (!gpuDetected)
    {
        gpuDetected = detectNvidiaGpu();
    }
    gpuDetectedCheckBox->setChecked(gpuDetected);

    // Save to QSettings
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("settings/os", os);
    s.setValue("settings/osRelease", release);
    s.setValue("settings/osVersion", version);
    s.setValue("settings/gpuDetected", gpuDetected);
    if (gpuDetected)
    {
        statusBar->showMessage(tr("GPU Detected"));
    }
    else
    {
        statusBar->showMessage(tr("GPU Not Detected"));
    }
}

/****************************************************************
 * @brief on Create Venv.
 ***************************************************************/
void MainWindow::onCreateVenv()
{
    // Check if python, pip, or pip-tools settings have changed
    // If so, rebuild venv_running
    // (You can compare current settings to those saved in QSettings)

    // Call your bash script using QProcess
    QProcess proc;
    QString script = "/path/to/pip-matrix-common.sh";
    QStringList args;
    args << "--create-venv-running"; // You can define this flag in your script
    proc.start(script, args);
    proc.waitForFinished(-1);
    QString output = proc.readAllStandardOutput();
    statusBar->showMessage(tr("Switching to Terminal tab. Created/Updated venv_running: %1").arg(output));
    mainTabs->setCurrentWidget(tabTerminal);
}

/****************************************************************
 * @brief Sets up venv_running and venv_testing paths and saves to QSettings.
 ***************************************************************/
void MainWindow::setupVenvPaths()
{
    QSettings s(kOrganizationName, kApplicationName);
    QString projectRoot = QDir::currentPath();
    QString venvRunning = projectRoot + "/.venvs/venv_running";
    QString venvTesting = projectRoot + "/.venvs/venv_testing";
    s.setValue("venv/venv_running", venvRunning);
    s.setValue("venv/venv_testing", venvTesting);
}

/****************************************************************
 * @brief detect Gpu Via PowerShell.
 ***************************************************************/
bool MainWindow::detectGpuViaPowerShell()
{
    QProcess proc;
    proc.start("powershell", QStringList() << "-Command" << "Get-WmiObject Win32_VideoController | Select-Object -ExpandProperty Name");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    return output.contains("NVIDIA", Qt::CaseInsensitive);
}

/****************************************************************
 * @brief detect Gpu Via DxDiag.
 ***************************************************************/
bool MainWindow::detectGpuViaDxDiag()
{
    QProcess proc;
    proc.start("cmd", QStringList() << "/c" << "dxdiag /t dxdiag.txt");
    proc.waitForFinished();
    QFile file("dxdiag.txt");
    bool found = false;
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        QString dxdiagOutput = file.readAll();
        found = dxdiagOutput.contains("NVIDIA", Qt::CaseInsensitive);
        file.remove(); // Clean up
    }
    return found;
}

/****************************************************************
 * @brief detect Gpu Via Nvidia Smi.
 ***************************************************************/
bool MainWindow::detectGpuViaNvidiaSmi()
{
    QProcess proc;
    proc.start("nvidia-smi");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    return output.contains("NVIDIA", Qt::CaseInsensitive);
}

/****************************************************************
 * @brief detect Nvidia Gpu.
 ***************************************************************/
bool MainWindow::detectNvidiaGpu()
{
    // Primary test: PowerShell WMI
    if (detectGpuViaPowerShell()) return true;
    // Fallback 1: dxdiag
    if (detectGpuViaDxDiag()) return true;
    // Fallback 2: nvidia-smi
    if (detectGpuViaNvidiaSmi()) return true;
    // Not detected
    return false;
}

/****************************************************************
 * @brief on Run Command.
 ***************************************************************/
void MainWindow::onRunCommand()
{
    QString command = commandInput->text().trimmed();
    if (command.isEmpty())
    {
        terminalOutput->appendPlainText("No command entered.");
        return;
    }

    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif

    QStringList args;
    bool usedVenv = false;

    if (command.startsWith("pip "))
    {
        args << "-m" << "pip";
        args << command.mid(4).split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    }
    else if (command.startsWith("pip-compile"))
    {
        args << "-m" << "piptools" << "compile";
        QString rest = command.mid(QString("pip-compile").length()).trimmed();
        if (!rest.isEmpty()) args << rest.split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    }
    else if (command.startsWith("pip-sync"))
    {
        args << "-m" << "piptools" << "sync";
        QString rest = command.mid(QString("pip-sync").length()).trimmed();
        if (!rest.isEmpty()) args << rest.split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    }
    else if (command.startsWith("python "))
    {
        args = command.mid(7).split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    }
    else
    {
#if defined(Q_OS_WIN)
        process.start("cmd.exe", QStringList() << "/C" << command);
#else
        process.start("bash", QStringList() << "-c" << command);
#endif
    }

    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();

    if (usedVenv)
        terminalOutput->appendPlainText("[venv] " + command);

    if (!output.isEmpty())
        terminalOutput->appendPlainText(output);
    if (!error.isEmpty())
        terminalOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief on Clear Terminal.
 ***************************************************************/
void MainWindow::onClearTerminal()
{
    terminalOutput->clear();
}

/****************************************************************
 * @brief on Search Package.
 ***************************************************************/
void MainWindow::onSearchPackage()
{
    QString pkg = packageNameInput->text().trimmed();
    if (pkg.isEmpty())
    {
        packageOutput->appendPlainText("Enter a package name to search.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "search", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief on Install Package.
 ***************************************************************/
void MainWindow::onInstallPackage()
{
    QString pkg = packageNameInput->text().trimmed();
    if (pkg.isEmpty())
    {
        packageOutput->appendPlainText("Enter a package name to install.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "install", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief on Uninstall Package.
 ***************************************************************/
void MainWindow::onUninstallPackage()
{
    QString pkg = packageNameInput->text().trimmed();
    if (pkg.isEmpty())
    {
        packageOutput->appendPlainText("Enter a package name to uninstall.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "uninstall", "-y", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief Refreshes the list of installed packages in venv.
 ***************************************************************/
void MainWindow::refreshInstalledPackages()
{
    installedPackagesList->clear();
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "list", "--format=freeze"};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QStringList lines = output.split('\n', Qt::SkipEmptyParts);
    for (int i = 0; i < lines.size(); ++i)
    {
        installedPackagesList->addItem(lines.at(i));
    }
}

/****************************************************************
 * @brief Handles double-click on installed package list item.
 * @param index The model index of the double-clicked item.
 ***************************************************************/
void MainWindow::onInstalledPackagesListDoubleClicked(const QModelIndex &index)
{
    QString pkg = installedPackagesList->item(index.row())->text().split('=')[0];
    packageNameInput->setText(pkg);
    onUninstallPackage();
}

/************** End of MainWindow.cpp ***************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.h
 * @brief Declares the main application window class.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.7
 * @date    2025-11-03
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Main window interface for PipMatrixResolver Qt application.
 * Includes settings API, history, menus, and shared loaders for
 * files and URLs. Uses C-style braces. Now with dynamic UI.
 ***************************************************************/

#pragma once
#include <QMainWindow>
#include <QStringList>
#include <QTimer>
#include <QStandardItemModel>
#include <QTableView>
#include <QPlainTextEdit>
#include <QProgressBar>
#include <QMenu>
#include <QMenuBar>
#include <QToolBar>
#include <QStatusBar>
#include <QAction>
#include <QDialogButtonBox>
#include <QPushButton>
#include <QFile>
#include <QDir>
#include <QFileInfo>
#include <QByteArray>
#include <QDialog>
#include <QTextBrowser>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QInputDialog>
#include <QMessageBox>
#include <QSettings>
#include <QDateTime>
#include <QDebug>
#include <QTabWidget>
#include <QSplitter>
#include <QCheckBox>
#include <QLineEdit>
#include <QSpinBox>
#include <QListWidget>
#include "CommandsTab.h"

/****************************************************************
 * @class MainWindow
 * @brief Implements the main application window.
 ***************************************************************/
class MainWindow : public QMainWindow
{
    Q_OBJECT
public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

    // QSettings
    static const QString kOrganizationName;
    static const QString kApplicationName;
    // Globals
    static QString appVersion;

private slots:
    void openLocalRequirements();
    void fetchRequirementsFromUrl();
    void refreshRecentMenus();
    void clearAllHistory();
    void loadAppSettings();
    void saveAppSettings();
    void validateAppSettings();
    void applySettingsFromUi();
    void updateUiFromSettings();
    void startResolve();
    void pauseResolve();
    void resumeResolve();
    void stopResolve();
    void appendLog(const QString &line);
    void updateProgress(int percent);
    void showCompiledResult(const QString &path);
    void showAboutBox();
    void showReadmeDialog();
    void exitApp();
    void writeTableToModel(const QStringList &lines);
    // Local history slots
    void on_localAddButton_clicked();
    void on_localEditButton_clicked();
    void on_localDeleteButton_clicked();
    void on_localUpButton_clicked();
    void on_localDownButton_clicked();

    // Web history slots
    void on_webAddButton_clicked();
    void on_webEditButton_clicked();
    void on_webDeleteButton_clicked();
    void on_webUpButton_clicked();
    void on_webDownButton_clicked();

    void updateLocalHistoryButtons();
    void updateWebHistoryButtons();
    // Slot for menu action
    void onCreateVenv();

    void onRunCommand();
    void onClearTerminal();

    // Package Manager tab
    void onSearchPackage();
    void onInstallPackage();
    void onUninstallPackage();

    void refreshInstalledPackages();
    void onInstalledPackagesListDoubleClicked(const QModelIndex &index);

private:
    void setupUi();
    void loadRequirementsFromFile(const QString &path);
    void loadRequirementsFromUrl(const QString &url);
    void saveHistory();
    void loadHistory();
    /****************************************************************
     * @brief Populates the local and web history tables in the
     *        History tab with the current history data.
     ***************************************************************/
    void refreshHistoryTables();
    /****************************************************************
    * @brief Checks all settings in the Settings tab at startup,
    *        restores defaults if missing, and updates the UI.
    ***************************************************************/
    void checkAndRestoreSettings();

    bool detectGpuViaPowerShell();
    bool detectNvidiaGpu();
    bool detectGpuViaNvidiaSmi();
    bool detectGpuViaDxDiag();
    /****************************************************************
    * @brief Saves all settings from the Settings tab to QSettings.
    ***************************************************************/
    void saveSettings();
    // Startup/system functions
    void detectSystem();
    void restoreCpuCudaSettings();
    void setupVenvPaths();

    // Utility functions moved from MatrixUtility
    QStringList readTextFileLines(const QString &path);
    bool validateRequirementsWithErrors(const QStringList &lines, QStringList &errors);
    QString normalizeRawUrl(const QString &inputUrl);
    bool downloadText(const QString &url, QByteArray &out);
    QString logsDir();

    // History data
    QStringList historyRecentLocal;
    QStringList historyRecentWeb;

    // UI widgets - Main Window
    QWidget *centralWidget;
    QTabWidget *mainTabs;
    QMenuBar *menuBar;
    QToolBar *mainToolBar;
    QStatusBar *statusBar;

    // Menus
    QMenu *menuFile;
    QMenu *menuTools;
    QMenu *menuBatch;
    QMenu *menuHelp;

    // Tab: Commands
    QWidget *tabCommands;
    CommandsTab *commandsTab;

    // Actions
    QAction *actionOpenRequirements;
    QAction *actionFetchRequirements;
    QAction *actionExit;
    QAction *actionCreateVenv;
    QAction *actionResolveMatrix;
    QAction *actionPause;
    QAction *actionResume;
    QAction *actionStop;
    QAction *actionRunBatch;
    QAction *actionAbout;
    QAction *actionViewReadme;

    // Tab: Main
    QWidget *tabMain;
    QSplitter *splitter;
    QSplitter *bottomSplitter;
    QStandardItemModel *requirementsModel;
    QTableView *requirementsView;
    QTableView *matrixView;
    QPlainTextEdit *logView;
    QProgressBar *progress;

    // Tab: History
    QWidget *tabHistory;
    QTableView *localHistoryTable;
    QTableView *webHistoryTable;
    QStandardItemModel *localHistoryModel;
    QStandardItemModel *webHistoryModel;
    QPushButton *localAddButton;
    QPushButton *localEditButton;
    QPushButton *localDeleteButton;
    QPushButton *localUpButton;
    QPushButton *localDownButton;
    QPushButton *webAddButton;
    QPushButton *webEditButton;
    QPushButton *webDeleteButton;
    QPushButton *webUpButton;
    QPushButton *webDownButton;

    // Tab: Terminal
    QWidget *tabTerminal;
    QPlainTextEdit *terminalOutput;
    QLineEdit *commandInput;
    QPushButton *runCommandBtn;
    QPushButton *clearTerminalBtn;

    // Tab: Package Manager
    QWidget *tabPackageManager;
    QLineEdit *packageNameInput;
    QPushButton *searchPackageBtn;
    QPushButton *installPackageBtn;
    QPushButton *uninstallPackageBtn;
    QListWidget *installedPackagesList;
    QPlainTextEdit *packageOutput;

    // Tab: Settings
    QWidget *tabSettings;
    QLineEdit *pythonVersionEdit;
    QLineEdit *pipVersionEdit;
    QLineEdit *pipToolsVersionEdit;
    QSpinBox *spinMaxItems;
    QCheckBox *gpuDetectedCheckBox;
    QCheckBox *useCpuCheckBox;
    QCheckBox *cudaCheckBox;
    QLineEdit *osEdit;
    QLineEdit *osReleaseEdit;
    QLineEdit *osVersionEdit;
    QPushButton *saveSettingsButton;
    QPushButton *restoreDefaultsButton;
    QDialogButtonBox *buttonBoxPreferences;

    QMenu *recentLocalMenu;
    QMenu *recentWebMenu;

    // Venv paths
    QString venvRunningPath;
    QString venvTestingPath;

    // Settings
    int maxHistoryItems; // -1=unlimited, 0 invalid, â‰¥1 valid
};

/************** End of MainWindow.h ****************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.ui
#-------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>900</width>
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Pip Matrix Resolver</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <widget class="QTabWidget" name="mainTabs">
      <property name="currentIndex">
       <number>3</number>
      </property>
      <widget class="QWidget" name="tabMain">
       <attribute name="title">
        <string>Main</string>
       </attribute>
       <layout class="QVBoxLayout" name="mainLayout">
        <item>
         <widget class="QSplitter" name="splitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QTableView" name="requirementsView"/>
          <widget class="QTableView" name="matrixView"/>
         </widget>
        </item>
        <item>
         <widget class="QSplitter" name="bottomSplitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QPlainTextEdit" name="logView">
           <property name="readOnly">
            <bool>true</bool>
           </property>
          </widget>
          <widget class="QProgressBar" name="progressBar"/>
         </widget>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabHistory">
       <attribute name="title">
        <string>History</string>
       </attribute>
       <layout class="QVBoxLayout" name="historyLayout">
        <item>
         <widget class="QTableView" name="localHistoryTable"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="localHistoryButtonBar">
          <item>
           <widget class="QPushButton" name="localAddButton">
            <property name="text">
             <string>Add</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localEditButton">
            <property name="text">
             <string>Edit</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localDeleteButton">
            <property name="text">
             <string>Delete</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localUpButton">
            <property name="text">
             <string>Up</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localDownButton">
            <property name="text">
             <string>Down</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QTableView" name="webHistoryTable"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="webHistoryButtonBar">
          <item>
           <widget class="QPushButton" name="webAddButton">
            <property name="text">
             <string>Add</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webEditButton">
            <property name="text">
             <string>Edit</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webDeleteButton">
            <property name="text">
             <string>Delete</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webUpButton">
            <property name="text">
             <string>Up</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webDownButton">
            <property name="text">
             <string>Down</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabTerminal">
       <attribute name="title">
        <string>Terminal</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_terminal">
        <item>
         <widget class="QPlainTextEdit" name="terminalOutput"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_terminal">
          <item>
           <widget class="QLineEdit" name="commandInput"/>
          </item>
          <item>
           <widget class="QPushButton" name="runCommandBtn">
            <property name="text">
             <string>Run Command</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="clearTerminalBtn">
            <property name="text">
             <string>Clear</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabPackageManager">
       <attribute name="title">
        <string>Package Manager</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_packageManager">
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_packageManager">
          <item>
           <widget class="QLineEdit" name="packageNameInput"/>
          </item>
          <item>
           <widget class="QPushButton" name="searchPackageBtn">
            <property name="text">
             <string>Search</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="installPackageBtn">
            <property name="text">
             <string>Install</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="uninstallPackageBtn">
            <property name="text">
             <string>Uninstall</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QListWidget" name="installedPackagesList"/>
        </item>
        <item>
         <widget class="QPlainTextEdit" name="packageOutput"/>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabSettings">
       <attribute name="title">
        <string>Settings</string>
       </attribute>
       <layout class="QVBoxLayout" name="settingsLayout">
        <item>
         <layout class="QFormLayout" name="formLayout">
          <item row="0" column="0">
           <widget class="QLabel" name="labelPythonVersion">
            <property name="text">
             <string>Python version:</string>
            </property>
           </widget>
          </item>
          <item row="0" column="1">
           <widget class="QLineEdit" name="pythonVersionEdit"/>
          </item>
          <item row="1" column="0">
           <widget class="QLabel" name="labelPipVersion">
            <property name="text">
             <string>pip version:</string>
            </property>
           </widget>
          </item>
          <item row="1" column="1">
           <widget class="QLineEdit" name="pipVersionEdit"/>
          </item>
          <item row="2" column="0">
           <widget class="QLabel" name="labelPipToolsVersion">
            <property name="text">
             <string>pip-tools version:</string>
            </property>
           </widget>
          </item>
          <item row="2" column="1">
           <widget class="QLineEdit" name="pipToolsVersionEdit"/>
          </item>
          <item row="3" column="0">
           <widget class="QLabel" name="labelMaxItems">
            <property name="text">
             <string>Maximum number of items:</string>
            </property>
           </widget>
          </item>
          <item row="3" column="1">
           <layout class="QHBoxLayout" name="spinMaxItemsLayout">
            <item>
             <widget class="QSpinBox" name="spinMaxItems">
              <property name="toolTip">
               <string>-1 = unlimited, 0 not allowed, â‰¥1 valid</string>
              </property>
              <property name="minimum">
               <number>-1</number>
              </property>
              <property name="maximum">
               <number>2147483647</number>
              </property>
              <property name="value">
               <number>10</number>
              </property>
             </widget>
            </item>
            <item>
             <spacer name="spinMaxItemsSpacer">
              <property name="orientation">
               <enum>Qt::Orientation::Horizontal</enum>
              </property>
              <property name="sizeType">
               <enum>QSizePolicy::Policy::Expanding</enum>
              </property>
              <property name="sizeHint" stdset="0">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
             </spacer>
            </item>
           </layout>
          </item>
          <item row="4" column="0">
           <widget class="QLabel" name="labelGpuDetected">
            <property name="text">
             <string>GPU Detected:</string>
            </property>
           </widget>
          </item>
          <item row="4" column="1">
           <widget class="QCheckBox" name="gpuDetectedCheckBox">
            <property name="enabled">
             <bool>false</bool>
            </property>
           </widget>
          </item>
          <item row="5" column="0">
           <widget class="QLabel" name="labelUseCpu">
            <property name="text">
             <string>Use CPU:</string>
            </property>
           </widget>
          </item>
          <item row="5" column="1">
           <widget class="QCheckBox" name="useCpuCheckBox"/>
          </item>
          <item row="6" column="0">
           <widget class="QLabel" name="labelCuda">
            <property name="text">
             <string>Cuda:</string>
            </property>
           </widget>
          </item>
          <item row="6" column="1">
           <widget class="QCheckBox" name="cudaCheckBox"/>
          </item>
          <item row="7" column="0">
           <widget class="QLabel" name="labelOs">
            <property name="text">
             <string>OS:</string>
            </property>
           </widget>
          </item>
          <item row="7" column="1">
           <widget class="QLineEdit" name="osEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="8" column="0">
           <widget class="QLabel" name="labelOsRelease">
            <property name="text">
             <string>Release:</string>
            </property>
           </widget>
          </item>
          <item row="8" column="1">
           <widget class="QLineEdit" name="osReleaseEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="9" column="0">
           <widget class="QLabel" name="labelOsVersion">
            <property name="text">
             <string>Version:</string>
            </property>
           </widget>
          </item>
          <item row="9" column="1">
           <widget class="QLineEdit" name="osVersionEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QPushButton" name="saveSettingsButton">
          <property name="text">
           <string>Save Settings</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="restoreDefaultsButton">
          <property name="text">
           <string>Restore Defaults</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QDialogButtonBox" name="buttonBoxPreferences">
          <property name="standardButtons">
           <set>QDialogButtonBox::StandardButton::Apply|QDialogButtonBox::StandardButton::Cancel|QDialogButtonBox::StandardButton::Ok</set>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>900</width>
     <height>20</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>&amp;File</string>
    </property>
    <addaction name="actionOpenRequirements"/>
    <addaction name="actionFetchRequirements"/>
    <addaction name="separator"/>
    <addaction name="actionExit"/>
   </widget>
   <widget class="QMenu" name="menuTools">
    <property name="title">
     <string>&amp;Tools</string>
    </property>
    <addaction name="actionCreateVenv"/>
    <addaction name="actionResolveMatrix"/>
    <addaction name="actionPause"/>
    <addaction name="actionResume"/>
    <addaction name="actionStop"/>
   </widget>
   <widget class="QMenu" name="menuBatch">
    <property name="title">
     <string>&amp;Batch</string>
    </property>
    <addaction name="actionRunBatch"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>&amp;Help</string>
    </property>
    <addaction name="actionAbout"/>
    <addaction name="actionViewReadme"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuTools"/>
   <addaction name="menuBatch"/>
   <addaction name="menuHelp"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="mainToolBar">
   <property name="windowTitle">
    <string>Main Toolbar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="actionOpenRequirements"/>
   <addaction name="actionFetchRequirements"/>
   <addaction name="actionCreateVenv"/>
   <addaction name="actionResolveMatrix"/>
   <addaction name="actionPause"/>
   <addaction name="actionResume"/>
   <addaction name="actionStop"/>
   <addaction name="actionRunBatch"/>
   <addaction name="actionAbout"/>
   <addaction name="actionViewReadme"/>
  </widget>
  <action name="actionOpenRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/open.svg</normaloff>:/icons/icons/open.svg</iconset>
   </property>
   <property name="text">
    <string>Open requirements file...</string>
   </property>
  </action>
  <action name="actionFetchRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/url.svg</normaloff>:/icons/icons/url.svg</iconset>
   </property>
   <property name="text">
    <string>Fetch requirements from URL...</string>
   </property>
  </action>
  <action name="actionExit">
   <property name="text">
    <string>Exit</string>
   </property>
  </action>
  <action name="actionCreateVenv">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/venv.svg</normaloff>:/icons/icons/venv.svg</iconset>
   </property>
   <property name="text">
    <string>Create/Update venv</string>
   </property>
  </action>
  <action name="actionResolveMatrix">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resolve.svg</normaloff>:/icons/icons/resolve.svg</iconset>
   </property>
   <property name="text">
    <string>Resolve matrix</string>
   </property>
  </action>
  <action name="actionPause">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/pause.svg</normaloff>:/icons/icons/pause.svg</iconset>
   </property>
   <property name="text">
    <string>Pause</string>
   </property>
  </action>
  <action name="actionResume">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resume.svg</normaloff>:/icons/icons/resume.svg</iconset>
   </property>
   <property name="text">
    <string>Resume</string>
   </property>
  </action>
  <action name="actionStop">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/stop.svg</normaloff>:/icons/icons/stop.svg</iconset>
   </property>
   <property name="text">
    <string>Stop</string>
   </property>
  </action>
  <action name="actionRunBatch">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/batch.svg</normaloff>:/icons/icons/batch.svg</iconset>
   </property>
   <property name="text">
    <string>Run batch</string>
   </property>
  </action>
  <action name="actionAbout">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/info.svg</normaloff>:/icons/icons/info.svg</iconset>
   </property>
   <property name="text">
    <string>About</string>
   </property>
  </action>
  <action name="actionViewReadme">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/readme.svg</normaloff>:/icons/icons/readme.svg</iconset>
   </property>
   <property name="text">
    <string>View README</string>
   </property>
  </action>
  <action name="separator">
   <property name="separator" stdset="0">
    <bool>true</bool>
   </property>
  </action>
 </widget>
 <resources>
  <include location="../PipMatrixResolverQt.qrc"/>
 </resources>
 <connections/>
</ui>

#-------------------------------------------------------------------------------
# File: src/main.cpp
#-------------------------------------------------------------------------------
#include <QApplication>
#include <QTranslator>
#include <QLocale>
#include <QFile>
#include <QDebug>
#include <QIcon>
#include "MainWindow.h"

int main(int argc, char *argv[])
{
    // Set app version before MainWindow is constructed
    MainWindow::appVersion = "0.1.3"; // or any version you wan

    QCoreApplication::setOrganizationName(MainWindow::kOrganizationName);
    QCoreApplication::setApplicationName(MainWindow::kApplicationName);

    QApplication theApplication(argc, argv);

    // Register compiled resources
    Q_INIT_RESOURCE(PipMatrixResolverQt);

    // Enable icons in menus globally
    theApplication.setAttribute(Qt::AA_DontShowIconsInMenus, false);

    // Set application icon
    QApplication::setWindowIcon(QIcon(":/icons/icons/app.svg"));

    // Diagnostics
    qDebug() << "[RESOURCE CHECK] :/icons/icons/open.svg exists:" << QFile::exists(":/icons/icons/open.svg");

    // Translation loading
    const QString languageCode = QLocale::system().name().split('_').first();
    auto loadTranslator = [&](const QString &baseName) -> bool
    {
        QTranslator *tr = new QTranslator(&theApplication);
        const QString qmFile = QString(":/translations/%1_%2.qm").arg(baseName, languageCode);
        if (tr->load(qmFile))
        {
            theApplication.installTranslator(tr);
            qDebug() << "Loaded translation:" << qmFile;
            return true;
        }
        delete tr;
        return false;
    };

    loadTranslator("PipMatrixResolverQt");
    loadTranslator("MatrixUtility");
    loadTranslator("MatrixHistory");

    MainWindow w;
    w.show();
    return theApplication.exec();
}

#-------------------------------------------------------------------------------
# File: tests/gtest_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity)
{
    ResolverEngine engine;
    // Replace with a real method from your class
    EXPECT_TRUE(engine.isValid());
}

#-------------------------------------------------------------------------------
# File: tests/qt_test_main.cpp
#-------------------------------------------------------------------------------
#include <QTest>
#include "test_mainwindow.h"

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    int status = 0;
    status |= QTest::qExec(new TestMainWindow, argc, argv);
    return status;
}

#-------------------------------------------------------------------------------
# File: tests/qtest_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject {
    Q_OBJECT

private slots:
    void initTestCase() {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

QTEST_MAIN(TestMainWindow)
#include "qtest_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_main.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>

int main(int argc, char **argv) 
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

#-------------------------------------------------------------------------------
# File: tests/test_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase() 
    {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

#include "test_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity) 
{
    ResolverEngine engine;
    EXPECT_TRUE(engine.isValid());
}

# Directory Structure
#-------------------------------------------------------------------------------
â”œâ”€â”€ .qtcreator
â”‚   â”œâ”€â”€ qtc-cmake-presets-NtZsHeFT
â”‚   â””â”€â”€ CMakeLists.txt.user
â”œâ”€â”€ icons
â”‚   â”œâ”€â”€ app.svg
â”‚   â”œâ”€â”€ batch.svg
â”‚   â”œâ”€â”€ cancel.svg
â”‚   â”œâ”€â”€ info.svg
â”‚   â”œâ”€â”€ open.svg
â”‚   â”œâ”€â”€ pause.svg
â”‚   â”œâ”€â”€ readme.svg
â”‚   â”œâ”€â”€ resolve.svg
â”‚   â”œâ”€â”€ resume.svg
â”‚   â”œâ”€â”€ stop.svg
â”‚   â”œâ”€â”€ url.svg
â”‚   â””â”€â”€ venv.svg
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ CommandsTab.cpp
â”‚   â”œâ”€â”€ CommandsTab.h
â”‚   â”œâ”€â”€ MainWindow.cpp
â”‚   â”œâ”€â”€ MainWindow.h
â”‚   â”œâ”€â”€ MainWindow.ui
â”‚   â””â”€â”€ main.cpp
â”œâ”€â”€ tests
â”‚   â”œâ”€â”€ gtest_resolver.cpp
â”‚   â”œâ”€â”€ qt_test_main.cpp
â”‚   â”œâ”€â”€ qtest_mainwindow.cpp
â”‚   â”œâ”€â”€ test_main.cpp
â”‚   â”œâ”€â”€ test_mainwindow.cpp
â”‚   â””â”€â”€ test_resolver.cpp
â”œâ”€â”€ translations
â”‚   â”œâ”€â”€ MatrixHistory_en.qm
â”‚   â”œâ”€â”€ MatrixHistory_en.ts
â”‚   â”œâ”€â”€ MatrixHistory_es.qm
â”‚   â”œâ”€â”€ MatrixHistory_es.ts
â”‚   â”œâ”€â”€ MatrixUtility_en.qm
â”‚   â”œâ”€â”€ MatrixUtility_en.ts
â”‚   â”œâ”€â”€ MatrixUtility_es.qm
â”‚   â”œâ”€â”€ MatrixUtility_es.ts
â”‚   â”œâ”€â”€ PipMatrixResolverQt_en.qm
â”‚   â”œâ”€â”€ PipMatrixResolverQt_en.ts
â”‚   â”œâ”€â”€ PipMatrixResolverQt_es.qm
â”‚   â””â”€â”€ PipMatrixResolverQt_es.ts
â”œâ”€â”€ .gitignore
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ Installation.txt
â”œâ”€â”€ LICENSE
â”œâ”€â”€ PipMatrixResolverQt.qrc
â”œâ”€â”€ README.md
â”œâ”€â”€ The.Plan.txt
â”œâ”€â”€ cleanbash.sh
â”œâ”€â”€ mainwindow_cpp.txt
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ src2txt.bat
â””â”€â”€ src2txt.sh

#*** End of file PipMatrixResolver ***
