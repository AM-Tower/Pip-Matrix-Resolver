#===============================================================================
# Project: PipMatrixResolver
# Generated on: 2025-11-03 20:08:23
# OS: WSL on Ubuntu: 24.04
# This file is used to show full source code, cmake, read me, and file locates.
#================================C

#-------------------------------------------------------------------------------
# File: CMakeLists.txt
#-------------------------------------------------------------------------------
cmake_minimum_required(VERSION 3.24)
project(PipMatrixResolverQt VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

find_package(Qt6 6.10 REQUIRED COMPONENTS Core Gui Widgets LinguistTools Network Concurrent Svg)
qt_standard_project_setup()

# Translations
set(TS_FILES
    translations/PipMatrixResolverQt_en.ts
    translations/PipMatrixResolverQt_es.ts
)
qt_add_translation(QM_FILES ${TS_FILES})

# Resources (icons + translations)
qt_add_resources(APP_RESOURCES PipMatrixResolverQt.qrc)

# Executable
qt_add_executable(PipMatrixResolverQt
    src/main.cpp
    src/MainWindow.cpp src/MainWindow.h src/MainWindow.ui
    src/CommandsTab.cpp src/CommandsTab.h
    ${APP_RESOURCES}
    ${QM_FILES}
)

target_link_libraries(PipMatrixResolverQt PRIVATE
    Qt6::Core
    Qt6::Gui
    Qt6::Widgets
    Qt6::Network
    Qt6::Concurrent
    Qt6::Svg
)
target_include_directories(PipMatrixResolverQt PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Install the executable
install(TARGETS PipMatrixResolverQt DESTINATION bin)

# Install Python scripts and requirements files
install(FILES
    src/venv_manager.py
    src/requirements.in
    src/requirements.txt
    DESTINATION share/pipmatrixresolverqt/python
)

# Optionally, show a message after install
install(CODE "message(\"\nPython scripts installed to: \${CMAKE_INSTALL_PREFIX}/share/pipmatrixresolverqt/python\nPlease ensure you have Python 3 and pip installed on your system.\")")

# Deployment logic
if(WIN32)
    find_program(WINDEPLOYQT_EXECUTABLE NAMES windeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(WINDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${WINDEPLOYQT_EXECUTABLE} --verbose 0 --no-compiler-runtime "$<TARGET_FILE:PipMatrixResolverQt>"
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (Windows)"
        )
    endif()
elseif(APPLE)
    find_program(MACDEPLOYQT_EXECUTABLE NAMES macdeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(MACDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${MACDEPLOYQT_EXECUTABLE} "$<TARGET_BUNDLE_DIR:PipMatrixResolverQt>" -verbose=1
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (macOS)"
        )
    endif()
elseif(UNIX)
    message(STATUS "✅ Linux build — Qt runtime deployment handled by system packages.")
endif()

# Packaging with CPack (Qt Installer, NSIS, DEB/RPM)
include(InstallRequiredSystemLibraries)
set(CPACK_PACKAGE_NAME "PipMatrixResolverQt")
set(CPACK_PACKAGE_VENDOR "AM-Tower")
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Python venv and pip-tools GUI manager")
set(CPACK_PACKAGE_VERSION_MAJOR "0")
set(CPACK_PACKAGE_VERSION_MINOR "1")
set(CPACK_PACKAGE_VERSION_PATCH "0")
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")
set(CPACK_RESOURCE_FILE_README "${CMAKE_CURRENT_SOURCE_DIR}/README.md")
set(CPACK_PACKAGE_EXECUTABLES "PipMatrixResolverQt" "PipMatrixResolverQt")

if(WIN32)
    set(CPACK_GENERATOR "NSIS")
    set(CPACK_NSIS_DISPLAY_NAME "PipMatrixResolverQt")
    set(CPACK_NSIS_PACKAGE_NAME "PipMatrixResolverQt")
    set(CPACK_NSIS_CONTACT "Occupant.AM.Tower@gmail.com")
elseif(APPLE)
    set(CPACK_GENERATOR "DragNDrop")
else()
    set(CPACK_GENERATOR "DEB;RPM")
    set(CPACK_DEBIAN_PACKAGE_MAINTAINER "Jeffrey Scott Flesher")
endif()

include(CPack)

#-------------------------------------------------------------------------------
# File: PipMatrixResolverQt.qrc
#-------------------------------------------------------------------------------
<RCC>
    <!-- Icons -->
    <qresource prefix="/icons">
        <file>icons/app.svg</file>
        <file>icons/open.svg</file>
        <file>icons/url.svg</file>
        <file>icons/venv.svg</file>
        <file>icons/resolve.svg</file>
        <file>icons/pause.svg</file>
        <file>icons/resume.svg</file>
        <file>icons/stop.svg</file>
        <file>icons/batch.svg</file>
        <file>icons/info.svg</file>
        <file>icons/readme.svg</file>
    </qresource>

    <!-- Translations -->
    <qresource prefix="/translations">
        <file>translations/PipMatrixResolverQt_en.qm</file>
        <file>translations/PipMatrixResolverQt_es.qm</file>
    </qresource>

    <!-- Docs -->
    <qresource prefix="/docs">
        <file>README.md</file>
    </qresource>

</RCC>
#-------------------------------------------------------------------------------
# File: README.md
#-------------------------------------------------------------------------------
# PipMatrixResolverQt

## Status:
* Not working.
* Just starting this project, and it will take time to get to a working version.

### A cross platform Qt 6.10 C++ GUI for resolving Python requirements.txt matrices, managing virtual environments, and running batch multimedia conversions.

Features

* Resolve Python dependency matrices with pip-tools
* Manage virtual environments (create, upgrade pip and pip-tools)
* Batch convert audio + image to MP4 with ffmpeg
* Qt GUI with menus, log view, progress bar
* Translation support (English and Spanish)

## Build Instructions
```
mkdir build
 cd build
 cmake ..
 cmake --build .
 # cmake -S . -B build -DCMAKE\_PREFIX\_PATH="C:/Qt/6.10.0/mingw\_64"
```

### Create the installer/package:

```
cpack
```

## On Windows, windeployqt is run automatically after build.

Project Tree

```
Qt/
├── build
├── icons
│   ├── app.svg
│   ├── batch.svg
│   ├── cancel.svg
│   ├── info.svg
│   ├── open.svg
│   ├── pause.svg
│   ├── readme.svg
│   ├── resolve.svg
│   ├── resume.svg
│   ├── stop.svg
│   ├── url.svg
│   └── venv.svg
├── src
│   ├── BatchRunner.cpp
│   ├── BatchRunner.h
│   ├── MainWindow.cpp
│   ├── MainWindow.h
│   ├── MainWindow.ui
│   ├── PipToolsRunner.cpp
│   ├── PipToolsRunner.h
│   ├── ResolverEngine.cpp
│   ├── ResolverEngine.h
│   ├── VenvManager.cpp
│   ├── VenvManager.h
│   └── main.cpp
├── src_text
│   ├── BatchRunner.cpp.txt
│   ├── BatchRunner.h.txt
│   ├── MainWindow.cpp.txt
│   ├── MainWindow.h.txt
│   ├── MainWindow.ui.autosave.txt
│   ├── MainWindow.ui.txt
│   ├── PipMatrixResolverQt.qrc.txt
│   ├── PipToolsRunner.cpp.txt
│   ├── PipToolsRunner.h.txt
│   ├── ResolverEngine.cpp.txt
│   ├── ResolverEngine.h.txt
│   ├── VenvManager.cpp.txt
│   ├── VenvManager.h.txt
│   └── main.cpp.txt
├── tests
│   ├── gtest_resolver.cpp
│   ├── qt_test_main.cpp
│   ├── qtest_mainwindow.cpp
│   ├── test_main.cpp
│   ├── test_mainwindow.cpp
│   └── test_resolver.cpp
├── translations
│   ├── PipMatrixResolverQt_en.qm
│   ├── PipMatrixResolverQt_en.ts
│   ├── PipMatrixResolverQt_es.qm
│   └── PipMatrixResolverQt_es.ts
├── .gitignore
├── CMakeLists.txt
├── LICENSE
├── PipMatrixResolverQt.qrc
├── README.md
├── cleanbash.sh
├── requirements.txt
├── src2txt.bat
└── src2txt.sh
```

## File Descriptions

Root
```
CMakeLists.txt – Build script: compiles sources, generates qm from ts, bundles resources
PipMatrixResolverQt.qrc – Qt resource file embedding icons and compiled translations
```

resources/icons
```
SVG icons used in menus and toolbars
```

src
```
main.cpp – Application entry point. Sets up QApplication, loads translations, shows MainWindow
MainWindow.h/.cpp/.ui – Main GUI window. Defines menus, log view, progress bar, and user actions
ResolverEngine.h/.cpp – Core engine for iterating over package version combinations. Emits logs, progress, and success signals
PipToolsRunner.h/.cpp – Wrapper around pip-compile. Runs with retries, logs output, analyzes errors
VenvManager.h/.cpp – Creates and manages Python virtual environments. Upgrades pip and pip-tools
BatchRunner.h/.cpp – Automates ffmpeg jobs. Enqueues tasks, parses progress, emits job completion signals
```

translations
```
PipMatrixResolverQt\_en.ts – English translation source
PipMatrixResolverQt\_es.ts – Spanish translation source
Both are compiled into qm at build time and embedded
```

build
```
Out of source build directory. Keeps generated files separate from source tree
```

Usage

```
File → Open requirements file – Load a local requirements.txt
Tools → Create/Update venv – Create or update a Python virtual environment
Tools → Resolve matrix – Start iterative resolution of package versions
Batch → Run batch conversion to mp4 – Combine audio and image into MP4
Help → About – Show app info
```

## Terminal Tab — What You Can Do
* Run Python scripts:
    * python myscript.py

* Install a package:
    * pip install package_name

* Uninstall a package:
    * pip uninstall package_name

* List installed packages:
    * pip list

* Show package details:
    * pip show package_name

* Upgrade a package:
    * pip install --upgrade package_name

* Run pip-tools commands:
    * pip-compile requirements.in
    * pip-sync

* Check Python version:
    * python --version

* Check pip version:
    * pip --version

* Run any shell command:
    * On Windows: dir
    * On Linux/macOS: ls

* View contents of a file:
    * On Windows: type filename.txt
    * On Linux/macOS: cat filename.txt

* Check environment variables:
    * On Windows: set
    * On Linux/macOS: env

* Run batch or shell scripts:
    * bash script.sh (Linux/macOS)
    * script.bat (Windows)

* Deactivate the virtual environment (if you started a shell session manually):
    * deactivate

## License: 
    Unlicensed, MIT or your chosen license

#-------------------------------------------------------------------------------
# File: src/CommandsTab.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file CommandsTab.cpp
 * @brief Implements the CommandsTab class for dynamic command UI,
 *        batch execution, project editing, and JSON persistence.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.7
 * @date    2025-11-03
 * @section License MIT
 * @section DESCRIPTION
 * This file contains the implementation of CommandsTab widget.
 ***************************************************************/
#include "CommandsTab.h"
#include <QFileInfo>
#include <QMessageBox>
#include <QInputDialog>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QDialogButtonBox>
#include <QScrollArea>
#include <QTextStream>

/****************************************************************
 * @brief Constructor: Builds the UI and loads initial state.
 ***************************************************************/
CommandsTab::CommandsTab(QWidget *parent) : QWidget(parent)
{
    buildUI();
    loadProjects("projects.json");
}

/****************************************************************
 * @brief Builds the static UI components.
 ***************************************************************/
void CommandsTab::buildUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);

    // Project selector and management buttons
    QHBoxLayout *projLayout = new QHBoxLayout;
    projectDropdown = new QComboBox;
    connect(projectDropdown, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &CommandsTab::onProjectChanged);
    addProjectButton = new QPushButton("Add");
    editProjectButton = new QPushButton("Edit");
    deleteProjectButton = new QPushButton("Delete");
    connect(addProjectButton, &QPushButton::clicked, this, &CommandsTab::onAddProject);
    connect(editProjectButton, &QPushButton::clicked, this, &CommandsTab::onEditProject);
    connect(deleteProjectButton, &QPushButton::clicked, this, &CommandsTab::onDeleteProject);
    projLayout->addWidget(new QLabel("Project:"));
    projLayout->addWidget(projectDropdown);
    projLayout->addWidget(addProjectButton);
    projLayout->addWidget(editProjectButton);
    projLayout->addWidget(deleteProjectButton);
    mainLayout->addLayout(projLayout);

    // Dynamic inputs area
    inputsLayout = new QVBoxLayout;
    mainLayout->addLayout(inputsLayout);

    // Extra arguments
    extraArgsEdit = new QLineEdit;
    connect(extraArgsEdit, &QLineEdit::textChanged, this, &CommandsTab::updatePreview);
    mainLayout->addWidget(new QLabel("Extra Arguments:"));
    mainLayout->addWidget(extraArgsEdit);

    // Command preview + clear button
    QHBoxLayout *previewLayout = new QHBoxLayout;
    commandPreview = new QLineEdit;
    commandPreview->setReadOnly(true);
    clearButton = new QToolButton;
    clearButton->setText("X");
    connect(clearButton, &QToolButton::clicked, this, &CommandsTab::onClearCommand);
    previewLayout->addWidget(commandPreview);
    previewLayout->addWidget(clearButton);
    mainLayout->addLayout(previewLayout);

    // Batch file selector
    QHBoxLayout *batchLayout = new QHBoxLayout;
    batchFileEdit = new QLineEdit;
    batchFileEdit->setPlaceholderText("Batch file (one path per line)");
    QPushButton *browseBatchBtn = new QPushButton("Browse");
    connect(browseBatchBtn, &QPushButton::clicked, this, &CommandsTab::onBrowseBatchFile);
    batchLayout->addWidget(batchFileEdit);
    batchLayout->addWidget(browseBatchBtn);
    mainLayout->addLayout(batchLayout);

    // Output console
    outputConsole = new QTextEdit;
    outputConsole->setReadOnly(true);
    mainLayout->addWidget(new QLabel("Command Output:"));
    mainLayout->addWidget(outputConsole);

    // Run buttons
    QHBoxLayout *runLayout = new QHBoxLayout;
    runButton = new QPushButton("Run Command");
    runBatchButton = new QPushButton("Run Batch");
    connect(runButton, &QPushButton::clicked, this, &CommandsTab::onRunCommand);
    connect(runBatchButton, &QPushButton::clicked, this, &CommandsTab::onRunBatch);
    runLayout->addWidget(runButton);
    runLayout->addWidget(runBatchButton);
    mainLayout->addLayout(runLayout);
}

/****************************************************************
 * @brief Loads projects from a JSON file.
 ***************************************************************/
bool CommandsTab::loadProjects(const QString &jsonPath)
{
    QFile file(jsonPath);
    if (!file.open(QIODevice::ReadOnly))
    {
        return false;
    }

    QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
    QJsonArray projArray = doc["projects"].toArray();

    projects.clear();
    projectDropdown->clear();

    for (int i = 0; i < projArray.size(); ++i)
    {
        QJsonObject obj = projArray.at(i).toObject();
        ProjectDef proj;
        proj.name = obj["name"].toString();
        proj.scriptPath = obj["script"].toString();
        proj.extraArgs = obj["extra_args"].toString();

        QJsonArray inputsArr = obj["inputs"].toArray();
        for (int j = 0; j < inputsArr.size(); ++j)
        {
            QJsonObject inObj = inputsArr.at(j).toObject();
            proj.inputs.append({inObj["label"].toString(), inObj["switch"].toString()});
        }

        projects.append(proj);
        projectDropdown->addItem(proj.name);
    }
    if (!projects.isEmpty())
    {
        onProjectChanged(0);
    }
    return true;
}

/****************************************************************
 * @brief Saves projects to a JSON file.
 ***************************************************************/
bool CommandsTab::saveProjects(const QString &jsonPath)
{
    QJsonArray arr;
    for (int i = 0; i < projects.size(); ++i)
    {
        const ProjectDef &proj = projects.at(i);
        QJsonObject obj;
        obj["name"] = proj.name;
        obj["script"] = proj.scriptPath;
        obj["extra_args"] = proj.extraArgs;
        QJsonArray inputsArr;
        for (int j = 0; j < proj.inputs.size(); ++j)
        {
            const InputDef &input = proj.inputs.at(j);
            QJsonObject inObj;
            inObj["label"] = input.label;
            inObj["switch"] = input.switchName;
            inputsArr.append(inObj);
        }
        obj["inputs"] = inputsArr;
        arr.append(obj);
    }
    QJsonObject root;
    root["projects"] = arr;
    QFile file(jsonPath);
    if (!file.open(QIODevice::WriteOnly))
    {
        return false;
    }
    file.write(QJsonDocument(root).toJson());
    return true;
}

/****************************************************************
 * @brief Handles project selection change.
 ***************************************************************/
void CommandsTab::onProjectChanged(int index)
{
    if (index < 0 || index >= projects.size())
    {
        return;
    }
    rebuildInputs(projects.at(index));
    extraArgsEdit->setText(projects.at(index).extraArgs);
    updatePreview();
}

/****************************************************************
 * @brief Rebuilds input fields dynamically.
 ***************************************************************/
void CommandsTab::rebuildInputs(const ProjectDef &proj)
{
    QLayoutItem *child;
    while ((child = inputsLayout->takeAt(0)) != nullptr)
    {
        delete child->widget();
        delete child;
    }
    inputEdits.clear();

    for (int i = 0; i < proj.inputs.size(); ++i)
    {
        const InputDef &input = proj.inputs.at(i);
        auto lbl = new QLabel(input.label);
        auto edit = new QLineEdit;
        connect(edit, &QLineEdit::textChanged, this, &CommandsTab::updatePreview);
        inputsLayout->addWidget(lbl);
        inputsLayout->addWidget(edit);
        inputEdits.append(edit);
    }
}

/****************************************************************
 * @brief Builds the full command string.
 ***************************************************************/
QString CommandsTab::buildCommand() const
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        return QString();
    }

    const ProjectDef &proj = projects.at(index);
    QString cmd = QString("python \"%1\" ").arg(proj.scriptPath);

    for (int i = 0; i < inputEdits.size(); ++i)
    {
        QString val = inputEdits.at(i)->text().trimmed();
        if (!val.isEmpty())
        {
            cmd += QString("%1 \"%2\" ").arg(proj.inputs.at(i).switchName, val);
        }
    }

    if (!extraArgsEdit->text().isEmpty())
    {
        cmd += extraArgsEdit->text();
    }

    return cmd.trimmed();
}

/****************************************************************
 * @brief Validates script and input files exist.
 ***************************************************************/
bool CommandsTab::validateFiles(QString &errorMsg) const
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        errorMsg = "Invalid project selected.";
        return false;
    }

    QFileInfo scriptInfo(projects.at(index).scriptPath);
    if (!scriptInfo.exists())
    {
        errorMsg = "Script file does not exist.";
        return false;
    }

    for (int i = 0; i < inputEdits.size(); ++i)
    {
        if (!inputEdits.at(i)->text().isEmpty())
        {
            QFileInfo fi(inputEdits.at(i)->text());
            if (!fi.exists())
            {
                errorMsg = QString("Input file missing: %1").arg(inputEdits.at(i)->text());
                return false;
            }
        }
    }
    return true;
}

/****************************************************************
 * @brief Updates the command preview.
 ***************************************************************/
void CommandsTab::updatePreview()
{
    commandPreview->setText(buildCommand());
}

/****************************************************************
 * @brief Runs the command using QProcess.
 ***************************************************************/
void CommandsTab::onRunCommand()
{
    QString errorMsg;
    if (!validateFiles(errorMsg))
    {
        QMessageBox::critical(this, "Validation Error", errorMsg);
        return;
    }

    QString cmd = buildCommand();
    outputConsole->append(QString("Running: %1").arg(cmd));
    executeCommand(cmd);
}

/****************************************************************
 * @brief Runs batch commands from a file.
 ***************************************************************/
void CommandsTab::onRunBatch()
{
    QString batchFile = batchFileEdit->text();
    QFile file(batchFile);
    if (!file.open(QIODevice::ReadOnly))
    {
        QMessageBox::critical(this, "Error", "Cannot open batch file.");
        return;
    }

    QTextStream in(&file);
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        QMessageBox::critical(this, "Error", "No project selected.");
        return;
    }
    const ProjectDef &proj = projects.at(index);

    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
        if (line.isEmpty()) continue;

        QStringList batchInputs = line.split(' ', Qt::SkipEmptyParts);
        for (int i = 0; i < inputEdits.size(); ++i)
        {
            if (i < batchInputs.size())
            {
                inputEdits.at(i)->setText(batchInputs.at(i));
            }
            else
            {
                inputEdits.at(i)->clear();
            }
        }
        QString cmd = buildCommand();
        outputConsole->append(QString("Batch Running: %1").arg(cmd));
        executeCommand(cmd);
    }
}

/****************************************************************
 * @brief Executes a command and streams output.
 ***************************************************************/
void CommandsTab::executeCommand(const QString &cmd)
{
    QProcess *proc = new QProcess(this);
    proc->setProcessChannelMode(QProcess::MergedChannels);
    connect(proc, &QProcess::readyReadStandardOutput, [this, proc]()
            {
                outputConsole->append(proc->readAllStandardOutput());
            });
    connect(proc, &QProcess::readyReadStandardError, [this, proc]()
            {
                outputConsole->append(proc->readAllStandardError());
            });
    proc->start(cmd);
}

/****************************************************************
 * @brief Clears the command preview.
 ***************************************************************/
void CommandsTab::onClearCommand()
{
    commandPreview->clear();
}

/****************************************************************
 * @brief Opens a file dialog to select batch file.
 ***************************************************************/
void CommandsTab::onBrowseBatchFile()
{
    QString fileName = QFileDialog::getOpenFileName(this, "Select Batch File", QString(), "Text Files (*.txt);;All Files (*)");
    if (!fileName.isEmpty())
    {
        batchFileEdit->setText(fileName);
    }
}

/****************************************************************
 * @brief Shows the project editor dialog for add/edit.
 ***************************************************************/
bool CommandsTab::showProjectDialog(ProjectDef &proj, bool isEdit)
{
    QDialog dialog(this);
    dialog.setWindowTitle(isEdit ? "Edit Project" : "Add Project");
    QFormLayout *form = new QFormLayout(&dialog);

    QLineEdit *nameEdit = new QLineEdit(proj.name, &dialog);
    QLineEdit *scriptEdit = new QLineEdit(proj.scriptPath, &dialog);
    QLineEdit *extraArgsEditDlg = new QLineEdit(proj.extraArgs, &dialog);
    QSpinBox *inputCountSpin = new QSpinBox(&dialog);
    inputCountSpin->setRange(1, 10);
    inputCountSpin->setValue(proj.inputs.isEmpty() ? 2 : proj.inputs.size());

    QVector<QLineEdit*> labelEdits;
    QVector<QLineEdit*> switchEdits;
    QVBoxLayout *inputsVBox = new QVBoxLayout;
    for (int i = 0; i < inputCountSpin->value(); ++i)
    {
        QHBoxLayout *row = new QHBoxLayout;
        QLineEdit *lblEdit = new QLineEdit(i < proj.inputs.size() ? proj.inputs.at(i).label : QString("input%1").arg(i+1), &dialog);
        QLineEdit *swEdit = new QLineEdit(i < proj.inputs.size() ? proj.inputs.at(i).switchName : "", &dialog);
        row->addWidget(new QLabel("Label:"));
        row->addWidget(lblEdit);
        row->addWidget(new QLabel("Switch:"));
        row->addWidget(swEdit);
        inputsVBox->addLayout(row);
        labelEdits.append(lblEdit);
        switchEdits.append(swEdit);
    }
    connect(inputCountSpin, QOverload<int>::of(&QSpinBox::valueChanged),
            [inputsVBox, &labelEdits, &switchEdits, &dialog](int count)
            {
                QLayoutItem *child;
                while ((child = inputsVBox->takeAt(0)) != nullptr)
                {
                    delete child->widget();
                    delete child;
                }
                labelEdits.clear();
                switchEdits.clear();
                for (int i = 0; i < count; ++i)
                {
                    QHBoxLayout *row = new QHBoxLayout;
                    QLineEdit *lblEdit = new QLineEdit(QString("input%1").arg(i+1), &dialog);
                    QLineEdit *swEdit = new QLineEdit("", &dialog);
                    row->addWidget(new QLabel("Label:"));
                    row->addWidget(lblEdit);
                    row->addWidget(new QLabel("Switch:"));
                    row->addWidget(swEdit);
                    inputsVBox->addLayout(row);
                    labelEdits.append(lblEdit);
                    switchEdits.append(swEdit);
                }
            }
            );

    form->addRow("Project Name:", nameEdit);
    form->addRow("Script Path:", scriptEdit);
    form->addRow("Extra Args:", extraArgsEditDlg);
    form->addRow("Number of Inputs:", inputCountSpin);
    form->addRow("Inputs:", inputsVBox);

    QDialogButtonBox *buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, &dialog);
    form->addRow(buttons);
    connect(buttons, &QDialogButtonBox::accepted, &dialog, &QDialog::accept);
    connect(buttons, &QDialogButtonBox::rejected, &dialog, &QDialog::reject);

    if (dialog.exec() == QDialog::Accepted)
    {
        proj.name = nameEdit->text();
        proj.scriptPath = scriptEdit->text();
        proj.extraArgs = extraArgsEditDlg->text();
        proj.inputs.clear();
        for (int i = 0; i < labelEdits.size(); ++i)
        {
            proj.inputs.append({labelEdits.at(i)->text(), switchEdits.at(i)->text()});
        }
        return true;
    }
    return false;
}

/****************************************************************
 * @brief Adds a new project.
 ***************************************************************/
void CommandsTab::onAddProject()
{
    ProjectDef proj;
    if (showProjectDialog(proj, false))
    {
        projects.append(proj);
        saveProjects("projects.json");
        refreshProjectDropdown();
        projectDropdown->setCurrentIndex(projects.size() - 1);
    }
}

/****************************************************************
 * @brief Edits the selected project.
 ***************************************************************/
void CommandsTab::onEditProject()
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        return;
    }
    ProjectDef proj = projects.at(index);
    if (showProjectDialog(proj, true))
    {
        projects[index] = proj;
        saveProjects("projects.json");
        refreshProjectDropdown();
        projectDropdown->setCurrentIndex(index);
    }
}

/****************************************************************
 * @brief Deletes the selected project.
 ***************************************************************/
void CommandsTab::onDeleteProject()
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        return;
    }
    if (QMessageBox::question(this, "Delete Project", "Are you sure you want to delete this project?") == QMessageBox::Yes)
    {
        projects.remove(index);
        saveProjects("projects.json");
        refreshProjectDropdown();
        if (!projects.isEmpty())
        {
            projectDropdown->setCurrentIndex(0);
        }
    }
}

/****************************************************************
 *es.
 ***************************************************************/
void CommandsTab::refreshProjectDropdown()
{
    projectDropdown->clear();
    for (int i = 0; i < projects.size(); ++i)
    {
        projectDropdown->addItem(projects.at(i).name);
    }
}
/************** End of CommandsTab.cpp **************************/

#-------------------------------------------------------------------------------
# File: src/CommandsTab.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file CommandsTab.h
 * @brief Declares the CommandsTab class for dynamic command UI,
 *        batch execution, project editing, and JSON persistence.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.7
 * @date    2025-11-03
 * @section License MIT
 * @section DESCRIPTION
 * This file defines the CommandsTab widget for PipMatrixResolverQt.
 * Features:
 *   - Dynamic UI from JSON schema
 *   - Batch command execution
 *   - Project add/edit/delete dialogs
 *   - JSON save/load
 *   - Real-time output streaming
 *   - Doxygen headers and C-style braces
 ***************************************************************/
#ifndef COMMANDSTAB_H
#define COMMANDSTAB_H

#include <QWidget>
#include <QComboBox>
#include <QLineEdit>
#include <QPushButton>
#include <QToolButton>
#include <QTextEdit>
#include <QVBoxLayout>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QFile>
#include <QProcess>
#include <QLabel>
#include <QVector>
#include <QDialog>
#include <QSpinBox>
#include <QFileDialog>

/****************************************************************
 * @struct InputDef
 * @brief Defines a single input argument for a command.
 ***************************************************************/
struct InputDef
{
    QString label;
    QString switchName;
};

/****************************************************************
 * @struct ProjectDef
 * @brief Defines a project with script, inputs, and extra args.
 ***************************************************************/
struct ProjectDef
{
    QString name;
    QString scriptPath;
    QVector<InputDef> inputs;
    QString extraArgs;
};

/****************************************************************
 * @class CommandsTab
 * @brief Implements the dynamic command management tab.
 ***************************************************************/
class CommandsTab : public QWidget
{
    Q_OBJECT

public:
    explicit CommandsTab(QWidget *parent = nullptr);
    bool loadProjects(const QString &jsonPath);
    bool saveProjects(const QString &jsonPath);

private slots:
    void onProjectChanged(int index);
    void onRunCommand();
    void onRunBatch();
    void onClearCommand();
    void onAddProject();
    void onEditProject();
    void onDeleteProject();
    void updatePreview();
    void onBrowseBatchFile();

private:
    QVector<ProjectDef> projects;

    QComboBox *projectDropdown;
    QVBoxLayout *inputsLayout;
    QVector<QLineEdit *> inputEdits;
    QLineEdit *extraArgsEdit;
    QLineEdit *commandPreview;
    QTextEdit *outputConsole;
    QLineEdit *batchFileEdit;
    QPushButton *runButton;
    QPushButton *runBatchButton;
    QPushButton *addProjectButton;
    QPushButton *editProjectButton;
    QPushButton *deleteProjectButton;
    QToolButton *clearButton;

    void buildUI();
    void rebuildInputs(const ProjectDef &proj);
    QString buildCommand() const;
    bool validateFiles(QString &errorMsg) const;
    void executeCommand(const QString &cmd);

    // Project editor dialog helpers
    bool showProjectDialog(ProjectDef &proj, bool isEdit = false);
    void refreshProjectDropdown();
};

#endif // COMMANDSTAB_H
/************** End of CommandsTab.h ***************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.cpp
 * @brief Implements the main application window.
 *
 * @author Jeffrey Scott Flesher with Copilot
 * @version 0.6
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Implements the main window logic: settings, history, menus,
 * file and URL loaders, logging, and UI dialog wiring.
 ***************************************************************/

#include "MainWindow.h"
#include "ui_MainWindow.h"
#include <QApplication>
#include <QFileDialog>
#include <QHeaderView>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QEventLoop>
#include <QUrl>
#include <utility> // Add this to your includes for std::as_const
#include <QSysInfo>
#include <QProcess>
#include <QPlainTextEdit>
#include <QLineEdit>
#include <QDir>
#include <QString>
#include <QDebug>

/****************************************************************
 * @brief Globals for MainWindow.
 ***************************************************************/
QString MainWindow::appVersion = "1.0"; // Change in main
const QString DEFAULT_PYTHON_VERSION = "3.11";
const QString DEFAULT_PIP_VERSION = "23.2";
const QString DEFAULT_PIPTOOLS_VERSION = "6.13";
const int DEFAULT_MAX_ITEMS = 10;
const QString DEFAULT_APP_VERSION = "1.0";
const QString MainWindow::kOrganizationName = "AM-Tower";
const QString MainWindow::kApplicationName = "PipMatrixResolver";
/****************************************************************
 * @brief Constructor for MainWindow.
 ***************************************************************/
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent),
    ui(new Ui::MainWindow),
    requirementsModel(new QStandardItemModel(this)),
    requirementsView(nullptr),
    logView(nullptr),
    progress(nullptr),
    recentLocalMenu(nullptr),
    recentWebMenu(nullptr),
    maxHistoryItems(10)
{
    ui->setupUi(this);

    // Manually add Recent Local and Recent Web submenus after actionFetchRequirements
    QList<QAction*> actions = ui->menuFile->actions();
    int insertIndex = -1;
    for (int i = 0; i < actions.size(); ++i)
    {
        if (actions[i] == ui->actionFetchRequirements)
        {
            insertIndex = i;
            break;
        }
    }
    recentLocalMenu = new QMenu(tr("Recent Local"), this);
    recentWebMenu = new QMenu(tr("Recent Web"), this);
    if (insertIndex != -1)
    {
        ui->menuFile->insertMenu(actions[insertIndex + 1], recentLocalMenu);
        ui->menuFile->insertMenu(actions[insertIndex + 1], recentWebMenu);
    }
    else
    {
        ui->menuFile->addMenu(recentLocalMenu);
        ui->menuFile->addMenu(recentWebMenu);
    }

    requirementsView = ui->requirementsView;
    logView = ui->logView;
    localHistoryTable = ui->localHistoryTable;
    webHistoryTable = ui->webHistoryTable;
    localHistoryModel = new QStandardItemModel(this);
    webHistoryModel = new QStandardItemModel(this);
    localHistoryTable->setModel(localHistoryModel);
    webHistoryTable->setModel(webHistoryModel);
    progress = ui->progressBar;

    gpuDetectedCheckBox = ui->gpuDetectedCheckBox;
    useCpuCheckBox = ui->useCpuCheckBox;
    cudaCheckBox = ui->cudaCheckBox;
    osEdit = ui->osEdit;
    osReleaseEdit = ui->osReleaseEdit;
    osVersionEdit = ui->osVersionEdit;

    requirementsView->setModel(requirementsModel);
    requirementsView->setAlternatingRowColors(true);
    requirementsView->setSelectionBehavior(QAbstractItemView::SelectRows);
    requirementsView->setSelectionMode(QAbstractItemView::ExtendedSelection);
    requirementsView->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    requirementsView->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    requirementsView->resizeColumnsToContents();
    requirementsView->resizeRowsToContents();
    requirementsView->setSizeAdjustPolicy(QAbstractScrollArea::AdjustToContents);
    requirementsView->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
    requirementsView->setHorizontalScrollMode(QAbstractItemView::ScrollPerPixel);

    loadAppSettings();
    loadHistory();

    connect(ui->actionOpenRequirements, &QAction::triggered, this, &MainWindow::openLocalRequirements);
    connect(ui->actionFetchRequirements, &QAction::triggered, this, &MainWindow::fetchRequirementsFromUrl);
    connect(ui->actionExit, &QAction::triggered, this, &MainWindow::exitApp);

    if (ui->buttonBoxPreferences)
    {
        connect(ui->buttonBoxPreferences, &QDialogButtonBox::accepted, this, &MainWindow::saveAppSettings);
        QPushButton *applyBtn = ui->buttonBoxPreferences->button(QDialogButtonBox::Apply);
        if (applyBtn)
        {
            connect(applyBtn, &QPushButton::clicked, this, &MainWindow::saveAppSettings);
        }
    }
    connect(ui->actionAbout, &QAction::triggered, this, &MainWindow::showAboutBox);
    connect(ui->actionViewReadme, &QAction::triggered, this, &MainWindow::showReadmeDialog);
    ui->mainTabs->setCurrentIndex(0);
    ui->mainTabs->setCurrentWidget(ui->tabMain);

    // History tables and models
    localHistoryTable = ui->localHistoryTable;
    webHistoryTable = ui->webHistoryTable;
    localHistoryModel = new QStandardItemModel(this);
    webHistoryModel = new QStandardItemModel(this);
    localHistoryTable->setModel(localHistoryModel);
    webHistoryTable->setModel(webHistoryModel);

    connect(localHistoryTable->selectionModel(), &QItemSelectionModel::selectionChanged,
            this, &MainWindow::updateLocalHistoryButtons);
    connect(webHistoryTable->selectionModel(), &QItemSelectionModel::selectionChanged,
            this, &MainWindow::updateWebHistoryButtons);
    connect(ui->actionCreateVenv, &QAction::triggered, this, &MainWindow::onCreateVenv);

    // Terminal tab
    connect(ui->runCommandBtn, &QPushButton::clicked, this, &MainWindow::onRunCommand);
    connect(ui->clearTerminalBtn, &QPushButton::clicked, this, &MainWindow::onClearTerminal);

    // Package Manager tab
    connect(ui->searchPackageBtn, &QPushButton::clicked, this, &MainWindow::onSearchPackage);
    connect(ui->installPackageBtn, &QPushButton::clicked, this, &MainWindow::onInstallPackage);
    connect(ui->uninstallPackageBtn, &QPushButton::clicked, this, &MainWindow::onUninstallPackage);

    connect(ui->mainTabs, &QTabWidget::currentChanged, this, [this](int index){
        if (ui->mainTabs->widget(index)->objectName() == "tabPackageManager") {
            refreshInstalledPackages();
        }
    });
    connect(ui->installedPackagesList, &QListWidget::doubleClicked, this, &MainWindow::onInstalledPackagesListDoubleClicked);

/*
 * Auto connected
    // Connect local history buttons
    connect(ui->localAddButton,    &QPushButton::clicked, this, &MainWindow::on_localAddButton_clicked);
    connect(ui->localEditButton,   &QPushButton::clicked, this, &MainWindow::on_localEditButton_clicked);
    connect(ui->localDeleteButton, &QPushButton::clicked, this, &MainWindow::on_localDeleteButton_clicked);
    connect(ui->localUpButton,     &QPushButton::clicked, this, &MainWindow::on_localUpButton_clicked);
    connect(ui->localDownButton,   &QPushButton::clicked, this, &MainWindow::on_localDownButton_clicked);

    // Connect web history buttons
    connect(ui->webAddButton,    &QPushButton::clicked, this, &MainWindow::on_webAddButton_clicked);
    connect(ui->webEditButton,   &QPushButton::clicked, this, &MainWindow::on_webEditButton_clicked);
    connect(ui->webDeleteButton, &QPushButton::clicked, this, &MainWindow::on_webDeleteButton_clicked);
    connect(ui->webUpButton,     &QPushButton::clicked, this, &MainWindow::on_webUpButton_clicked);
    connect(ui->webDownButton,   &QPushButton::clicked, this, &MainWindow::on_webDownButton_clicked);
*/
    // Refresh tables on startup
    refreshRecentMenus();
    refreshHistoryTables();
    checkAndRestoreSettings();

    detectSystem();         // Detect OS, release, version, GPU
    restoreCpuCudaSettings(); // Restore CPU/Cuda settings from QSettings
    setupVenvPaths();       // Set up venv_running and venv_testing paths
}

/****************************************************************
 * @brief Destructor for MainWindow.
 ***************************************************************/
MainWindow::~MainWindow()
{
    delete ui;
}

/****************************************************************
 * @brief Exits the application.
 ***************************************************************/
void MainWindow::exitApp()
{
    QApplication::quit();
}

/****************************************************************
 * @brief Opens requirements from a local file via dialog.
 ***************************************************************/
void MainWindow::openLocalRequirements()
{
    QString path = QFileDialog::getOpenFileName(this, tr("Open requirements.txt"), QString(), tr("Text Files (*.txt)"));
    if (path.isEmpty())
    {
        return;
    }
    loadRequirementsFromFile(path);
}

/****************************************************************
 * @brief Fetches requirements from a URL via dialog.
 ***************************************************************/
void MainWindow::fetchRequirementsFromUrl()
{
    bool ok = false;
    QString inputUrl = QInputDialog::getText(
        this,
        tr("Fetch requirements"),
        tr("Enter URL:"),
        QLineEdit::Normal,
        "",
        &ok
    );
    if (!ok || inputUrl.isEmpty())
    {
        return;
    }
    const QString rawUrl = normalizeRawUrl(inputUrl);
    loadRequirementsFromUrl(rawUrl);
}

/****************************************************************
 * @brief Loads requirements from a local file.
 ***************************************************************/
void MainWindow::loadRequirementsFromFile(const QString &path)
{
    if (path.isEmpty())
    {
        return;
    }
    if (!QFile::exists(path))
    {
        QMessageBox::warning(this, tr("File missing"), tr("File no longer exists:\n%1").arg(path));
        historyRecentLocal.removeAll(path);
        refreshRecentMenus();
        saveHistory();
        return;
    }
    const QStringList lines = readTextFileLines(path);
    QStringList errors;
    if (!validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(
            this,
            tr("Invalid requirements.txt"),
            tr("Validation failed:\n%1").arg(errors.join("\n"))
        );
        return;
    }
    if (requirementsModel)
    {
        requirementsModel->clear();
        writeTableToModel(lines);
    }
    applySettingsFromUi();
    historyRecentLocal.removeAll(path);
    historyRecentLocal.prepend(path);
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Loaded %1 requirements from %2").arg(requirementsModel->rowCount()).arg(path));
}

/****************************************************************
 * @brief Loads requirements from a URL.
 ***************************************************************/
void MainWindow::loadRequirementsFromUrl(const QString &url)
{
    if (url.isEmpty())
    {
        return;
    }
    QByteArray content;
    if (!downloadText(url, content))
    {
        QMessageBox::warning(this, tr("Download failed"), tr("Failed to fetch requirements from URL:\n%1").arg(url));
        historyRecentWeb.removeAll(url);
        refreshRecentMenus();
        saveHistory();
        return;
    }
    const QStringList lines = QString::fromUtf8(content).split('\n', Qt::KeepEmptyParts);
    QStringList errors;
    if (!validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(this, tr("Invalid requirements.txt"), tr("Fetched content failed validation:\n%1").arg(errors.join("\n")));
        return;
    }
    if (requirementsModel)
    {
        requirementsModel->clear();
        writeTableToModel(lines);
    }
    applySettingsFromUi();
    historyRecentWeb.removeAll(url);
    historyRecentWeb.prepend(url);
    if (maxHistoryItems != -1)
    {
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Fetched %1 requirements from URL: %2")
        .arg(requirementsModel->rowCount())
        .arg(url));
}

/****************************************************************
 * @brief Populates the local and web history tables in the
 *        History tab with the current history data from QSettings.
 ***************************************************************/
void MainWindow::refreshHistoryTables()
{
    QSettings s(kOrganizationName, kApplicationName);
    QStringList localList = s.value("history/recentLocal").toStringList();
    QStringList webList = s.value("history/recentWeb").toStringList();

    localHistoryModel->clear();
    localHistoryModel->setHorizontalHeaderLabels({tr("Recent Local Files")});
    for (const QString &path : std::as_const(localList))
    {
        QList<QStandardItem*> row;
        row << new QStandardItem(path);
        localHistoryModel->appendRow(row);
    }
    localHistoryTable->resizeColumnsToContents();

    webHistoryModel->clear();
    webHistoryModel->setHorizontalHeaderLabels({tr("Recent Web URLs")});
    for (const QString &url : std::as_const(webList))
    {
        QList<QStandardItem*> row;
        row << new QStandardItem(url);
        webHistoryModel->appendRow(row);
    }
    webHistoryTable->resizeColumnsToContents();
    updateLocalHistoryButtons();
    updateWebHistoryButtons();
}

/****************************************************************
 * @brief Refreshes recent file and URL menus safely.
 ***************************************************************/
void MainWindow::refreshRecentMenus()
{
    if (!recentLocalMenu || !recentWebMenu)
    {
        qWarning() << "refreshRecentMenus: menus not available, skipping";
        return;
    }
    recentLocalMenu->clear();
    recentWebMenu->clear();

    // Populate Recent Local
    for (int i = 0; i < historyRecentLocal.size(); ++i)
    {
        const QString &path = historyRecentLocal.at(i);
        QAction *act = recentLocalMenu->addAction(path);
        connect(act, &QAction::triggered, this, [this, path]()
        {
            loadRequirementsFromFile(path);
        });
    }
    if (!historyRecentLocal.isEmpty())
    {
        recentLocalMenu->addSeparator();
        QAction *clearLocal = recentLocalMenu->addAction(tr("Clear Local History"));
        connect(clearLocal, &QAction::triggered, this, [this]()
        {
            historyRecentLocal.clear();
            refreshRecentMenus();
            saveHistory();
        });
    }

    // Populate Recent Web
    for (int i = 0; i < historyRecentWeb.size(); ++i)
    {
        const QString &url = historyRecentWeb.at(i);
        QAction *act = recentWebMenu->addAction(url);
        connect(act, &QAction::triggered, this, [this, url]()
        {
            loadRequirementsFromUrl(url);
        });
    }
    if (!historyRecentWeb.isEmpty())
    {
        recentWebMenu->addSeparator();
        QAction *clearWeb = recentWebMenu->addAction(tr("Clear Web History"));
        connect(clearWeb, &QAction::triggered, this, [this]()
        {
            historyRecentWeb.clear();
            refreshRecentMenus();
            saveHistory();
        });
    }
}

/****************************************************************
 * @brief Clears both local and web recent history lists.
 ***************************************************************/
void MainWindow::clearAllHistory()
{
    historyRecentLocal.clear();
    historyRecentWeb.clear();
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Cleared all history"));
}

/****************************************************************
 * @brief Loads application settings from QSettings to UI.
 ***************************************************************/
void MainWindow::loadAppSettings()
{
    QSettings settings;
    maxHistoryItems = settings.value("app/maxItems", 10).toInt();
    validateAppSettings();
    updateUiFromSettings();
}

/****************************************************************
 * @brief Saves application settings from UI to QSettings.
 ***************************************************************/
void MainWindow::saveAppSettings()
{
    applySettingsFromUi();
    validateAppSettings();
    QSettings settings;
    settings.setValue("app/maxItems", maxHistoryItems);
    statusBar()->showMessage(tr("Settings saved"), 2000);
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
}

/****************************************************************
 * @brief Validates and clamps settings to safe ranges.
 ***************************************************************/
void MainWindow::validateAppSettings()
{
    if (maxHistoryItems == 0)
    {
        maxHistoryItems = 10;
    }
    else if (maxHistoryItems < -1)
    {
        maxHistoryItems = 1;
    }
}

/****************************************************************
 * @brief Applies settings from UI widgets to member state.
 ***************************************************************/
void MainWindow::applySettingsFromUi()
{
    maxHistoryItems = ui->spinMaxItems->value();
}

/****************************************************************
 * @brief Updates UI widgets to reflect current settings.
 ***************************************************************/
void MainWindow::updateUiFromSettings()
{
    ui->spinMaxItems->setMinimum(-1);
    ui->spinMaxItems->setMaximum(std::numeric_limits<int>::max());
    ui->spinMaxItems->setToolTip(tr("-1 = unlimited, 0 not allowed, ≥1 valid"));
    ui->spinMaxItems->setValue(maxHistoryItems);
}

/****************************************************************
 * @brief Writes requirements into a one-column model.
 ***************************************************************/
void MainWindow::writeTableToModel(const QStringList &lines)
{
    if (!requirementsModel || !requirementsView) { return; }
    requirementsModel->clear();
    requirementsModel->setColumnCount(1);
    requirementsModel->setHorizontalHeaderLabels({tr("requirements.txt")});
    requirementsView->resizeRowsToContents();

    for (const QString &line : lines)
    {
        const QString trimmed = line.trimmed();
        if (trimmed.isEmpty())
        {
            continue;
        }
        auto *item = new QStandardItem(trimmed);
        item->setEditable(false);
        requirementsModel->appendRow(item);
    }
    requirementsView->resizeColumnsToContents();
    requirementsView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
    requirementsView->horizontalHeader()->setSectionResizeMode(QHeaderView::Interactive);
    requirementsView->resizeColumnsToContents();
    requirementsView->resizeRowsToContents();

    // Get the actual width of requirementsView and add 66px
    int reqWidth = requirementsView->verticalHeader()->width();
    for (int col = 0; col < requirementsModel->columnCount(); ++col)
    {
        reqWidth += requirementsView->columnWidth(col);
    }
    reqWidth += 66;

    // Set the splitter sizes
    QSplitter *splitter = qobject_cast<QSplitter*>(requirementsView->parentWidget());
    if (splitter)
    {
        QList<int> sizes;
        sizes << reqWidth << qMax(100, splitter->width() - reqWidth);
        splitter->setSizes(sizes);
    }
    refreshHistoryTables();
}

/****************************************************************
 * @brief Appends a line to the log view with timestamp.
 * @param line The message line to append.
 ***************************************************************/
void MainWindow::appendLog(const QString &line)
{
    QString time = QDateTime::currentDateTime().toString("HH:mm:ss");
    logView->appendPlainText(QString("[%1] %2").arg(time, line));
}

/****************************************************************
 * @brief Updates progress bar percent.
 * @param percent The progress value (0-100).
 ***************************************************************/
void MainWindow::updateProgress(int percent)
{
    progress->setValue(percent);
}

/****************************************************************
 * @brief Shows compiled result message path.
 * @param path The compiled output path.
 ***************************************************************/
void MainWindow::showCompiledResult(const QString &path)
{
    appendLog(tr("Successfully compiled: %1").arg(path));
    statusBar()->showMessage(tr("Compiled successfully"));
}

/****************************************************************
 * @brief Shows About dialog using current appVersion.
 ***************************************************************/
void MainWindow::showAboutBox()
{
    QMessageBox::about(this,
        tr("About Pip Matrix Resolver"),
        tr("<b>Pip Matrix Resolver</b><br>"
           "Cross-platform Qt tool to resolve "
           "Python dependency matrices.<br>"
           "Version %1").arg(appVersion)
        );
}

/****************************************************************
 * @brief Shows README dialog from resources.
 ***************************************************************/
void MainWindow::showReadmeDialog()
{
    QFile file(":/docs/README.md");
    QString markdown;
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        markdown = QString::fromUtf8(file.readAll());
    }
    else
    {
        markdown = tr("README.md not found in resources.");
    }

    QDialog dialog(this);
    dialog.setWindowTitle(tr("README"));
    dialog.resize(700, 500);

    QVBoxLayout layout(&dialog);
    QTextBrowser viewer(&dialog);
    viewer.setMarkdown(markdown);
    viewer.setOpenExternalLinks(true);

    QPushButton closeButton(tr("Close"), &dialog);
    layout.addWidget(&viewer);
    layout.addWidget(&closeButton);

    connect(&closeButton, &QPushButton::clicked, &dialog, &QDialog::accept);

    dialog.exec();
}

/****************************************************************
 * @brief Loads persistent history from QSettings.
 ***************************************************************/
void MainWindow::loadHistory()
{
    QSettings s(kOrganizationName, kApplicationName);
    historyRecentLocal = s.value("history/recentLocal").toStringList();
    historyRecentWeb = s.value("history/recentWeb").toStringList();

    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
}

/****************************************************************
 * @brief Saves persistent history to QSettings.
 ***************************************************************/
void MainWindow::saveHistory()
{
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("history/recentLocal", historyRecentLocal);
    s.setValue("history/recentWeb", historyRecentWeb);
}

/****************************************************************
 * @brief Normalizes a raw URL string.
 ***************************************************************/
QString MainWindow::normalizeRawUrl(const QString &inputUrl)
{
    QString url = inputUrl.trimmed();
    if (!url.startsWith("http://") && !url.startsWith("https://"))
    {
        url.prepend("https://");
    }
    return url;
}

/****************************************************************
 * @brief Reads all lines from a text file.
 ***************************************************************/
QStringList MainWindow::readTextFileLines(const QString &path)
{
    QStringList lines;
    QFile file(path);
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        while (!file.atEnd())
        {
            lines << QString::fromUtf8(file.readLine()).trimmed();
        }
        file.close();
    }
    return lines;
}

/****************************************************************
 * @brief Validates requirements.txt lines.
 ***************************************************************/
bool MainWindow::validateRequirementsWithErrors(const QStringList &lines, QStringList &errors)
{
    errors.clear();
    bool valid = true;
    for (const QString &line : lines)
    {
        if (line.isEmpty())
        {
            continue;
        }
        // Example validation: must not start with a dash or space
        if (line.startsWith('-') || line.startsWith(' '))
        {
            errors << tr("Invalid line: %1").arg(line);
            valid = false;
        }
        // Add more validation rules as needed
    }
    return valid;
}

/****************************************************************
 * @brief Downloads text from a URL.
 ***************************************************************/
bool MainWindow::downloadText(const QString &url, QByteArray &out)
{
    QNetworkAccessManager manager;
    QNetworkRequest request{QUrl(url)};
    QNetworkReply *reply = manager.get(request);
    QEventLoop loop;
    connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
    loop.exec();
    if (reply->error() != QNetworkReply::NoError)
    {
        reply->deleteLater();
        return false;
    }
    out = reply->readAll();
    reply->deleteLater();
    return true;
}

/****************************************************************
 * @brief Returns the logs directory path.
 ***************************************************************/
QString MainWindow::logsDir()
{
    QString dir = QDir::homePath() + "/PipMatrixResolverLogs";
    QDir().mkpath(dir);
    return dir;
}

/****************************************************************
 * @brief Starts matrix resolution (stub).
 ***************************************************************/
void MainWindow::startResolve()
{
    appendLog(tr("Starting matrix resolution..."));
    // Add your matrix resolution logic here
}

/****************************************************************
 * @brief Pauses matrix resolution (stub).
 ***************************************************************/
void MainWindow::pauseResolve()
{
    appendLog(tr("Pausing..."));
    // Add your pause logic here
}

/****************************************************************
 * @brief Resumes matrix resolution (stub).
 ***************************************************************/
void MainWindow::resumeResolve()
{
    appendLog(tr("Resuming..."));
    // Add your resume logic here
}

/****************************************************************
 * @brief Stops matrix resolution (stub).
 ***************************************************************/
void MainWindow::stopResolve()
{
    appendLog(tr("Stopping..."));
    // Add your stop logic here
}

/****************************************************************
 * @brief Adds a new entry to the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localAddButton_clicked()
{
    bool ok;
    QString path = QInputDialog::getText(this, tr("Add Local File"), tr("File path:"), QLineEdit::Normal, "", &ok);
    if (ok && !path.isEmpty())
    {
        QSettings s(kOrganizationName, kApplicationName);
        QStringList list = s.value("history/recentLocal").toStringList();
        list.prepend(path);
        s.setValue("history/recentLocal", list);
        refreshHistoryTables();
    }
}

/****************************************************************
 * @brief Edits the selected entry in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localEditButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    QString oldValue = list.at(idx.row());
    bool ok;
    QString newValue = QInputDialog::getText(this, tr("Edit Local File"), tr("File path:"), QLineEdit::Normal, oldValue, &ok);
    if (!ok) return; // User cancelled, do nothing
    if (newValue.isEmpty()) return; // Optionally, do nothing if empty
    list[idx.row()] = newValue;
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Deletes the selected entry from the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localDeleteButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    list.removeAt(idx.row());
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Moves the selected entry up in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localUpButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid() || idx.row() == 0) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    list.swapItemsAt(idx.row(), idx.row() - 1);
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
    localHistoryTable->selectRow(idx.row() - 1);
}

/****************************************************************
 * @brief Moves the selected entry down in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localDownButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    if (!idx.isValid() || idx.row() >= list.size() - 1) return;
    list.swapItemsAt(idx.row(), idx.row() + 1);
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
    localHistoryTable->selectRow(idx.row() + 1);
}

/****************************************************************
 * @brief Adds a new entry to the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webAddButton_clicked()
{
    bool ok;
    QString url = QInputDialog::getText(this, tr("Add Web URL"), tr("URL:"), QLineEdit::Normal, "", &ok);
    if (ok && !url.isEmpty())
    {
        QSettings s(kOrganizationName, kApplicationName);
        QStringList list = s.value("history/recentWeb").toStringList();
        list.prepend(url);
        s.setValue("history/recentWeb", list);
        refreshHistoryTables();
    }
}

/****************************************************************
 * @brief Edits the selected entry in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webEditButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    QString oldValue = list.at(idx.row());
    bool ok;
    QString newValue = QInputDialog::getText(this, tr("Edit Web URL"), tr("URL:"), QLineEdit::Normal, oldValue, &ok);
    if (!ok) return; // User cancelled, do nothing
    if (newValue.isEmpty()) return; // Optionally, do nothing if empty
    list[idx.row()] = newValue;
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
}
/****************************************************************
 * @brief Deletes the selected entry from the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webDeleteButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    list.removeAt(idx.row());
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Moves the selected entry up in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webUpButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid() || idx.row() == 0) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    list.swapItemsAt(idx.row(), idx.row() - 1);
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
    webHistoryTable->selectRow(idx.row() - 1);
}

/****************************************************************
 * @brief Moves the selected entry down in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webDownButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    if (!idx.isValid() || idx.row() >= list.size() - 1) return;
    list.swapItemsAt(idx.row(), idx.row() + 1);
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
    webHistoryTable->selectRow(idx.row() + 1);
}

/****************************************************************
 * @brief Enables/disables local history buttons based on selection and table size.
 ***************************************************************/
void MainWindow::updateLocalHistoryButtons()
{
    QItemSelectionModel *sel = localHistoryTable->selectionModel();
    int rowCount = localHistoryModel->rowCount();
    bool hasSelection = sel->hasSelection();

    ui->localEditButton->setEnabled(hasSelection);
    ui->localDeleteButton->setEnabled(hasSelection);

    // Up: enabled if selected and not first row, and more than 1 item
    bool canUp = hasSelection && rowCount > 1;
    if (canUp)
    {
        QModelIndex idx = sel->currentIndex();
        canUp = idx.isValid() && idx.row() > 0;
    }
    ui->localUpButton->setEnabled(canUp);

    // Down: enabled if selected and not last row, and more than 1 item
    bool canDown = hasSelection && rowCount > 1;
    if (canDown)
    {
        QModelIndex idx = sel->currentIndex();
        canDown = idx.isValid() && idx.row() < rowCount - 1;
    }
    ui->localDownButton->setEnabled(canDown);
}

/****************************************************************
 * @brief Enables/disables web history buttons based on selection and table size.
 ***************************************************************/
void MainWindow::updateWebHistoryButtons()
{
    QItemSelectionModel *sel = webHistoryTable->selectionModel();
    int rowCount = webHistoryModel->rowCount();
    bool hasSelection = sel->hasSelection();

    ui->webEditButton->setEnabled(hasSelection);
    ui->webDeleteButton->setEnabled(hasSelection);

    // Up: enabled if selected and not first row, and more than 1 item
    bool canUp = hasSelection && rowCount > 1;
    if (canUp)
    {
        QModelIndex idx = sel->currentIndex();
        canUp = idx.isValid() && idx.row() > 0;
    }
    ui->webUpButton->setEnabled(canUp);

    // Down: enabled if selected and not last row, and more than 1 item
    bool canDown = hasSelection && rowCount > 1;
    if (canDown)
    {
        QModelIndex idx = sel->currentIndex();
        canDown = idx.isValid() && idx.row() < rowCount - 1;
    }
    ui->webDownButton->setEnabled(canDown);
}

/****************************************************************
 * @brief save Settings.
 ***************************************************************/
void MainWindow::saveSettings()
{
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("settings/pythonVersion", ui->pythonVersionEdit->text());
    s.setValue("settings/pipVersion", ui->pipVersionEdit->text());
    s.setValue("settings/pipToolsVersion", ui->pipToolsVersionEdit->text());
    s.setValue("settings/maxItems", ui->spinMaxItems->value());
    s.setValue("settings/useCpu", useCpuCheckBox->isChecked());
    s.setValue("settings/cuda", cudaCheckBox->isChecked());
}

/****************************************************************
 * @brief check And Restore Settings.
 ***************************************************************/
void MainWindow::checkAndRestoreSettings()
{
    QSettings s(kOrganizationName, kApplicationName);

    // Python version
    QString pythonVersion = s.value("settings/pythonVersion", DEFAULT_PYTHON_VERSION).toString();
    if (pythonVersion.isEmpty())
    {
        pythonVersion = DEFAULT_PYTHON_VERSION;
        s.setValue("settings/pythonVersion", pythonVersion);
    }
    ui->pythonVersionEdit->setText(pythonVersion);

    // pip version
    QString pipVersion = s.value("settings/pipVersion", DEFAULT_PIP_VERSION).toString();
    if (pipVersion.isEmpty())
    {
        pipVersion = DEFAULT_PIP_VERSION;
        s.setValue("settings/pipVersion", pipVersion);
    }
    ui->pipVersionEdit->setText(pipVersion);

    // pip-tools version
    QString pipToolsVersion = s.value("settings/pipToolsVersion", DEFAULT_PIPTOOLS_VERSION).toString();
    if (pipToolsVersion.isEmpty())
    {
        pipToolsVersion = DEFAULT_PIPTOOLS_VERSION;
        s.setValue("settings/pipToolsVersion", pipToolsVersion);
    }
    ui->pipToolsVersionEdit->setText(pipToolsVersion);

    // Max items
    int maxItems = s.value("settings/maxItems", DEFAULT_MAX_ITEMS).toInt();
    if (maxItems == 0)
    {
        maxItems = DEFAULT_MAX_ITEMS;
        s.setValue("settings/maxItems", maxItems);
    }
    ui->spinMaxItems->setValue(maxItems);
}

/****************************************************************
 * @brief Restores CPU and Cuda settings from QSettings to UI.
 ***************************************************************/
void MainWindow::restoreCpuCudaSettings()
{
    QSettings s(kOrganizationName, kApplicationName);
    ui->useCpuCheckBox->setChecked(s.value("settings/useCpu", false).toBool());
    ui->cudaCheckBox->setChecked(s.value("settings/cuda", true).toBool());
}

/****************************************************************
 * @brief Detect OS System.
 ***************************************************************/
void MainWindow::detectSystem()
{
    // GPU detection (simple: check for NVIDIA)
    bool gpuDetected = false;
    QString os, release, version;
#if defined(Q_OS_WIN)
    os = "Windows";
    release = QSysInfo::productType();
    version = QSysInfo::productVersion();
#elif defined(Q_OS_MAC)
    os = "Mac";
    release = QSysInfo::productType();
    version = QSysInfo::productVersion();
#elif defined(Q_OS_LINUX)
    os = "Linux";
    QFile f("/etc/os-release");
    if (f.open(QIODevice::ReadOnly | QIODevice::Text)) {
        while (!f.atEnd()) {
            QString line = f.readLine();
            if (line.startsWith("ID=")) release = line.mid(3).trimmed().replace("\"", "");
            if (line.startsWith("VERSION_ID=")) version = line.mid(11).trimmed().replace("\"", "");
        }
    }
#endif
    osEdit->setText(os);
    osReleaseEdit->setText(release);
    osVersionEdit->setText(version);

#if defined(Q_OS_WIN)
    QProcess proc;
    proc.start("wmic path win32_VideoController get name");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive)) gpuDetected = true;
#elif defined(Q_OS_LINUX)
    QProcess proc;
    proc.start("lspci");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive)) gpuDetected = true;
#elif defined(Q_OS_MAC)
    QProcess proc;
    proc.start("system_profiler SPDisplaysDataType");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive)) gpuDetected = true;
#endif
    if (!gpuDetected)
    {
        gpuDetected = detectNvidiaGpu();
        ui->gpuDetectedCheckBox->setChecked(gpuDetected);
    }
    // Save to QSettings
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("settings/os", os);
    s.setValue("settings/osRelease", release);
    s.setValue("settings/osVersion", version);
    s.setValue("settings/gpuDetected", gpuDetected);
    if (gpuDetected)
    {
        ui->statusbar->showMessage(tr("GPU Detected"));
    }
    else
    {
        ui->statusbar->showMessage(tr("GPU Not Detected"));
    }
}

/****************************************************************
 * @brief on Create Venv.
 ***************************************************************/
void MainWindow::onCreateVenv()
{
    // Check if python, pip, or pip-tools settings have changed
    // If so, rebuild venv_running
    // (You can compare current settings to those saved in QSettings)

    // Call your bash script using QProcess
    QProcess proc;
    QString script = "/path/to/pip-matrix-common.sh";
    QStringList args;
    args << "--create-venv-running"; // You can define this flag in your script
    proc.start(script, args);
    proc.waitForFinished(-1);
    QString output = proc.readAllStandardOutput();
    ui->statusbar->showMessage(tr("Switching to Terminal tab. Created/Updated venv_running: %1").arg(output));
    ui->mainTabs->setCurrentWidget(ui->tabTerminal);
}

/****************************************************************
 * @brief Sets up venv_running and venv_testing paths and saves to QSettings.
 ***************************************************************/
void MainWindow::setupVenvPaths()
{
    QSettings s(kOrganizationName, kApplicationName);
    QString projectRoot = QDir::currentPath();
    QString venvRunning = projectRoot + "/.venvs/venv_running";
    QString venvTesting = projectRoot + "/.venvs/venv_testing";
    s.setValue("venv/venv_running", venvRunning);
    s.setValue("venv/venv_testing", venvTesting);
}

/****************************************************************
 * @brief detect Gpu Via PowerShell.
 ***************************************************************/
bool MainWindow::detectGpuViaPowerShell()
{
    QProcess proc;
    proc.start("powershell", QStringList() << "-Command" << "Get-WmiObject Win32_VideoController | Select-Object -ExpandProperty Name");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    // Debug: print output if needed
    // QMessageBox::information(nullptr, "PowerShell GPU Output", output);
    return output.contains("NVIDIA", Qt::CaseInsensitive);
}

/****************************************************************
 * @brief detect Gpu Via DxDiag.
 ***************************************************************/
bool MainWindow::detectGpuViaDxDiag()
{
    QProcess proc;
    proc.start("cmd", QStringList() << "/c" << "dxdiag /t dxdiag.txt");
    proc.waitForFinished();
    QFile file("dxdiag.txt");
    bool found = false;
    if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QString dxdiagOutput = file.readAll();
        found = dxdiagOutput.contains("NVIDIA", Qt::CaseInsensitive);
        file.remove(); // Clean up
    }
    // Debug: print output if needed
    // QMessageBox::information(nullptr, "dxdiag GPU Output", dxdiagOutput);
    return found;
}

/****************************************************************
 * @brief detect Gpu Via Nvidia Smi.
 ***************************************************************/
bool MainWindow::detectGpuViaNvidiaSmi()
{
    QProcess proc;
    proc.start("nvidia-smi");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    // Debug: print output if needed
    // QMessageBox::information(nullptr, "nvidia-smi Output", output);
    return output.contains("NVIDIA", Qt::CaseInsensitive);
}

/****************************************************************
 * @brief detect Nvidia Gpu.
 ***************************************************************/
bool MainWindow::detectNvidiaGpu()
{
    // Primary test: PowerShell WMI
    if (detectGpuViaPowerShell()) return true;
    // Fallback 1: dxdiag
    if (detectGpuViaDxDiag()) return true;
    // Fallback 2: nvidia-smi
    if (detectGpuViaNvidiaSmi()) return true;
    // Not detected
    return false;
}

/****************************************************************
 * @brief on Run Command.
 ***************************************************************/
void MainWindow::onRunCommand()
{
    QString command = ui->commandInput->text().trimmed();
    if (command.isEmpty())
    {
        ui->terminalOutput->appendPlainText("No command entered.");
        return;
    }

    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif

    QStringList args;
    bool usedVenv = false;

    if (command.startsWith("pip "))
    {
        args << "-m" << "pip";
        args << command.mid(4).split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    }
    else if (command.startsWith("pip-compile"))
    {
        args << "-m" << "piptools" << "compile";
        QString rest = command.mid(QString("pip-compile").length()).trimmed();
        if (!rest.isEmpty()) args << rest.split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    }
    else if (command.startsWith("pip-sync"))
    {
        args << "-m" << "piptools" << "sync";
        QString rest = command.mid(QString("pip-sync").length()).trimmed();
        if (!rest.isEmpty()) args << rest.split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    }
    else if (command.startsWith("python "))
    {
        args = command.mid(7).split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    }
    else
    {
#if defined(Q_OS_WIN)
        process.start("cmd.exe", QStringList() << "/C" << command);
#else
        process.start("bash", QStringList() << "-c" << command);
#endif
    }

    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();

    if (usedVenv)
        ui->terminalOutput->appendPlainText("[venv] " + command);

    if (!output.isEmpty())
        ui->terminalOutput->appendPlainText(output);
    if (!error.isEmpty())
        ui->terminalOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief on Clear Terminal.
 ***************************************************************/
void MainWindow::onClearTerminal()
{
    ui->terminalOutput->clear();
}

/****************************************************************
 * @brief on Search Package.
 ***************************************************************/
void MainWindow::onSearchPackage()
{
    QString pkg = ui->packageNameInput->text().trimmed();
    if (pkg.isEmpty()) {
        ui->packageOutput->appendPlainText("Enter a package name to search.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "search", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        ui->packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        ui->packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief on Install Package.
 ***************************************************************/
void MainWindow::onInstallPackage()
{
    QString pkg = ui->packageNameInput->text().trimmed();
    if (pkg.isEmpty()) {
        ui->packageOutput->appendPlainText("Enter a package name to install.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "install", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        ui->packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        ui->packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief on Uninstall Package.
 ***************************************************************/
void MainWindow::onUninstallPackage()
{
    QString pkg = ui->packageNameInput->text().trimmed();
    if (pkg.isEmpty()) {
        ui->packageOutput->appendPlainText("Enter a package name to uninstall.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "uninstall", "-y", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        ui->packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        ui->packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief .
 ***************************************************************/
void MainWindow::refreshInstalledPackages()
{
    ui->installedPackagesList->clear();
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "list", "--format=freeze"};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QStringList lines = output.split('\n', Qt::SkipEmptyParts);
    for (int i = 0; i < lines.size(); ++i)
    {
        ui->installedPackagesList->addItem(lines.at(i));
    }
}

/****************************************************************
 * @brief .
 ***************************************************************/
void MainWindow::onInstalledPackagesListDoubleClicked(const QModelIndex &index)
{
    QString pkg = ui->installedPackagesList->item(index.row())->text().split('=')[0];
    ui->packageNameInput->setText(pkg);
    onUninstallPackage();
}

/****************************************************************
 * @brief Example function to run a Python script.
 * runPythonScript("C:/path/to/MuseTalk/main.py");
 ***************************************************************/
void runPythonScript(const QString &scriptPath)
{
    QProcess process;
    QString pythonExe = "python"; // or full path to python.exe in your venv
    QStringList arguments;
    arguments << scriptPath;

    process.start(pythonExe, arguments);
    process.waitForFinished();

    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();

    qDebug() << "Output:" << output;
    qDebug() << "Error:" << error;
}
/****************************************************************
 * @brief .
 ***************************************************************/

/****************************************************************
 * @brief .
 ***************************************************************/

/****************************************************************
 * @brief .
 ***************************************************************/

/************** End of MainWindow.cpp **************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.h
 * @brief Declares the main application window class.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.6
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Main window interface for PipMatrixResolver Qt application.
 * Includes settings API, history, menus, and shared loaders for
 * files and URLs. Uses C-style braces.
 ***************************************************************/

#pragma once
#include <QMainWindow>
#include <QStringList>
#include <QTimer>
#include <QStandardItemModel>
#include <QTableView>
#include <QPlainTextEdit>
#include <QProgressBar>
#include <QMenu>
#include <QAction>
#include <QDialogButtonBox>
#include <QPushButton>
#include <QFile>
#include <QDir>
#include <QFileInfo>
#include <QByteArray>
#include <QDialog>
#include <QTextBrowser>
#include <QVBoxLayout>
#include <QInputDialog>
#include <QMessageBox>
#include <QSettings>
#include <QDateTime>
#include <QDebug>

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE

/****************************************************************
 * @class MainWindow
 * @brief Implements the main application window.
 ***************************************************************/
class MainWindow : public QMainWindow
{
    Q_OBJECT
public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

    // QSettings
    static const QString kOrganizationName;
    static const QString kApplicationName;
    // Globals
    static QString appVersion;

private slots:
    void openLocalRequirements();
    void fetchRequirementsFromUrl();
    void refreshRecentMenus();
    void clearAllHistory();
    void loadAppSettings();
    void saveAppSettings();
    void validateAppSettings();
    void applySettingsFromUi();
    void updateUiFromSettings();
    void startResolve();
    void pauseResolve();
    void resumeResolve();
    void stopResolve();
    void appendLog(const QString &line);
    void updateProgress(int percent);
    void showCompiledResult(const QString &path);
    void showAboutBox();
    void showReadmeDialog();
    void exitApp();
    void writeTableToModel(const QStringList &lines);
    // Local history slots
    void on_localAddButton_clicked();
    void on_localEditButton_clicked();
    void on_localDeleteButton_clicked();
    void on_localUpButton_clicked();
    void on_localDownButton_clicked();

    // Web history slots
    void on_webAddButton_clicked();
    void on_webEditButton_clicked();
    void on_webDeleteButton_clicked();
    void on_webUpButton_clicked();
    void on_webDownButton_clicked();

    void updateLocalHistoryButtons();
    void updateWebHistoryButtons();
    // Slot for menu action
    void onCreateVenv();

    void onRunCommand();
    void onClearTerminal();

    // Package Manager tab
    void onSearchPackage();
    void onInstallPackage();
    void onUninstallPackage();

    void refreshInstalledPackages();
    void onInstalledPackagesListDoubleClicked(const QModelIndex &index);


private:
    void loadRequirementsFromFile(const QString &path);
    void loadRequirementsFromUrl(const QString &url);
    void saveHistory();
    void loadHistory();
    /****************************************************************
     * @brief Populates the local and web history tables in the
     *        History tab with the current history data.
     ***************************************************************/
    void refreshHistoryTables();
    /****************************************************************
    * @brief Checks all settings in the Settings tab at startup,
    *        restores defaults if missing, and updates the UI.
    ***************************************************************/
    void checkAndRestoreSettings();

    bool detectGpuViaPowerShell();
    bool detectNvidiaGpu();
    bool detectGpuViaNvidiaSmi();
    bool detectGpuViaDxDiag();
    /****************************************************************
    * @brief Saves all settings from the Settings tab to QSettings.
    ***************************************************************/
    void saveSettings();
    // Startup/system functions
    void detectSystem();
    void restoreCpuCudaSettings();
    void setupVenvPaths();

    // Utility functions moved from MatrixUtility
    QStringList readTextFileLines(const QString &path);
    bool validateRequirementsWithErrors(const QStringList &lines, QStringList &errors);
    QString normalizeRawUrl(const QString &inputUrl);
    bool downloadText(const QString &url, QByteArray &out);
    QString logsDir();

    // History data
    QStringList historyRecentLocal;
    QStringList historyRecentWeb;

    // UI pointers
    Ui::MainWindow *ui;
    QStandardItemModel *requirementsModel;
    QTableView *requirementsView;
    QPlainTextEdit *logView;
    QTableView *localHistoryTable;
    QTableView *webHistoryTable;
    QStandardItemModel *localHistoryModel;
    QStandardItemModel *webHistoryModel;
    QProgressBar *progress;
    QMenu *recentLocalMenu;
    QMenu *recentWebMenu;

    // Settings tab widgets
    QCheckBox *gpuDetectedCheckBox;
    QCheckBox *useCpuCheckBox;
    QCheckBox *cudaCheckBox;
    QLineEdit *osEdit;
    QLineEdit *osReleaseEdit;
    QLineEdit *osVersionEdit;

    // Venv paths
    QString venvRunningPath;
    QString venvTestingPath;

    // Settings
    int maxHistoryItems; // -1=unlimited, 0 invalid, ≥1 valid
};

/************** End of MainWindow.h **************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.ui
#-------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>900</width>
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Pip Matrix Resolver</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <widget class="QTabWidget" name="mainTabs">
      <property name="currentIndex">
       <number>3</number>
      </property>
      <widget class="QWidget" name="tabMain">
       <attribute name="title">
        <string>Main</string>
       </attribute>
       <layout class="QVBoxLayout" name="mainLayout">
        <item>
         <widget class="QSplitter" name="splitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QTableView" name="requirementsView"/>
          <widget class="QTableView" name="matrixView"/>
         </widget>
        </item>
        <item>
         <widget class="QSplitter" name="bottomSplitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QPlainTextEdit" name="logView">
           <property name="readOnly">
            <bool>true</bool>
           </property>
          </widget>
          <widget class="QProgressBar" name="progressBar"/>
         </widget>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabHistory">
       <attribute name="title">
        <string>History</string>
       </attribute>
       <layout class="QVBoxLayout" name="historyLayout">
        <item>
         <widget class="QTableView" name="localHistoryTable"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="localHistoryButtonBar">
          <item>
           <widget class="QPushButton" name="localAddButton">
            <property name="text">
             <string>Add</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localEditButton">
            <property name="text">
             <string>Edit</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localDeleteButton">
            <property name="text">
             <string>Delete</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localUpButton">
            <property name="text">
             <string>Up</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localDownButton">
            <property name="text">
             <string>Down</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QTableView" name="webHistoryTable"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="webHistoryButtonBar">
          <item>
           <widget class="QPushButton" name="webAddButton">
            <property name="text">
             <string>Add</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webEditButton">
            <property name="text">
             <string>Edit</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webDeleteButton">
            <property name="text">
             <string>Delete</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webUpButton">
            <property name="text">
             <string>Up</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webDownButton">
            <property name="text">
             <string>Down</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabTerminal">
       <attribute name="title">
        <string>Terminal</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_terminal">
        <item>
         <widget class="QPlainTextEdit" name="terminalOutput"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_terminal">
          <item>
           <widget class="QLineEdit" name="commandInput"/>
          </item>
          <item>
           <widget class="QPushButton" name="runCommandBtn">
            <property name="text">
             <string>Run Command</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="clearTerminalBtn">
            <property name="text">
             <string>Clear</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabPackageManager">
       <attribute name="title">
        <string>Package Manager</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_packageManager">
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_packageManager">
          <item>
           <widget class="QLineEdit" name="packageNameInput"/>
          </item>
          <item>
           <widget class="QPushButton" name="searchPackageBtn">
            <property name="text">
             <string>Search</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="installPackageBtn">
            <property name="text">
             <string>Install</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="uninstallPackageBtn">
            <property name="text">
             <string>Uninstall</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QListWidget" name="installedPackagesList"/>
        </item>
        <item>
         <widget class="QPlainTextEdit" name="packageOutput"/>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabSettings">
       <attribute name="title">
        <string>Settings</string>
       </attribute>
       <layout class="QVBoxLayout" name="settingsLayout">
        <item>
         <layout class="QFormLayout" name="formLayout">
          <item row="0" column="0">
           <widget class="QLabel" name="labelPythonVersion">
            <property name="text">
             <string>Python version:</string>
            </property>
           </widget>
          </item>
          <item row="0" column="1">
           <widget class="QLineEdit" name="pythonVersionEdit"/>
          </item>
          <item row="1" column="0">
           <widget class="QLabel" name="labelPipVersion">
            <property name="text">
             <string>pip version:</string>
            </property>
           </widget>
          </item>
          <item row="1" column="1">
           <widget class="QLineEdit" name="pipVersionEdit"/>
          </item>
          <item row="2" column="0">
           <widget class="QLabel" name="labelPipToolsVersion">
            <property name="text">
             <string>pip-tools version:</string>
            </property>
           </widget>
          </item>
          <item row="2" column="1">
           <widget class="QLineEdit" name="pipToolsVersionEdit"/>
          </item>
          <item row="3" column="0">
           <widget class="QLabel" name="labelMaxItems">
            <property name="text">
             <string>Maximum number of items:</string>
            </property>
           </widget>
          </item>
          <item row="3" column="1">
           <layout class="QHBoxLayout" name="spinMaxItemsLayout">
            <item>
             <widget class="QSpinBox" name="spinMaxItems">
              <property name="toolTip">
               <string>-1 = unlimited, 0 not allowed, ≥1 valid</string>
              </property>
              <property name="minimum">
               <number>-1</number>
              </property>
              <property name="maximum">
               <number>2147483647</number>
              </property>
              <property name="value">
               <number>10</number>
              </property>
             </widget>
            </item>
            <item>
             <spacer name="spinMaxItemsSpacer">
              <property name="orientation">
               <enum>Qt::Orientation::Horizontal</enum>
              </property>
              <property name="sizeType">
               <enum>QSizePolicy::Policy::Expanding</enum>
              </property>
              <property name="sizeHint" stdset="0">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
             </spacer>
            </item>
           </layout>
          </item>
          <item row="4" column="0">
           <widget class="QLabel" name="labelGpuDetected">
            <property name="text">
             <string>GPU Detected:</string>
            </property>
           </widget>
          </item>
          <item row="4" column="1">
           <widget class="QCheckBox" name="gpuDetectedCheckBox">
            <property name="enabled">
             <bool>false</bool>
            </property>
           </widget>
          </item>
          <item row="5" column="0">
           <widget class="QLabel" name="labelUseCpu">
            <property name="text">
             <string>Use CPU:</string>
            </property>
           </widget>
          </item>
          <item row="5" column="1">
           <widget class="QCheckBox" name="useCpuCheckBox"/>
          </item>
          <item row="6" column="0">
           <widget class="QLabel" name="labelCuda">
            <property name="text">
             <string>Cuda:</string>
            </property>
           </widget>
          </item>
          <item row="6" column="1">
           <widget class="QCheckBox" name="cudaCheckBox"/>
          </item>
          <item row="7" column="0">
           <widget class="QLabel" name="labelOs">
            <property name="text">
             <string>OS:</string>
            </property>
           </widget>
          </item>
          <item row="7" column="1">
           <widget class="QLineEdit" name="osEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="8" column="0">
           <widget class="QLabel" name="labelOsRelease">
            <property name="text">
             <string>Release:</string>
            </property>
           </widget>
          </item>
          <item row="8" column="1">
           <widget class="QLineEdit" name="osReleaseEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="9" column="0">
           <widget class="QLabel" name="labelOsVersion">
            <property name="text">
             <string>Version:</string>
            </property>
           </widget>
          </item>
          <item row="9" column="1">
           <widget class="QLineEdit" name="osVersionEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QPushButton" name="saveSettingsButton">
          <property name="text">
           <string>Save Settings</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="restoreDefaultsButton">
          <property name="text">
           <string>Restore Defaults</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QDialogButtonBox" name="buttonBoxPreferences">
          <property name="standardButtons">
           <set>QDialogButtonBox::StandardButton::Apply|QDialogButtonBox::StandardButton::Cancel|QDialogButtonBox::StandardButton::Ok</set>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>900</width>
     <height>20</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>&amp;File</string>
    </property>
    <addaction name="actionOpenRequirements"/>
    <addaction name="actionFetchRequirements"/>
    <addaction name="separator"/>
    <addaction name="actionExit"/>
   </widget>
   <widget class="QMenu" name="menuTools">
    <property name="title">
     <string>&amp;Tools</string>
    </property>
    <addaction name="actionCreateVenv"/>
    <addaction name="actionResolveMatrix"/>
    <addaction name="actionPause"/>
    <addaction name="actionResume"/>
    <addaction name="actionStop"/>
   </widget>
   <widget class="QMenu" name="menuBatch">
    <property name="title">
     <string>&amp;Batch</string>
    </property>
    <addaction name="actionRunBatch"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>&amp;Help</string>
    </property>
    <addaction name="actionAbout"/>
    <addaction name="actionViewReadme"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuTools"/>
   <addaction name="menuBatch"/>
   <addaction name="menuHelp"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="mainToolBar">
   <property name="windowTitle">
    <string>Main Toolbar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="actionOpenRequirements"/>
   <addaction name="actionFetchRequirements"/>
   <addaction name="actionCreateVenv"/>
   <addaction name="actionResolveMatrix"/>
   <addaction name="actionPause"/>
   <addaction name="actionResume"/>
   <addaction name="actionStop"/>
   <addaction name="actionRunBatch"/>
   <addaction name="actionAbout"/>
   <addaction name="actionViewReadme"/>
  </widget>
  <action name="actionOpenRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/open.svg</normaloff>:/icons/icons/open.svg</iconset>
   </property>
   <property name="text">
    <string>Open requirements file...</string>
   </property>
  </action>
  <action name="actionFetchRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/url.svg</normaloff>:/icons/icons/url.svg</iconset>
   </property>
   <property name="text">
    <string>Fetch requirements from URL...</string>
   </property>
  </action>
  <action name="actionExit">
   <property name="text">
    <string>Exit</string>
   </property>
  </action>
  <action name="actionCreateVenv">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/venv.svg</normaloff>:/icons/icons/venv.svg</iconset>
   </property>
   <property name="text">
    <string>Create/Update venv</string>
   </property>
  </action>
  <action name="actionResolveMatrix">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resolve.svg</normaloff>:/icons/icons/resolve.svg</iconset>
   </property>
   <property name="text">
    <string>Resolve matrix</string>
   </property>
  </action>
  <action name="actionPause">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/pause.svg</normaloff>:/icons/icons/pause.svg</iconset>
   </property>
   <property name="text">
    <string>Pause</string>
   </property>
  </action>
  <action name="actionResume">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resume.svg</normaloff>:/icons/icons/resume.svg</iconset>
   </property>
   <property name="text">
    <string>Resume</string>
   </property>
  </action>
  <action name="actionStop">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/stop.svg</normaloff>:/icons/icons/stop.svg</iconset>
   </property>
   <property name="text">
    <string>Stop</string>
   </property>
  </action>
  <action name="actionRunBatch">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/batch.svg</normaloff>:/icons/icons/batch.svg</iconset>
   </property>
   <property name="text">
    <string>Run batch</string>
   </property>
  </action>
  <action name="actionAbout">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/info.svg</normaloff>:/icons/icons/info.svg</iconset>
   </property>
   <property name="text">
    <string>About</string>
   </property>
  </action>
  <action name="actionViewReadme">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/readme.svg</normaloff>:/icons/icons/readme.svg</iconset>
   </property>
   <property name="text">
    <string>View README</string>
   </property>
  </action>
  <action name="separator">
   <property name="separator" stdset="0">
    <bool>true</bool>
   </property>
  </action>
 </widget>
 <resources>
  <include location="../PipMatrixResolverQt.qrc"/>
 </resources>
 <connections/>
</ui>

#-------------------------------------------------------------------------------
# File: src/main.cpp
#-------------------------------------------------------------------------------
#include <QApplication>
#include <QTranslator>
#include <QLocale>
#include <QFile>
#include <QDebug>
#include <QIcon>
#include "MainWindow.h"

int main(int argc, char *argv[])
{
    // Set app version before MainWindow is constructed
    MainWindow::appVersion = "0.1.3"; // or any version you wan

    QCoreApplication::setOrganizationName(MainWindow::kOrganizationName);
    QCoreApplication::setApplicationName(MainWindow::kApplicationName);

    QApplication theApplication(argc, argv);

    // Register compiled resources
    Q_INIT_RESOURCE(PipMatrixResolverQt);

    // Enable icons in menus globally
    theApplication.setAttribute(Qt::AA_DontShowIconsInMenus, false);

    // Set application icon
    QApplication::setWindowIcon(QIcon(":/icons/icons/app.svg"));

    // Diagnostics
    qDebug() << "[RESOURCE CHECK] :/icons/icons/open.svg exists:" << QFile::exists(":/icons/icons/open.svg");

    // Translation loading
    const QString languageCode = QLocale::system().name().split('_').first();
    auto loadTranslator = [&](const QString &baseName) -> bool
    {
        QTranslator *tr = new QTranslator(&theApplication);
        const QString qmFile = QString(":/translations/%1_%2.qm").arg(baseName, languageCode);
        if (tr->load(qmFile))
        {
            theApplication.installTranslator(tr);
            qDebug() << "Loaded translation:" << qmFile;
            return true;
        }
        delete tr;
        return false;
    };

    loadTranslator("PipMatrixResolverQt");
    loadTranslator("MatrixUtility");
    loadTranslator("MatrixHistory");

    MainWindow w;
    w.show();
    return theApplication.exec();
}

#-------------------------------------------------------------------------------
# File: tests/gtest_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity)
{
    ResolverEngine engine;
    // Replace with a real method from your class
    EXPECT_TRUE(engine.isValid());
}

#-------------------------------------------------------------------------------
# File: tests/qt_test_main.cpp
#-------------------------------------------------------------------------------
#include <QTest>
#include "test_mainwindow.h"

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    int status = 0;
    status |= QTest::qExec(new TestMainWindow, argc, argv);
    return status;
}

#-------------------------------------------------------------------------------
# File: tests/qtest_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject {
    Q_OBJECT

private slots:
    void initTestCase() {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

QTEST_MAIN(TestMainWindow)
#include "qtest_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_main.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>

int main(int argc, char **argv) 
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

#-------------------------------------------------------------------------------
# File: tests/test_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase() 
    {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

#include "test_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity) 
{
    ResolverEngine engine;
    EXPECT_TRUE(engine.isValid());
}

# Directory Structure
#-------------------------------------------------------------------------------
├── .qtcreator
│   ├── qtc-cmake-presets-vRRckuMy
│   └── CMakeLists.txt.user
├── icons
│   ├── app.svg
│   ├── batch.svg
│   ├── cancel.svg
│   ├── info.svg
│   ├── open.svg
│   ├── pause.svg
│   ├── readme.svg
│   ├── resolve.svg
│   ├── resume.svg
│   ├── stop.svg
│   ├── url.svg
│   └── venv.svg
├── src
│   ├── CommandsTab.cpp
│   ├── CommandsTab.h
│   ├── MainWindow.cpp
│   ├── MainWindow.h
│   ├── MainWindow.ui
│   └── main.cpp
├── tests
│   ├── gtest_resolver.cpp
│   ├── qt_test_main.cpp
│   ├── qtest_mainwindow.cpp
│   ├── test_main.cpp
│   ├── test_mainwindow.cpp
│   └── test_resolver.cpp
├── translations
│   ├── MatrixHistory_en.qm
│   ├── MatrixHistory_en.ts
│   ├── MatrixHistory_es.qm
│   ├── MatrixHistory_es.ts
│   ├── MatrixUtility_en.qm
│   ├── MatrixUtility_en.ts
│   ├── MatrixUtility_es.qm
│   ├── MatrixUtility_es.ts
│   ├── PipMatrixResolverQt_en.qm
│   ├── PipMatrixResolverQt_en.ts
│   ├── PipMatrixResolverQt_es.qm
│   └── PipMatrixResolverQt_es.ts
├── .gitignore
├── CMakeLists.txt
├── Installation.txt
├── LICENSE
├── PipMatrixResolverQt.qrc
├── README.md
├── cleanbash.sh
├── requirements.txt
├── src2txt.bat
└── src2txt.sh

#*** End of file PipMatrixResolver ***
