#===============================================================================
# Project: PipMatrixResolver
# Generated on: 2025-11-06 21:50:47
# OS: WSL on Ubuntu: 24.04
# This file is used to show full source code, cmake, read me, and file locates.
#================================C

#-------------------------------------------------------------------------------
# File: CMakeLists.txt
#-------------------------------------------------------------------------------
cmake_minimum_required(VERSION 3.24)
project(PipMatrixResolverQt VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

find_package(Qt6 6.10 REQUIRED COMPONENTS Core Gui Widgets LinguistTools Network Concurrent Svg)

qt_standard_project_setup()

# Translations
set(TS_FILES
    translations/PipMatrixResolverQt_en.ts
    translations/PipMatrixResolverQt_es.ts
)
qt_add_translation(QM_FILES ${TS_FILES})

# Resources (icons + translations)
qt_add_resources(APP_RESOURCES PipMatrixResolverQt.qrc)

# Executable
qt_add_executable(PipMatrixResolverQt
    src/main.cpp
    src/MainWindow.h src/MainWindow.cpp
    src/CommandsTab.h src/CommandsTab.cpp
    src/TerminalEngine.h src/TerminalEngine.cpp
    ${APP_RESOURCES}
    ${QM_FILES}
    src/Settings.h src/Settings.cpp
    src/Constants.h
    src/Config.h
)

target_link_libraries(PipMatrixResolverQt PRIVATE
    Qt6::Core
    Qt6::Gui
    Qt6::Widgets
    Qt6::Network
    Qt6::Concurrent
    Qt6::Svg
)
target_include_directories(PipMatrixResolverQt PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Install the executable
install(TARGETS PipMatrixResolverQt DESTINATION bin)

# Install Python scripts and requirements files
install(FILES
    src/venv_manager.py
    src/requirements.in
    src/requirements.txt
    DESTINATION share/pipmatrixresolverqt/python
)

# Optionally, show a message after install
install(CODE "message(\"\nPython scripts installed to: \${CMAKE_INSTALL_PREFIX}/share/pipmatrixresolverqt/python\nPlease ensure you have Python 3 and pip installed on your system.\")")

# Deployment logic
if(WIN32)
    find_program(WINDEPLOYQT_EXECUTABLE NAMES windeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(WINDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${WINDEPLOYQT_EXECUTABLE} --verbose 0 --no-compiler-runtime "$<TARGET_FILE:PipMatrixResolverQt>"
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (Windows)"
        )
    endif()
elseif(APPLE)
    find_program(MACDEPLOYQT_EXECUTABLE NAMES macdeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(MACDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${MACDEPLOYQT_EXECUTABLE} "$<TARGET_BUNDLE_DIR:PipMatrixResolverQt>" -verbose=1
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (macOS)"
        )
    endif()
elseif(UNIX)
    message(STATUS "âœ… Linux build â€“ Qt runtime deployment handled by system packages.")
endif()

# Packaging with CPack (Qt Installer, NSIS, DEB/RPM)
include(InstallRequiredSystemLibraries)
set(CPACK_PACKAGE_NAME "PipMatrixResolverQt")
set(CPACK_PACKAGE_VENDOR "AM-Tower")
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Python venv and pip-tools GUI manager")
set(CPACK_PACKAGE_VERSION_MAJOR "0")
set(CPACK_PACKAGE_VERSION_MINOR "1")
set(CPACK_PACKAGE_VERSION_PATCH "0")
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")
set(CPACK_RESOURCE_FILE_README "${CMAKE_CURRENT_SOURCE_DIR}/README.md")
set(CPACK_PACKAGE_EXECUTABLES "PipMatrixResolverQt" "PipMatrixResolverQt")

if(WIN32)
    set(CPACK_GENERATOR "NSIS")
    set(CPACK_NSIS_DISPLAY_NAME "PipMatrixResolverQt")
    set(CPACK_NSIS_PACKAGE_NAME "PipMatrixResolverQt")
    set(CPACK_NSIS_CONTACT "Occupant.AM.Tower@gmail.com")
elseif(APPLE)
    set(CPACK_GENERATOR "DragNDrop")
else()
    set(CPACK_GENERATOR "DEB;RPM")
    set(CPACK_DEBIAN_PACKAGE_MAINTAINER "Jeffrey Scott Flesher")
endif()

include(CPack)

#-------------------------------------------------------------------------------
# File: PipMatrixResolverQt.qrc
#-------------------------------------------------------------------------------
<RCC>
    <!-- Icons -->
    <qresource prefix="/icons">
        <file>icons/app.svg</file>
        <file>icons/open.svg</file>
        <file>icons/url.svg</file>
        <file>icons/venv.svg</file>
        <file>icons/resolve.svg</file>
        <file>icons/pause.svg</file>
        <file>icons/resume.svg</file>
        <file>icons/stop.svg</file>
        <file>icons/batch.svg</file>
        <file>icons/info.svg</file>
        <file>icons/readme.svg</file>
    </qresource>

    <!-- Translations -->
    <qresource prefix="/translations">
        <file>translations/PipMatrixResolverQt_en.qm</file>
        <file>translations/PipMatrixResolverQt_es.qm</file>
    </qresource>

    <!-- Docs -->
    <qresource prefix="/docs">
        <file>README.md</file>
    </qresource>

</RCC>
#-------------------------------------------------------------------------------
# File: README.md
#-------------------------------------------------------------------------------
# Pip-Matrix-Resolver
This is a Qt C++ GUI,
that allows you to open requirements.txt
and create a working Python environment terminal.
* It has tabs to show the function it provides.
* It has a Python Terminal to run commands and applications.
* You can create batch files to process Python calls.

A cross-platform Qt C++ GUI for resolving Python requirements.txt matrixes/matrices
to build a Python environment to run Python applications.
and managing virtual environments, 
for running batch commands.

## Use-Case
The best use case for this application,
is when you find it hard to install the Python application.
You get stuck in Dependency Hell.
Every computer OS, release, and verion, can have a different environment.
This application will read a requirements.txt locally, 
or over the web, normally from a GitHub repository.
I assignes a matrix for all packages and their versions.
You can adjust from the base, how much range you want to give it.
By default it has 3 versions, but you can change the levels.

The matrix will read the file requirements.sh, 
and will update the matrix resolver values that resolve. 
It will use the operator == to pin exact version.


The time to run the test will vary, but here is the math.
If you have 18 packages, each with 3 possible versions, 
that gives you 18 independent variables with 3 options each. 
The total number of possible combinations is 
318=387,420,4893^18 = 387,420,489. 
If each test takes 5 seconds, 
running all combinations would require about 1.9 billion seconds, 
or roughly 61.4 years of nonstop testingâ€”assuming no parallelism, 
no caching, and no skipped failures. 
Clearly, exhaustive testing is impractical. 
To optimize, we can use tools like pipâ€‘tools to resolve dependencies up front, 
prune invalid combinations, and lock down a consistent set of requirements, 
dramatically reducing the number of cases we actually need to test.

The reason I wrote this application:

I wrote this to use SadTalker and MuseTalk.
The are Pyton applications that take an image and wav file as arguments.
I will animate the face in the image, to lip sync the wav file.
This is called a talking heads video.
It will allow me to install it and keep it updated on GitHub.
I can create a batch file to process images and wav files into videos.

## Status:
* Not working.
* Open requirements.txt in Local and Web modes works.
* Terminal is in work.
* Just starting this project, and it will take time to get to a working version.

#### Features
* Resolve Python dependency matrices with pip-tools
* Manage virtual environments (create, upgrade pip and pip-tools)
* Batch convert audio + image to MP4 with ffmpeg
* Qt GUI with menus, log view, progress bar
* Translation support (English and Spanish)

## Build Instructions
Use Qt build or:
```
cmake -S . -B build
cmake --build build
```
### Create the installer/package:
* cpack

On Windows, windeployqt is run automatically after build.

## Qt Project Structure
```
/
â”œâ”€â”€ ðŸ“‚ build
â”œâ”€â”€ ðŸ“‚ icons
â”‚   â”œâ”€â”€ ðŸ“„ app.svg
â”‚   â”œâ”€â”€ ðŸ“„ batch.svg
â”‚   â”œâ”€â”€ ðŸ“„ cancel.svg
â”‚   â”œâ”€â”€ ðŸ“„ info.svg
â”‚   â”œâ”€â”€ ðŸ“„ open.svg
â”‚   â”œâ”€â”€ ðŸ“„ pause.svg
â”‚   â”œâ”€â”€ ðŸ“„ readme.svg
â”‚   â”œâ”€â”€ ðŸ“„ resolve.svg
â”‚   â”œâ”€â”€ ðŸ“„ resume.svg
â”‚   â”œâ”€â”€ ðŸ“„ stop.svg
â”‚   â”œâ”€â”€ ðŸ“„ url.svg
â”‚   â””â”€â”€ ðŸ“„ venv.svg
â”œâ”€â”€ ðŸ“‚ src
â”‚   â”œâ”€â”€ ðŸ“„ MainWindow.cpp
â”‚   â”œâ”€â”€ ðŸ“„ MainWindow.h
â”‚   â”œâ”€â”€ ðŸ“„ CommandsTab.cpp
â”‚   â”œâ”€â”€ ðŸ“„ CommandsTab.h
â”‚   â””â”€â”€ ðŸ“„ main.cpp
â”œâ”€â”€ ðŸ“‚ tests
â”‚   â”œâ”€â”€ ðŸ“„ gtest_resolver.cpp
â”‚   â”œâ”€â”€ ðŸ“„ qt_test_main.cpp
â”‚   â”œâ”€â”€ ðŸ“„ qtest_mainwindow.cpp
â”‚   â”œâ”€â”€ ðŸ“„ test_main.cpp
â”‚   â”œâ”€â”€ ðŸ“„ test_mainwindow.cpp
â”‚   â””â”€â”€ ðŸ“„ test_resolver.cpp
â”œâ”€â”€ ðŸ“‚ translations
â”‚   â”œâ”€â”€ ðŸ“„ PipMatrixResolverQt_en.qm
â”‚   â”œâ”€â”€ ðŸ“„ PipMatrixResolverQt_en.ts
â”‚   â”œâ”€â”€ ðŸ“„ PipMatrixResolverQt_es.qm
â”‚   â””â”€â”€ ðŸ“„ PipMatrixResolverQt_es.ts
â”œâ”€â”€ ðŸ“„ .gitignore
â”œâ”€â”€ ðŸ“„ CMakeLists.txt
â”œâ”€â”€ ðŸ“„ LICENSE
â”œâ”€â”€ ðŸ“„ PipMatrixResolverQt.qrc
â”œâ”€â”€ ðŸ“„ README.md
â”œâ”€â”€ ðŸ“„ cleanbash.sh
â”œâ”€â”€ ðŸ“„ requirements.txt
â”œâ”€â”€ ðŸ“„ src2txt.bat
â””â”€â”€ ðŸ“„ src2txt.sh
```
## File Descriptions

#### Root
* CMakeLists.txt â€“ Build script: compiles sources, generates qm from ts, bundles resources
* PipMatrixResolverQt.qrc â€“ Qt resource file embedding icons and compiled translations


#### resources/icons
* SVG icons used in menus and toolbars


#### src
* main.cpp â€“ Application entry point. Sets up QApplication, loads translations, shows MainWindow
* MainWindow.h/.cpp â€“ Main GUI window. Defines menus, log view, progress bar, and user actions.
* CommandsTab.h/cpp -

#### translations
* PipMatrixResolverQt_en.ts â€“ English translation source
* PipMatrixResolverQt_es.ts â€“ Spanish translation source
* Both are compiled into qm at build time and embedded

#### Usage

* File â†’ Open requirements file â€“ Load a local requirements.txt
* Tools â†’ Create/Update venv â€“ Create or update a Python virtual environment
* Tools â†’ Resolve matrix â€“ Start iterative resolution of package versions
* Batch â†’ Run batch conversion to mp4 â€“ Combine audio and image into MP4
* Help â†’ About â€“ Show app info

## Terminal Tab â€” What You Can Do
* Run Python scripts:
    * python myscript.py

* Install a package:
    * pip install package_name

* Uninstall a package:
    * pip uninstall package_name

* List installed packages:
    * pip list

* Show package details:
    * pip show package_name

* Upgrade a package:
    * pip install --upgrade package_name

* Run pip-tools commands:
    * pip-compile requirements.in
    * pip-sync

* Check Python version:
    * python --version

* Check pip version:
    * pip --version

* Run any shell command:
    * On Windows: dir
    * On Linux/macOS: ls

* View contents of a file:
    * On Windows: type filename.txt
    * On Linux/macOS: cat filename.txt

* Check environment variables:
    * On Windows: set
    * On Linux/macOS: env

* Run batch or shell scripts:
    * bash script.sh (Linux/macOS)
    * script.bat (Windows)

* Deactivate the virtual environment (if you started a shell session manually):
    * deactivate

## License:
* Unlicensed, MIT or your chosen license

## End of Readme

#-------------------------------------------------------------------------------
# File: src/CommandsTab.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file CommandsTab.cpp
 * @brief Implements the CommandsTab class for dynamic command UI,
 *        batch execution, project editing, and JSON persistence.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.7
 * @date    2025-11-03
 * @section License MIT
 * @section DESCRIPTION
 * This file contains the implementation of CommandsTab widget.
 ***************************************************************/
#include "CommandsTab.h"
#include <QFileInfo>
#include <QMessageBox>
#include <QInputDialog>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QDialogButtonBox>
#include <QScrollArea>
#include <QTextStream>

/****************************************************************
 * @brief Constructor: Builds the UI and loads initial state.
 ***************************************************************/
CommandsTab::CommandsTab(TerminalEngine* engine, QWidget* parent)
    : QWidget(parent), engine(engine)
{
    buildUI();
    loadProjects("projects.json");
}
/****************************************************************
 * @brief Builds the static UI components.
 ***************************************************************/
void CommandsTab::buildUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);

    // Project selector and management buttons
    QHBoxLayout *projLayout = new QHBoxLayout;
    projectDropdown = new QComboBox;
    connect(projectDropdown, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &CommandsTab::onProjectChanged);

    addProjectButton = new QPushButton("Add");
    editProjectButton = new QPushButton("Edit");
    deleteProjectButton = new QPushButton("Delete");

    connect(addProjectButton, &QPushButton::clicked, this, &CommandsTab::onAddProject);
    connect(editProjectButton, &QPushButton::clicked, this, &CommandsTab::onEditProject);
    connect(deleteProjectButton, &QPushButton::clicked, this, &CommandsTab::onDeleteProject);

    projLayout->addWidget(new QLabel("Project:"));
    projLayout->addWidget(projectDropdown);
    projLayout->addWidget(addProjectButton);
    projLayout->addWidget(editProjectButton);
    projLayout->addWidget(deleteProjectButton);
    mainLayout->addLayout(projLayout);

    // Dynamic inputs area
    inputsLayout = new QVBoxLayout;
    mainLayout->addLayout(inputsLayout);

    // Extra arguments
    extraArgsEdit = new QLineEdit;
    connect(extraArgsEdit, &QLineEdit::textChanged, this, &CommandsTab::updatePreview);
    mainLayout->addWidget(new QLabel("Extra Arguments:"));
    mainLayout->addWidget(extraArgsEdit);

    // Command preview + clear button
    QHBoxLayout *previewLayout = new QHBoxLayout;
    commandPreview = new QLineEdit;
    commandPreview->setReadOnly(true);
    clearButton = new QToolButton;
    clearButton->setText("X");
    connect(clearButton, &QToolButton::clicked, this, &CommandsTab::onClearCommand);
    previewLayout->addWidget(commandPreview);
    previewLayout->addWidget(clearButton);
    mainLayout->addLayout(previewLayout);

    // Batch file selector
    QHBoxLayout *batchLayout = new QHBoxLayout;
    batchFileEdit = new QLineEdit;
    batchFileEdit->setPlaceholderText("Batch file (one path per line)");
    QPushButton *browseBatchBtn = new QPushButton("Browse");
    connect(browseBatchBtn, &QPushButton::clicked, this, &CommandsTab::onBrowseBatchFile);
    batchLayout->addWidget(batchFileEdit);
    batchLayout->addWidget(browseBatchBtn);
    mainLayout->addLayout(batchLayout);

    // Output console
    outputConsole = new QTextEdit;
    outputConsole->setReadOnly(true);
    mainLayout->addWidget(new QLabel("Command Output:"));
    mainLayout->addWidget(outputConsole);

    // Run buttons
    QHBoxLayout *runLayout = new QHBoxLayout;
    runButton = new QPushButton("Run Command");
    runBatchButton = new QPushButton("Run Batch");
    connect(runButton, &QPushButton::clicked, this, &CommandsTab::onRunCommand);
    connect(runBatchButton, &QPushButton::clicked, this, &CommandsTab::onRunBatch);
    runLayout->addWidget(runButton);
    runLayout->addWidget(runBatchButton);
    mainLayout->addLayout(runLayout);
}

/****************************************************************
 * @brief Loads projects from a JSON file.
 ***************************************************************/
bool CommandsTab::loadProjects(const QString &jsonPath)
{
    QFile file(jsonPath);
    if (!file.open(QIODevice::ReadOnly))
    {
        return false;
    }

    QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
    QJsonArray projArray = doc["projects"].toArray();

    projects.clear();
    projectDropdown->clear();

    for (int i = 0; i < projArray.size(); ++i)
    {
        QJsonObject obj = projArray.at(i).toObject();
        ProjectDef proj;
        proj.name = obj["name"].toString();
        proj.scriptPath = obj["script"].toString();
        proj.extraArgs = obj["extra_args"].toString();

        QJsonArray inputsArr = obj["inputs"].toArray();
        for (int j = 0; j < inputsArr.size(); ++j)
        {
            QJsonObject inObj = inputsArr.at(j).toObject();
            proj.inputs.append({inObj["label"].toString(), inObj["switch"].toString()});
        }

        projects.append(proj);
        projectDropdown->addItem(proj.name);
    }
    if (!projects.isEmpty())
    {
        onProjectChanged(0);
    }
    return true;
}

/****************************************************************
 * @brief Saves projects to a JSON file.
 ***************************************************************/
bool CommandsTab::saveProjects(const QString &jsonPath)
{
    QJsonArray arr;
    for (int i = 0; i < projects.size(); ++i)
    {
        const ProjectDef &proj = projects.at(i);
        QJsonObject obj;
        obj["name"] = proj.name;
        obj["script"] = proj.scriptPath;
        obj["extra_args"] = proj.extraArgs;
        QJsonArray inputsArr;
        for (int j = 0; j < proj.inputs.size(); ++j)
        {
            const InputDef &input = proj.inputs.at(j);
            QJsonObject inObj;
            inObj["label"] = input.label;
            inObj["switch"] = input.switchName;
            inputsArr.append(inObj);
        }
        obj["inputs"] = inputsArr;
        arr.append(obj);
    }
    QJsonObject root;
    root["projects"] = arr;
    QFile file(jsonPath);
    if (!file.open(QIODevice::WriteOnly))
    {
        return false;
    }
    file.write(QJsonDocument(root).toJson());
    return true;
}

/****************************************************************
 * @brief Handles project selection change.
 ***************************************************************/
void CommandsTab::onProjectChanged(int index)
{
    if (index < 0 || index >= projects.size())
    {
        return;
    }
    rebuildInputs(projects.at(index));
    extraArgsEdit->setText(projects.at(index).extraArgs);
    updatePreview();
}

/****************************************************************
 * @brief Rebuilds input fields dynamically.
 ***************************************************************/
void CommandsTab::rebuildInputs(const ProjectDef &proj)
{
    QLayoutItem *child;
    while ((child = inputsLayout->takeAt(0)) != nullptr)
    {
        delete child->widget();
        delete child;
    }
    inputEdits.clear();

    for (int i = 0; i < proj.inputs.size(); ++i)
    {
        const InputDef &input = proj.inputs.at(i);
        auto lbl = new QLabel(input.label);
        auto edit = new QLineEdit;
        connect(edit, &QLineEdit::textChanged, this, &CommandsTab::updatePreview);
        inputsLayout->addWidget(lbl);
        inputsLayout->addWidget(edit);
        inputEdits.append(edit);
    }
}

QString CommandsTab::buildCommand() const
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
        return QString();

    const ProjectDef& proj = projects.at(index);

    // Use engineâ€™s resolved interpreter
    QString pythonExe = engine->pythonCommand();
    QStringList args;

    args << QString("\"%1\"").arg(proj.scriptPath);

    for (int i = 0; i < inputEdits.size(); ++i)
    {
        QString val = inputEdits.at(i)->text().trimmed();
        if (!val.isEmpty())
        {
            args << proj.inputs.at(i).switchName << QString("\"%1\"").arg(val);
        }
    }

    if (!extraArgsEdit->text().isEmpty())
    {
        args << extraArgsEdit->text();
    }

    return QString("%1 %2").arg(pythonExe, args.join(' '));
}

/****************************************************************
 * @brief Validates script and input files exist.
 ***************************************************************/
bool CommandsTab::validateFiles(QString &errorMsg) const
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        errorMsg = "Invalid project selected.";
        return false;
    }

    QFileInfo scriptInfo(projects.at(index).scriptPath);
    if (!scriptInfo.exists())
    {
        errorMsg = "Script file does not exist.";
        return false;
    }

    for (int i = 0; i < inputEdits.size(); ++i)
    {
        if (!inputEdits.at(i)->text().isEmpty())
        {
            QFileInfo fi(inputEdits.at(i)->text());
            if (!fi.exists())
            {
                errorMsg = QString("Input file missing: %1").arg(inputEdits.at(i)->text());
                return false;
            }
        }
    }
    return true;
}

/****************************************************************
 * @brief Updates the command preview.
 ***************************************************************/
void CommandsTab::updatePreview()
{
    commandPreview->setText(buildCommand());
}

/****************************************************************
 * @brief Runs the command using QProcess.
 ***************************************************************/
void CommandsTab::onRunCommand()
{
    QString errorMsg;
    if (!validateFiles(errorMsg))
    {
        QMessageBox::critical(this, "Validation Error", errorMsg);
        return;
    }

    QString cmd = buildCommand();
    outputConsole->append(QString("Running: %1").arg(cmd));
    executeCommand(cmd);
}

/****************************************************************
 * @brief Runs batch commands sequentially from a file.
 ***************************************************************/
void CommandsTab::onRunBatch()
{
    QString batchFile = batchFileEdit->text();
    QFile file(batchFile);
    if (!file.open(QIODevice::ReadOnly))
    {
        QMessageBox::critical(this, "Error", "Cannot open batch file.");
        return;
    }

    QTextStream in(&file);
    batchQueue.clear();

    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        QMessageBox::critical(this, "Error", "No project selected.");
        return;
    }
    const ProjectDef &proj = projects.at(index);

    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
        if (line.isEmpty()) continue;

        // Fill inputs from line
        QStringList batchInputs = line.split(' ', Qt::SkipEmptyParts);
        for (int i = 0; i < inputEdits.size(); ++i)
        {
            if (i < batchInputs.size())
                inputEdits.at(i)->setText(batchInputs.at(i));
            else
                inputEdits.at(i)->clear();
        }

        QString cmd = buildCommand();
        batchQueue.append(cmd);
    }

    outputConsole->append(QString("Queued %1 batch commands").arg(batchQueue.size()));
    runNextBatchCommand();
}

/****************************************************************
 * @brief Runs the next command in the batch queue.
 ***************************************************************/
void CommandsTab::runNextBatchCommand()
{
    if (batchQueue.isEmpty())
    {
        outputConsole->append("Batch execution finished.");
        return;
    }

    QString cmd = batchQueue.takeFirst();
    outputConsole->append(QString("Batch Running: %1").arg(cmd));

    // Use venv Python path from engine
    QString venvPython = engine->venvPythonPath(engine->venvPath);
    QStringList parts = QProcess::splitCommand(cmd);

    // Replace "python" with venv python
    if (!parts.isEmpty() && parts.first().toLower() == "python")
    {
        parts[0] = venvPython;
    }

    QString program = parts.takeFirst();

    batchProc = new QProcess(this);
    batchProc->setProcessChannelMode(QProcess::MergedChannels);

    connect(batchProc, &QProcess::readyReadStandardOutput, [this]()
            {
                outputConsole->append(batchProc->readAllStandardOutput());
            });
    connect(batchProc, &QProcess::readyReadStandardError, [this]()
            {
                outputConsole->append(batchProc->readAllStandardError());
            });
    connect(batchProc, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            [this](int exitCode, QProcess::ExitStatus status)
            {
                outputConsole->append(QString("Process finished with code %1, status %2")
                                          .arg(exitCode).arg(status));
                batchProc->deleteLater();
                batchProc = nullptr;
                runNextBatchCommand(); // run next queued command
            });

    batchProc->start(program, parts);
}

/****************************************************************
 * @brief Executes a command using QProcess with program + args.
 ***************************************************************/
void CommandsTab::executeCommand(const QString &cmd)
{
    // Split program and args safely
    QStringList parts = QProcess::splitCommand(cmd);
    if (parts.isEmpty())
    {
        outputConsole->append("Invalid command string");
        return;
    }

    QString program = parts.takeFirst();
    QProcess *proc = new QProcess(this);
    proc->setProcessChannelMode(QProcess::MergedChannels);

    connect(proc, &QProcess::readyReadStandardOutput, [this, proc]()
            {
                outputConsole->append(proc->readAllStandardOutput());
            });
    connect(proc, &QProcess::readyReadStandardError, [this, proc]()
            {
                outputConsole->append(proc->readAllStandardError());
            });
    connect(proc, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            [this, proc](int exitCode, QProcess::ExitStatus status)
            {
                outputConsole->append(QString("Process finished with code %1, status %2")
                                          .arg(exitCode).arg(status));
            });

    proc->start(program, parts);
}

/****************************************************************
 * @brief Clears the command preview.
 ***************************************************************/
void CommandsTab::onClearCommand()
{
    commandPreview->clear();
}

/****************************************************************
 * @brief Opens a file dialog to select batch file.
 ***************************************************************/
void CommandsTab::onBrowseBatchFile()
{
    QString fileName = QFileDialog::getOpenFileName(this, "Select Batch File", QString(), "Text Files (*.txt);;All Files (*)");
    if (!fileName.isEmpty())
    {
        batchFileEdit->setText(fileName);
    }
}

/****************************************************************
 * @brief Shows the project editor dialog for add/edit.
 ***************************************************************/
bool CommandsTab::showProjectDialog(ProjectDef &proj, bool isEdit)
{
    QDialog dialog(this);
    dialog.setWindowTitle(isEdit ? "Edit Project" : "Add Project");
    QFormLayout *form = new QFormLayout(&dialog);

    QLineEdit *nameEdit = new QLineEdit(proj.name, &dialog);
    QLineEdit *scriptEdit = new QLineEdit(proj.scriptPath, &dialog);
    QLineEdit *extraArgsEditDlg = new QLineEdit(proj.extraArgs, &dialog);
    QSpinBox *inputCountSpin = new QSpinBox(&dialog);
    inputCountSpin->setRange(1, 10);
    inputCountSpin->setValue(proj.inputs.isEmpty() ? 2 : proj.inputs.size());

    QVector<QLineEdit*> labelEdits;
    QVector<QLineEdit*> switchEdits;
    QVBoxLayout *inputsVBox = new QVBoxLayout;
    for (int i = 0; i < inputCountSpin->value(); ++i)
    {
        QHBoxLayout *row = new QHBoxLayout;
        QLineEdit *lblEdit = new QLineEdit(i < proj.inputs.size() ? proj.inputs.at(i).label : QString("input%1").arg(i+1), &dialog);
        QLineEdit *swEdit = new QLineEdit(i < proj.inputs.size() ? proj.inputs.at(i).switchName : "", &dialog);
        row->addWidget(new QLabel("Label:"));
        row->addWidget(lblEdit);
        row->addWidget(new QLabel("Switch:"));
        row->addWidget(swEdit);
        inputsVBox->addLayout(row);
        labelEdits.append(lblEdit);
        switchEdits.append(swEdit);
    }
    connect(inputCountSpin, QOverload<int>::of(&QSpinBox::valueChanged),
            [inputsVBox, &labelEdits, &switchEdits, &dialog](int count)
            {
                QLayoutItem *child;
                while ((child = inputsVBox->takeAt(0)) != nullptr)
                {
                    delete child->widget();
                    delete child;
                }
                labelEdits.clear();
                switchEdits.clear();
                for (int i = 0; i < count; ++i)
                {
                    QHBoxLayout *row = new QHBoxLayout;
                    QLineEdit *lblEdit = new QLineEdit(QString("input%1").arg(i+1), &dialog);
                    QLineEdit *swEdit = new QLineEdit("", &dialog);
                    row->addWidget(new QLabel("Label:"));
                    row->addWidget(lblEdit);
                    row->addWidget(new QLabel("Switch:"));
                    row->addWidget(swEdit);
                    inputsVBox->addLayout(row);
                    labelEdits.append(lblEdit);
                    switchEdits.append(swEdit);
                }
            }
            );

    form->addRow("Project Name:", nameEdit);
    form->addRow("Script Path:", scriptEdit);
    form->addRow("Extra Args:", extraArgsEditDlg);
    form->addRow("Number of Inputs:", inputCountSpin);
    form->addRow("Inputs:", inputsVBox);

    QDialogButtonBox *buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, &dialog);
    form->addRow(buttons);
    connect(buttons, &QDialogButtonBox::accepted, &dialog, &QDialog::accept);
    connect(buttons, &QDialogButtonBox::rejected, &dialog, &QDialog::reject);

    if (dialog.exec() == QDialog::Accepted)
    {
        proj.name = nameEdit->text();
        proj.scriptPath = scriptEdit->text();
        proj.extraArgs = extraArgsEditDlg->text();
        proj.inputs.clear();
        for (int i = 0; i < labelEdits.size(); ++i)
        {
            proj.inputs.append({labelEdits.at(i)->text(), switchEdits.at(i)->text()});
        }
        return true;
    }
    return false;
}

/****************************************************************
 * @brief Adds a new project.
 ***************************************************************/
void CommandsTab::onAddProject()
{
    ProjectDef proj;
    if (showProjectDialog(proj, false))
    {
        projects.append(proj);
        saveProjects("projects.json");
        refreshProjectDropdown();
        projectDropdown->setCurrentIndex(projects.size() - 1);
    }
}

/****************************************************************
 * @brief Edits the selected project.
 ***************************************************************/
void CommandsTab::onEditProject()
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        return;
    }

    ProjectDef proj = projects.at(index);
    if (showProjectDialog(proj, true))
    {
        projects[index] = proj;
        saveProjects("projects.json");
        refreshProjectDropdown();
        projectDropdown->setCurrentIndex(index);
    }
}

/****************************************************************
 * @brief Deletes the selected project.
 ***************************************************************/
void CommandsTab::onDeleteProject()
{
    int index = projectDropdown->currentIndex();
    if (index < 0 || index >= projects.size())
    {
        return;
    }
    if (QMessageBox::question(this, "Delete Project", "Are you sure you want to delete this project?") == QMessageBox::Yes)
    {
        projects.remove(index);
        saveProjects("projects.json");
        refreshProjectDropdown();
        if (!projects.isEmpty())
        {
            projectDropdown->setCurrentIndex(0);
        }
    }
}

/****************************************************************
 *es.
 ***************************************************************/
void CommandsTab::refreshProjectDropdown()
{
    projectDropdown->clear();
    for (int i = 0; i < projects.size(); ++i)
    {
        projectDropdown->addItem(projects.at(i).name);
    }
}
/************** End of CommandsTab.cpp **************************/

#-------------------------------------------------------------------------------
# File: src/CommandsTab.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file CommandsTab.h
 * @brief Declares the CommandsTab class for dynamic command UI,
 *        batch execution, project editing, and JSON persistence.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.7
 * @date    2025-11-03
 * @section License MIT
 * @section DESCRIPTION
 * This file defines the CommandsTab widget for PipMatrixResolverQt.
 * Features:
 *   - Dynamic UI from JSON schema
 *   - Batch command execution
 *   - Project add/edit/delete dialogs
 *   - JSON save/load
 *   - Real-time output streaming
 *   - Doxygen headers and C-style braces
 ***************************************************************/
#ifndef COMMANDSTAB_H
#define COMMANDSTAB_H

#include <QWidget>
#include <QComboBox>
#include <QLineEdit>
#include <QPushButton>
#include <QToolButton>
#include <QTextEdit>
#include <QVBoxLayout>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QFile>
#include <QProcess>
#include <QLabel>
#include <QVector>
#include <QDialog>
#include <QSpinBox>
#include <QFileDialog>
#include "TerminalEngine.h"

/****************************************************************
 * @struct InputDef
 * @brief Defines a single input argument for a command.
 ***************************************************************/
struct InputDef
{
    QString label;
    QString switchName;
};

/****************************************************************
 * @struct ProjectDef
 * @brief Defines a project with script, inputs, and extra args.
 ***************************************************************/
struct ProjectDef
{
    QString name;
    QString scriptPath;
    QVector<InputDef> inputs;
    QString extraArgs;
};

/****************************************************************
 * @class CommandsTab
 * @brief Implements the dynamic command management tab.
 ***************************************************************/
class CommandsTab : public QWidget
{
    Q_OBJECT

public:
    /************************************************************
     * @brief Constructor
     * @param engine Pointer to the TerminalEngine backend
     * @param parent Optional parent widget
     ************************************************************/
    explicit CommandsTab(TerminalEngine* engine, QWidget* parent = nullptr);
    bool loadProjects(const QString &jsonPath);
    bool saveProjects(const QString &jsonPath);

private slots:
    void onProjectChanged(int index);
    void onRunCommand();
    void onRunBatch();
    void onClearCommand();
    void onAddProject();
    void onEditProject();
    void onDeleteProject();
    void updatePreview();
    void onBrowseBatchFile();

private:
    void buildUI();
    void rebuildInputs(const ProjectDef &proj);
    QString buildCommand() const;
    bool validateFiles(QString &errorMsg) const;
    void executeCommand(const QString &cmd);

    // Project editor dialog helpers
    bool showProjectDialog(ProjectDef &proj, bool isEdit = false);
    void refreshProjectDropdown();
    void runNextBatchCommand();   ///< helper to run next queued command
    // Variables:
    QVector<ProjectDef> projects;
    QComboBox *projectDropdown;
    QVBoxLayout *inputsLayout;
    QVector<QLineEdit *> inputEdits;
    QLineEdit *extraArgsEdit;
    QLineEdit *commandPreview;
    QTextEdit *outputConsole;
    QLineEdit *batchFileEdit;
    QPushButton *runButton;
    QPushButton *runBatchButton;
    QPushButton *addProjectButton;
    QPushButton *editProjectButton;
    QPushButton *deleteProjectButton;
    QToolButton *clearButton;
    TerminalEngine* engine;

    QStringList batchQueue;       ///< queued batch commands
    QProcess* batchProc = nullptr; ///< active batch process

};

#endif // COMMANDSTAB_H
/************** End of CommandsTab.h ***************************/

#-------------------------------------------------------------------------------
# File: src/Config.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file Config.h
 * @brief Global configuration macros.
 ***************************************************************/
#pragma once

// Toggle debug output: set to 1 to enable, 0 to disable
// #define SHOW_DEBUG 1

#if SHOW_DEBUG
    #define DEBUG_MSG() qDebug()
#else
    #define DEBUG_MSG() if (true) {} else qDebug()
#endif
/************** End of Config.h **************************/

#-------------------------------------------------------------------------------
# File: src/Constants.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file Constants.h
 * @brief Centralized application constants (no hard-coded literals).
 *
 * @author Jeffrey Scott Flesher
 * @version 0.6 [Increment]
 * @date    2025-11-06 [Todays date]
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * This file declares project-wide constants for defaults and
 * platform-specific settings to ensure maintainability and
 * onboarding parity across Windows, Linux, and macOS.
 ***************************************************************/
#pragma once
#include <QString>

/****************************************************************
 * @brief Returns the platform-appropriate default Python command.
 * @return Default Python command name (e.g., "python" or "python3").
 ***************************************************************/
inline QString defaultPythonCommand()
{
#ifdef _WIN32
    return QStringLiteral("python");
#else
    return QStringLiteral("python3");
#endif
}

/****************************************************************
 * @brief Constant accessor for the default Python interpreter.
 * @return Default Python interpreter command.
 ***************************************************************/
inline QString DEFAULT_PYTHON_INTERPRETER()
{
    return defaultPythonCommand();
}

/************** End of Constants.h **************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.cpp
 * @brief Implements the main application window.
 *
 * @author Jeffrey Scott Flesher with Copilot
 * @version 0.7
 * @date    2025-11-03
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Implements the main window logic: settings, history, menus,
 * file and URL loaders, logging, and UI dialog wiring.
 * Now with dynamic UI setup instead of .ui file.
 ***************************************************************/

#include "MainWindow.h"
#include <QApplication>
#include <QDebug>
#include <QEventLoop>
#include <QFileDialog>
#include <QHeaderView>
#include <QLabel>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>
#include <QProcess>
#include <QSysInfo>
#include <QUrl>
#include <utility>
#include "Config.h"

#define SHOW_DEBUG 1

/****************************************************************
 * @brief Globals for MainWindow.
 ***************************************************************/
QString MainWindow::appVersion = "1.0"; // Change in main
const QString DEFAULT_PYTHON_VERSION = "3.10";
const QString DEFAULT_PIP_VERSION = "23.2";
const QString DEFAULT_PIPTOOLS_VERSION = "6.13";
const int DEFAULT_MAX_ITEMS = 10;
const QString DEFAULT_APP_VERSION = "1.0";
const QString MainWindow::kOrganizationName = "AM-Tower";
const QString MainWindow::kApplicationName = "PipMatrixResolver";

/****************************************************************
 * @brief Constructor for MainWindow.
 ***************************************************************/
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , requirementsModel(new QStandardItemModel(this))
    , localHistoryModel(new QStandardItemModel(this))
    , webHistoryModel(new QStandardItemModel(this))
    , maxHistoryItems(10)
    , terminalEngine(new TerminalEngine(this))
{
    setupUi();

    loadAppSettings();
    loadHistory();

    // Connect actions
    connect(actionOpenRequirements, &QAction::triggered, this, &MainWindow::openLocalRequirements);
    connect(actionFetchRequirements,
            &QAction::triggered,
            this,
            &MainWindow::fetchRequirementsFromUrl);
    connect(actionExit, &QAction::triggered, this, &MainWindow::exitApp);
    connect(actionAbout, &QAction::triggered, this, &MainWindow::showAboutBox);
    connect(actionViewReadme, &QAction::triggered, this, &MainWindow::showReadmeDialog);
    connect(actionCreateVenv, &QAction::triggered, this, &MainWindow::onCreateVenv);
    connect(actionResolveMatrix, &QAction::triggered, this, &MainWindow::startResolve);
    connect(actionPause, &QAction::triggered, this, &MainWindow::pauseResolve);
    connect(actionResume, &QAction::triggered, this, &MainWindow::resumeResolve);
    connect(actionStop, &QAction::triggered, this, &MainWindow::stopResolve);

    // Connect settings buttons
    if (buttonBoxPreferences)
    {
        connect(buttonBoxPreferences,
                &QDialogButtonBox::accepted,
                this,
                &MainWindow::saveAppSettings);
        QPushButton *applyBtn = buttonBoxPreferences->button(QDialogButtonBox::Apply);
        if (applyBtn)
        {
            connect(applyBtn, &QPushButton::clicked, this, &MainWindow::saveAppSettings);
        }
    }

    // Connect history table selection changes
    connect(localHistoryTable->selectionModel(),
            &QItemSelectionModel::selectionChanged,
            this,
            &MainWindow::updateLocalHistoryButtons);
    connect(webHistoryTable->selectionModel(),
            &QItemSelectionModel::selectionChanged,
            this,
            &MainWindow::updateWebHistoryButtons);

    // Connect Terminal tab
    connect(runCommandBtn, &QPushButton::clicked, this, &MainWindow::onRunCommand);
    connect(clearTerminalBtn, &QPushButton::clicked, this, &MainWindow::onClearTerminal);
    connect(stopCommandBtn, &QPushButton::clicked, this, &MainWindow::onStopCommand);
    connect(commandInput, &QLineEdit::returnPressed, this, &MainWindow::onRunCommand);

    // Connect Package Manager tab
    connect(searchPackageBtn, &QPushButton::clicked, this, &MainWindow::onSearchPackage);
    connect(installPackageBtn, &QPushButton::clicked, this, &MainWindow::onInstallPackage);
    connect(uninstallPackageBtn, &QPushButton::clicked, this, &MainWindow::onUninstallPackage);

    connect(mainTabs, &QTabWidget::currentChanged, this, [this](int index) {
        if (mainTabs->widget(index)->objectName() == "tabPackageManager")
        {
            refreshInstalledPackages();
        }
    });
    connect(installedPackagesList,
            &QListWidget::doubleClicked,
            this,
            &MainWindow::onInstalledPackagesListDoubleClicked);

    // Refresh tables on startup
    refreshRecentMenus();
    refreshHistoryTables();
    checkAndRestoreSettings();

    detectSystem();
    restoreCpuCudaSettings();
    setupVenvPaths();
}

/****************************************************************
 * @brief Destructor for MainWindow.
 ***************************************************************/
MainWindow::~MainWindow() {}

/****************************************************************
 * @brief Sets up the entire UI dynamically.
 ***************************************************************/
void MainWindow::setupUi()
{
    // Main window setup
    resize(900, 600);
    setWindowTitle(tr("Pip Matrix Resolver"));

    // Central widget
    centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);

    // Main layout
    QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);

    // Tab widget
    mainTabs = new QTabWidget(centralWidget);
    mainTabs->setCurrentIndex(3);
    mainLayout->addWidget(mainTabs);

    // === TAB: MAIN ===
    tabMain = new QWidget();
    tabMain->setObjectName("tabMain");
    QVBoxLayout *mainTabLayout = new QVBoxLayout(tabMain);

    splitter = new QSplitter(Qt::Horizontal, tabMain);
    requirementsView = new QTableView(splitter);
    matrixView = new QTableView(splitter);
    splitter->addWidget(requirementsView);
    splitter->addWidget(matrixView);
    mainTabLayout->addWidget(splitter);

    bottomSplitter = new QSplitter(Qt::Horizontal, tabMain);
    logView = new QPlainTextEdit(bottomSplitter);
    logView->setReadOnly(true);
    progress = new QProgressBar(bottomSplitter);
    bottomSplitter->addWidget(logView);
    bottomSplitter->addWidget(progress);
    mainTabLayout->addWidget(bottomSplitter);

    requirementsView->setModel(requirementsModel);
    requirementsView->setAlternatingRowColors(true);
    requirementsView->setSelectionBehavior(QAbstractItemView::SelectRows);
    requirementsView->setSelectionMode(QAbstractItemView::ExtendedSelection);

    mainTabs->addTab(tabMain, tr("Main"));

    // === TAB: HISTORY ===
    tabHistory = new QWidget();
    tabHistory->setObjectName("tabHistory");
    QVBoxLayout *historyLayout = new QVBoxLayout(tabHistory);

    localHistoryTable = new QTableView(tabHistory);
    localHistoryTable->setModel(localHistoryModel);
    historyLayout->addWidget(localHistoryTable);

    QHBoxLayout *localHistoryButtonBar = new QHBoxLayout();
    localAddButton = new QPushButton(tr("Add"), tabHistory);
    localEditButton = new QPushButton(tr("Edit"), tabHistory);
    localDeleteButton = new QPushButton(tr("Delete"), tabHistory);
    localUpButton = new QPushButton(tr("Up"), tabHistory);
    localDownButton = new QPushButton(tr("Down"), tabHistory);
    localHistoryButtonBar->addWidget(localAddButton);
    localHistoryButtonBar->addWidget(localEditButton);
    localHistoryButtonBar->addWidget(localDeleteButton);
    localHistoryButtonBar->addWidget(localUpButton);
    localHistoryButtonBar->addWidget(localDownButton);
    historyLayout->addLayout(localHistoryButtonBar);

    connect(localAddButton, &QPushButton::clicked, this, &MainWindow::on_localAddButton_clicked);
    connect(localEditButton, &QPushButton::clicked, this, &MainWindow::on_localEditButton_clicked);
    connect(localDeleteButton,
            &QPushButton::clicked,
            this,
            &MainWindow::on_localDeleteButton_clicked);
    connect(localUpButton, &QPushButton::clicked, this, &MainWindow::on_localUpButton_clicked);
    connect(localDownButton, &QPushButton::clicked, this, &MainWindow::on_localDownButton_clicked);

    webHistoryTable = new QTableView(tabHistory);
    webHistoryTable->setModel(webHistoryModel);
    historyLayout->addWidget(webHistoryTable);

    QHBoxLayout *webHistoryButtonBar = new QHBoxLayout();
    webAddButton = new QPushButton(tr("Add"), tabHistory);
    webEditButton = new QPushButton(tr("Edit"), tabHistory);
    webDeleteButton = new QPushButton(tr("Delete"), tabHistory);
    webUpButton = new QPushButton(tr("Up"), tabHistory);
    webDownButton = new QPushButton(tr("Down"), tabHistory);
    webHistoryButtonBar->addWidget(webAddButton);
    webHistoryButtonBar->addWidget(webEditButton);
    webHistoryButtonBar->addWidget(webDeleteButton);
    webHistoryButtonBar->addWidget(webUpButton);
    webHistoryButtonBar->addWidget(webDownButton);
    historyLayout->addLayout(webHistoryButtonBar);

    connect(webAddButton, &QPushButton::clicked, this, &MainWindow::on_webAddButton_clicked);
    connect(webEditButton, &QPushButton::clicked, this, &MainWindow::on_webEditButton_clicked);
    connect(webDeleteButton, &QPushButton::clicked, this, &MainWindow::on_webDeleteButton_clicked);
    connect(webUpButton, &QPushButton::clicked, this, &MainWindow::on_webUpButton_clicked);
    connect(webDownButton, &QPushButton::clicked, this, &MainWindow::on_webDownButton_clicked);

    mainTabs->addTab(tabHistory, tr("History"));

    // === TAB: TERMINAL ===
    tabTerminal = new QWidget();
    tabTerminal->setObjectName("tabTerminal");
    QVBoxLayout *terminalLayout = new QVBoxLayout(tabTerminal);

    terminalOutput = new QPlainTextEdit(tabTerminal);
    terminalLayout->addWidget(terminalOutput);

    QHBoxLayout *terminalCommandLayout = new QHBoxLayout();
    commandInput = new QLineEdit(tabTerminal);
    commandInput->setPlaceholderText("Enter command...");
    runCommandBtn = new QPushButton(tr("Run"), tabTerminal);
    clearTerminalBtn = new QPushButton(tr("Clear"), tabTerminal);
    stopCommandBtn = new QPushButton(tr("Stop"), tabTerminal);
    stopCommandBtn->setEnabled(false);
    terminalCommandLayout->addWidget(commandInput);
    terminalCommandLayout->addWidget(runCommandBtn);
    terminalCommandLayout->addWidget(stopCommandBtn);
    terminalCommandLayout->addWidget(clearTerminalBtn);
    terminalLayout->addLayout(terminalCommandLayout);

    mainTabs->addTab(tabTerminal, tr("Terminal"));

    // === TAB: PACKAGE MANAGER ===
    tabPackageManager = new QWidget();
    tabPackageManager->setObjectName("tabPackageManager");
    QVBoxLayout *packageManagerLayout = new QVBoxLayout(tabPackageManager);

    QHBoxLayout *packageManagerCommandLayout = new QHBoxLayout();
    packageNameInput = new QLineEdit(tabPackageManager);
    searchPackageBtn = new QPushButton(tr("Search"), tabPackageManager);
    installPackageBtn = new QPushButton(tr("Install"), tabPackageManager);
    uninstallPackageBtn = new QPushButton(tr("Uninstall"), tabPackageManager);
    packageManagerCommandLayout->addWidget(packageNameInput);
    packageManagerCommandLayout->addWidget(searchPackageBtn);
    packageManagerCommandLayout->addWidget(installPackageBtn);
    packageManagerCommandLayout->addWidget(uninstallPackageBtn);
    packageManagerLayout->addLayout(packageManagerCommandLayout);

    installedPackagesList = new QListWidget(tabPackageManager);
    packageManagerLayout->addWidget(installedPackagesList);

    packageOutput = new QPlainTextEdit(tabPackageManager);
    packageManagerLayout->addWidget(packageOutput);

    mainTabs->addTab(tabPackageManager, tr("Package Manager"));

    // === TAB: COMMANDS ===
    tabCommands = new QWidget();
    tabCommands->setObjectName("tabCommands");
    QVBoxLayout *commandsLayout = new QVBoxLayout(tabCommands);

    commandsTab = new CommandsTab(terminalEngine, tabCommands);
    commandsLayout->addWidget(commandsTab);

    mainTabs->addTab(tabCommands, tr("Commands"));

    // === TAB: SETTINGS ===
    tabSettings = new QWidget();
    tabSettings->setObjectName("tabSettings");
    QVBoxLayout *settingsLayout = new QVBoxLayout(tabSettings);

    QFormLayout *formLayout = new QFormLayout();

    pythonVersionEdit = new QLineEdit(tabSettings);
    formLayout->addRow(tr("Python version:"), pythonVersionEdit);

    pipVersionEdit = new QLineEdit(tabSettings);
    formLayout->addRow(tr("pip version:"), pipVersionEdit);

    pipToolsVersionEdit = new QLineEdit(tabSettings);
    formLayout->addRow(tr("pip-tools version:"), pipToolsVersionEdit);

    spinMaxItems = new QSpinBox(tabSettings);
    spinMaxItems->setMinimum(-1);
    spinMaxItems->setMaximum(std::numeric_limits<int>::max());
    spinMaxItems->setValue(10);
    spinMaxItems->setToolTip(tr("-1 = unlimited, 0 not allowed, â‰¥1 valid"));
    formLayout->addRow(tr("Maximum number of items:"), spinMaxItems);

    gpuDetectedCheckBox = new QCheckBox(tabSettings);
    gpuDetectedCheckBox->setEnabled(false);
    formLayout->addRow(tr("GPU Detected:"), gpuDetectedCheckBox);

    useCpuCheckBox = new QCheckBox(tabSettings);
    formLayout->addRow(tr("Use CPU:"), useCpuCheckBox);

    cudaCheckBox = new QCheckBox(tabSettings);
    formLayout->addRow(tr("Cuda:"), cudaCheckBox);

    osEdit = new QLineEdit(tabSettings);
    osEdit->setReadOnly(true);
    formLayout->addRow(tr("OS:"), osEdit);

    osReleaseEdit = new QLineEdit(tabSettings);
    osReleaseEdit->setReadOnly(true);
    formLayout->addRow(tr("Release:"), osReleaseEdit);

    osVersionEdit = new QLineEdit(tabSettings);
    osVersionEdit->setReadOnly(true);
    formLayout->addRow(tr("Version:"), osVersionEdit);

    settingsLayout->addLayout(formLayout);

    // Buttons and button box
    saveSettingsButton = new QPushButton(tr("Save Settings"), tabSettings);
    settingsLayout->addWidget(saveSettingsButton);

    restoreDefaultsButton = new QPushButton(tr("Restore Defaults"), tabSettings);
    settingsLayout->addWidget(restoreDefaultsButton);

    // Create the button box BEFORE connecting any signals
    buttonBoxPreferences = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Apply
                                                    | QDialogButtonBox::Cancel,
                                                tabSettings);
    settingsLayout->addWidget(buttonBoxPreferences);

    mainTabs->addTab(tabSettings, tr("Settings"));

    // === MENU BAR ===
    menuBar = new QMenuBar(this);
    setMenuBar(menuBar);

    // File menu
    menuFile = new QMenu(tr("&File"), this);
    menuBar->addMenu(menuFile);

    actionOpenRequirements = new QAction(QIcon(":/icons/icons/open.svg"),
                                         tr("Open requirements file..."),
                                         this);
    menuFile->addAction(actionOpenRequirements);

    actionFetchRequirements = new QAction(QIcon(":/icons/icons/url.svg"),
                                          tr("Fetch requirements from URL..."),
                                          this);
    menuFile->addAction(actionFetchRequirements);

    menuFile->addSeparator();

    // Recent menus (created here, populated later)
    recentLocalMenu = new QMenu(tr("Recent Local"), this);
    menuFile->addMenu(recentLocalMenu);

    recentWebMenu = new QMenu(tr("Recent Web"), this);
    menuFile->addMenu(recentWebMenu);

    menuFile->addSeparator();

    actionExit = new QAction(tr("Exit"), this);
    menuFile->addAction(actionExit);

    // Tools menu
    menuTools = new QMenu(tr("&Tools"), this);
    menuBar->addMenu(menuTools);

    actionCreateVenv = new QAction(QIcon(":/icons/icons/venv.svg"), tr("Create venv"), this);
    menuTools->addAction(actionCreateVenv);

    actionResolveMatrix = new QAction(QIcon(":/icons/icons/resolve.svg"),
                                      tr("Resolve matrix"),
                                      this);
    menuTools->addAction(actionResolveMatrix);

    actionPause = new QAction(QIcon(":/icons/icons/pause.svg"), tr("Pause"), this);
    menuTools->addAction(actionPause);

    actionResume = new QAction(QIcon(":/icons/icons/resume.svg"), tr("Resume"), this);
    menuTools->addAction(actionResume);

    actionStop = new QAction(QIcon(":/icons/icons/stop.svg"), tr("Stop"), this);
    menuTools->addAction(actionStop);

    // Batch menu
    menuBatch = new QMenu(tr("&Batch"), this);
    menuBar->addMenu(menuBatch);

    actionRunBatch = new QAction(QIcon(":/icons/icons/batch.svg"), tr("Run batch"), this);
    menuBatch->addAction(actionRunBatch);

    // Help menu
    menuHelp = new QMenu(tr("&Help"), this);
    menuBar->addMenu(menuHelp);

    actionAbout = new QAction(QIcon(":/icons/icons/info.svg"), tr("About"), this);
    menuHelp->addAction(actionAbout);

    actionViewReadme = new QAction(QIcon(":/icons/icons/readme.svg"), tr("View README"), this);
    menuHelp->addAction(actionViewReadme);

    // === TOOLBAR ===
    mainToolBar = new QToolBar(tr("Main Toolbar"), this);
    addToolBar(Qt::TopToolBarArea, mainToolBar);

    mainToolBar->addAction(actionOpenRequirements);
    mainToolBar->addAction(actionFetchRequirements);
    mainToolBar->addAction(actionCreateVenv);
    mainToolBar->addAction(actionResolveMatrix);
    mainToolBar->addAction(actionPause);
    mainToolBar->addAction(actionResume);
    mainToolBar->addAction(actionStop);
    mainToolBar->addAction(actionRunBatch);
    mainToolBar->addAction(actionAbout);
    mainToolBar->addAction(actionViewReadme);

    // === STATUS BAR ===
    statusBar = new QStatusBar(this);
    setStatusBar(statusBar);

    // === Terminal Engine wiring and Terminal tab gating ===
    terminalEngine = new TerminalEngine(this);

    // Connect TerminalEngine signals
    connect(terminalEngine, &TerminalEngine::outputReceived, this, &MainWindow::onTerminalOutput);
    connect(terminalEngine,
            &TerminalEngine::commandStarted,
            this,
            &MainWindow::onTerminalCommandStarted);
    connect(terminalEngine,
            &TerminalEngine::commandFinished,
            this,
            &MainWindow::onTerminalCommandFinished);
    connect(terminalEngine, &TerminalEngine::venvProgress, this, &MainWindow::onVenvProgress);

    // Settings tab connections (safe order)
    connect(saveSettingsButton, &QPushButton::clicked, this, &MainWindow::onSaveSettings);
    connect(restoreDefaultsButton, &QPushButton::clicked, this, &MainWindow::onRestoreDefaults);
    connect(buttonBoxPreferences, &QDialogButtonBox::accepted, this, &MainWindow::saveAppSettings);
    if (QPushButton *applyBtn = buttonBoxPreferences->button(QDialogButtonBox::Apply))
    {
        connect(applyBtn, &QPushButton::clicked, this, &MainWindow::onApplySettings);
    }

    // After creating terminalEngine and before venv checks:
    QString versionFromSettings = pythonVersionEdit->text().trimmed();
    terminalEngine->setPythonCommand(versionFromSettings);

    // Default venv path to project-local ".venv"
    terminalEngine->setVenvPath(QDir::currentPath() + "/.venv");

    // Disable Terminal tab at startup until venv is available and activated
    int terminalTabIndex = mainTabs->indexOf(tabTerminal);
    if (terminalTabIndex >= 0)
    {
        mainTabs->setTabEnabled(terminalTabIndex, false);
    }

    // Attempt to enable if venv exists and activation succeeds
    if (terminalEngine->venvExists())
    {
        if (terminalEngine->activateVenv())
        {
            if (terminalTabIndex >= 0)
            {
                mainTabs->setTabEnabled(terminalTabIndex, true);
            }
            statusBar->showMessage(tr("Virtual environment detected and activated"), 3000);
        }
        else
        {
            statusBar->showMessage(tr("Virtual environment present but activation failed"), 3000);
        }
    }
    else
    {
        statusBar->showMessage(tr("No virtual environment found. Use Tools â†’ Create venv."), 4000);
    }
}

/****************************************************************
 * @brief Exits the application.
 ***************************************************************/
void MainWindow::exitApp()
{
    QApplication::quit();
}

/****************************************************************
 * @brief Opens requirements from a local file via dialog.
 ***************************************************************/
void MainWindow::openLocalRequirements()
{
    QString path = QFileDialog::getOpenFileName(this,
                                                tr("Open requirements.txt"),
                                                QString(),
                                                tr("Text Files (*.txt)"));
    if (path.isEmpty())
    {
        return;
    }
    loadRequirementsFromFile(path);
}

/****************************************************************
 * @brief Fetches requirements from a URL via dialog.
 ***************************************************************/
void MainWindow::fetchRequirementsFromUrl()
{
    bool ok = false;
    QString inputUrl = QInputDialog::getText(this,
                                             tr("Fetch requirements"),
                                             tr("Enter URL:"),
                                             QLineEdit::Normal,
                                             "",
                                             &ok);
    if (!ok || inputUrl.isEmpty())
    {
        return;
    }
    const QString rawUrl = normalizeRawUrl(inputUrl);
    loadRequirementsFromUrl(rawUrl);
}

/****************************************************************
 * @brief Loads requirements from a local file.
 ***************************************************************/
void MainWindow::loadRequirementsFromFile(const QString &path)
{
    if (path.isEmpty())
    {
        return;
    }
    if (!QFile::exists(path))
    {
        QMessageBox::warning(this, tr("File missing"), tr("File no longer exists:\n%1").arg(path));
        historyRecentLocal.removeAll(path);
        refreshRecentMenus();
        saveHistory();
        return;
    }
    const QStringList lines = readTextFileLines(path);
    QStringList errors;
    if (!validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(this,
                             tr("Invalid requirements.txt"),
                             tr("Validation failed:\n%1").arg(errors.join("\n")));
        return;
    }
    if (requirementsModel)
    {
        requirementsModel->clear();
        writeTableToModel(lines);
    }
    applySettingsFromUi();
    historyRecentLocal.removeAll(path);
    historyRecentLocal.prepend(path);
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Loaded %1 requirements from %2").arg(requirementsModel->rowCount()).arg(path));
}

/****************************************************************
 * @brief Loads requirements from a URL.
 ***************************************************************/
void MainWindow::loadRequirementsFromUrl(const QString &url)
{
    if (url.isEmpty())
    {
        return;
    }
    QByteArray content;
    if (!downloadText(url, content))
    {
        QMessageBox::warning(this,
                             tr("Download failed"),
                             tr("Failed to fetch requirements from URL:\n%1").arg(url));
        historyRecentWeb.removeAll(url);
        refreshRecentMenus();
        saveHistory();
        return;
    }
    const QStringList lines = QString::fromUtf8(content).split('\n', Qt::KeepEmptyParts);
    QStringList errors;
    if (!validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(this,
                             tr("Invalid requirements.txt"),
                             tr("Fetched content failed validation:\n%1").arg(errors.join("\n")));
        return;
    }
    if (requirementsModel)
    {
        requirementsModel->clear();
        writeTableToModel(lines);
    }
    applySettingsFromUi();
    historyRecentWeb.removeAll(url);
    historyRecentWeb.prepend(url);
    if (maxHistoryItems != -1)
    {
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
    appendLog(
        tr("Fetched %1 requirements from URL: %2").arg(requirementsModel->rowCount()).arg(url));
}

/****************************************************************
 * @brief Populates the local and web history tables in the
 *        History tab with the current history data from QSettings.
 ***************************************************************/
void MainWindow::refreshHistoryTables()
{
    QSettings s(kOrganizationName, kApplicationName);
    QStringList localList = s.value("history/recentLocal").toStringList();
    QStringList webList = s.value("history/recentWeb").toStringList();

    localHistoryModel->clear();
    localHistoryModel->setHorizontalHeaderLabels({tr("Recent Local Files")});
    for (const QString &path : std::as_const(localList))
    {
        QList<QStandardItem *> row;
        row << new QStandardItem(path);
        localHistoryModel->appendRow(row);
    }
    localHistoryTable->resizeColumnsToContents();

    webHistoryModel->clear();
    webHistoryModel->setHorizontalHeaderLabels({tr("Recent Web URLs")});
    for (const QString &url : std::as_const(webList))
    {
        QList<QStandardItem *> row;
        row << new QStandardItem(url);
        webHistoryModel->appendRow(row);
    }
    webHistoryTable->resizeColumnsToContents();
    updateLocalHistoryButtons();
    updateWebHistoryButtons();
}

/****************************************************************
 * @brief Refreshes recent file and URL menus safely.
 ***************************************************************/
void MainWindow::refreshRecentMenus()
{
    if (!recentLocalMenu || !recentWebMenu)
    {
        qWarning() << "refreshRecentMenus: menus not available, skipping";
        return;
    }
    recentLocalMenu->clear();
    recentWebMenu->clear();

    // Populate Recent Local
    for (int i = 0; i < historyRecentLocal.size(); ++i)
    {
        const QString &path = historyRecentLocal.at(i);
        QAction *act = recentLocalMenu->addAction(path);
        connect(act, &QAction::triggered, this, [this, path]() { loadRequirementsFromFile(path); });
    }
    if (!historyRecentLocal.isEmpty())
    {
        recentLocalMenu->addSeparator();
        QAction *clearLocal = recentLocalMenu->addAction(tr("Clear Local History"));
        connect(clearLocal, &QAction::triggered, this, [this]() {
            historyRecentLocal.clear();
            refreshRecentMenus();
            saveHistory();
        });
    }

    // Populate Recent Web
    for (int i = 0; i < historyRecentWeb.size(); ++i)
    {
        const QString &url = historyRecentWeb.at(i);
        QAction *act = recentWebMenu->addAction(url);
        connect(act, &QAction::triggered, this, [this, url]() { loadRequirementsFromUrl(url); });
    }
    if (!historyRecentWeb.isEmpty())
    {
        recentWebMenu->addSeparator();
        QAction *clearWeb = recentWebMenu->addAction(tr("Clear Web History"));
        connect(clearWeb, &QAction::triggered, this, [this]() {
            historyRecentWeb.clear();
            refreshRecentMenus();
            saveHistory();
        });
    }
}

/****************************************************************
 * @brief Clears both local and web recent history lists.
 ***************************************************************/
void MainWindow::clearAllHistory()
{
    historyRecentLocal.clear();
    historyRecentWeb.clear();
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Cleared all history"));
}

/****************************************************************
 * @brief Loads persisted application + Settings values at startup.
 ***************************************************************/
void MainWindow::loadAppSettings()
{
    QSettings settings;

    // Load values with defaults
    QString pythonVer = settings.value("PythonVersion", DEFAULT_PYTHON_VERSION).toString();
    QString pipVer = settings.value("PipVersion", DEFAULT_PIP_VERSION).toString();
    QString pipToolsVer = settings.value("PipToolsVersion", DEFAULT_PIPTOOLS_VERSION).toString();
    int maxItems = settings.value("app/maxItems", DEFAULT_MAX_ITEMS).toInt();

    // Update internal state
    maxHistoryItems = maxItems;

    // Update UI fields
    pythonVersionEdit->setText(pythonVer);
    pipVersionEdit->setText(pipVer);
    pipToolsVersionEdit->setText(pipToolsVer);
    spinMaxItems->setValue(maxItems);

    // Apply Python command immediately
    terminalEngine->setPythonCommand(pythonVer);

    // Validate and sync UI
    validateAppSettings();
    updateUiFromSettings();
}

/****************************************************************
 * @brief Save Settings button handler.
 ***************************************************************/
void MainWindow::onSaveSettings()
{
    QString pythonVer = pythonVersionEdit->text().trimmed();
    QString pipVer = pipVersionEdit->text().trimmed();
    QString pipToolsVer = pipToolsVersionEdit->text().trimmed();
    int maxItems = spinMaxItems->value();

    terminalEngine->setPythonCommand(pythonVer);

    QSettings settings;
    settings.setValue("PythonVersion", pythonVer);
    settings.setValue("PipVersion", pipVer);
    settings.setValue("PipToolsVersion", pipToolsVer);
    settings.setValue("app/maxItems", maxItems);
    settings.sync();

    statusBar->showMessage(tr("Settings saved. Python command updated to: %1")
                               .arg(terminalEngine->pythonCommand()),
                           4000);
}

/****************************************************************
 * @brief Apply Settings button handler.
 ***************************************************************/
void MainWindow::onApplySettings()
{
    QString pythonVer = pythonVersionEdit->text().trimmed();
    terminalEngine->setPythonCommand(pythonVer);

    statusBar->showMessage(tr("Settings applied. Python command updated to: %1")
                               .arg(terminalEngine->pythonCommand()),
                           4000);
}

/****************************************************************
 * @brief Restore Defaults button handler.
 ***************************************************************/
void MainWindow::onRestoreDefaults()
{
    // Reset UI fields using constants
    pythonVersionEdit->setText(DEFAULT_PYTHON_VERSION);
    pipVersionEdit->setText(DEFAULT_PIP_VERSION);
    pipToolsVersionEdit->setText(DEFAULT_PIPTOOLS_VERSION);
    spinMaxItems->setValue(DEFAULT_MAX_ITEMS);
    useCpuCheckBox->setChecked(false);
    cudaCheckBox->setChecked(false);

    // Update runtime Python command using default
    terminalEngine->setPythonCommand(DEFAULT_PYTHON_VERSION);

    // Persist defaults
    QSettings settings;
    settings.setValue("PythonVersion", DEFAULT_PYTHON_VERSION);
    settings.setValue("PipVersion", DEFAULT_PIP_VERSION);
    settings.setValue("PipToolsVersion", DEFAULT_PIPTOOLS_VERSION);
    settings.setValue("app/maxItems", DEFAULT_MAX_ITEMS);
    settings.setValue("AppVersion", DEFAULT_APP_VERSION);
    settings.sync();

    statusBar->showMessage(tr("Defaults restored. Python command set to: %1")
                               .arg(terminalEngine->pythonCommand()),
                           4000);
}

/****************************************************************
 * @brief Save Settings when dialog accepted (OK).
 ***************************************************************/
void MainWindow::saveAppSettings()
{
    QString pythonVer = pythonVersionEdit->text().trimmed();
    QString pipVer = pipVersionEdit->text().trimmed();
    QString pipToolsVer = pipToolsVersionEdit->text().trimmed();
    int maxItems = spinMaxItems->value();

    terminalEngine->setPythonCommand(pythonVer);

    QSettings settings;
    settings.setValue("PythonVersion", pythonVer);
    settings.setValue("PipVersion", pipVer);
    settings.setValue("PipToolsVersion", pipToolsVer);
    settings.setValue("app/maxItems", maxItems);
    settings.setValue("AppVersion", DEFAULT_APP_VERSION);
    settings.sync();

    statusBar->showMessage(tr("Application settings saved. Python command updated to: %1")
                               .arg(terminalEngine->pythonCommand()),
                           4000);
}

/****************************************************************
 * @brief Validates and clamps settings to safe ranges.
 ***************************************************************/
void MainWindow::validateAppSettings()
{
    if (maxHistoryItems == 0)
    {
        maxHistoryItems = 10;
    }
    else if (maxHistoryItems < -1)
    {
        maxHistoryItems = 1;
    }
}

/****************************************************************
 * @brief Applies settings from UI widgets to member state.
 ***************************************************************/
void MainWindow::applySettingsFromUi()
{
    maxHistoryItems = spinMaxItems->value();
}

/****************************************************************
 * @brief Updates UI widgets to reflect current settings.
 ***************************************************************/
void MainWindow::updateUiFromSettings()
{
    spinMaxItems->setValue(maxHistoryItems);
}

/****************************************************************
 * @brief Writes requirements into a one-column model.
 ***************************************************************/
void MainWindow::writeTableToModel(const QStringList &lines)
{
    if (!requirementsModel || !requirementsView)
    {
        return;
    }
    requirementsModel->clear();
    requirementsModel->setColumnCount(1);
    requirementsModel->setHorizontalHeaderLabels({tr("requirements.txt")});
    requirementsView->resizeRowsToContents();

    for (const QString &line : lines)
    {
        const QString trimmed = line.trimmed();
        if (trimmed.isEmpty())
        {
            continue;
        }
        auto *item = new QStandardItem(trimmed);
        item->setEditable(false);
        requirementsModel->appendRow(item);
    }
    requirementsView->resizeColumnsToContents();
    requirementsView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
    requirementsView->horizontalHeader()->setSectionResizeMode(QHeaderView::Interactive);
    requirementsView->resizeColumnsToContents();
    requirementsView->resizeRowsToContents();

    // Get the actual width of requirementsView and add 66px
    int reqWidth = requirementsView->verticalHeader()->width();
    for (int col = 0; col < requirementsModel->columnCount(); ++col)
    {
        reqWidth += requirementsView->columnWidth(col);
    }
    reqWidth += 66;

    // Set the splitter sizes
    if (splitter)
    {
        QList<int> sizes;
        sizes << reqWidth << qMax(100, splitter->width() - reqWidth);
        splitter->setSizes(sizes);
    }
    refreshHistoryTables();
}

/****************************************************************
 * @brief Appends a line to the log view with timestamp.
 * @param line The message line to append.
 ***************************************************************/
void MainWindow::appendLog(const QString &line)
{
    QString time = QDateTime::currentDateTime().toString("HH:mm:ss");
    logView->appendPlainText(QString("[%1] %2").arg(time, line));
}

/****************************************************************
 * @brief Updates progress bar percent.
 * @param percent The progress value (0-100).
 ***************************************************************/
void MainWindow::updateProgress(int percent)
{
    progress->setValue(percent);
}

/****************************************************************
 * @brief Shows compiled result message path.
 * @param path The compiled output path.
 ***************************************************************/
void MainWindow::showCompiledResult(const QString &path)
{
    appendLog(tr("Successfully compiled: %1").arg(path));
    statusBar->showMessage(tr("Compiled successfully"));
}

/****************************************************************
 * @brief Shows About dialog using current appVersion.
 ***************************************************************/
void MainWindow::showAboutBox()
{
    QMessageBox::about(
        this,
        tr("About Pip Matrix Resolver"),
        tr("<b>Pip Matrix Resolver</b><br>" "Cross-platform Qt tool to resolve " "Python dependency matrices.<br>" "Version %1")
            .arg(appVersion));
}

/****************************************************************
 * @brief Shows README dialog from resources.
 ***************************************************************/
void MainWindow::showReadmeDialog()
{
    QFile file(":/docs/README.md");
    QString markdown;
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        markdown = QString::fromUtf8(file.readAll());
    }
    else
    {
        markdown = tr("README.md not found in resources.");
    }

    QDialog dialog(this);
    dialog.setWindowTitle(tr("README"));
    dialog.resize(700, 500);

    QVBoxLayout layout(&dialog);
    QTextBrowser viewer(&dialog);
    viewer.setMarkdown(markdown);
    viewer.setOpenExternalLinks(true);

    QPushButton closeButton(tr("Close"), &dialog);
    layout.addWidget(&viewer);
    layout.addWidget(&closeButton);

    connect(&closeButton, &QPushButton::clicked, &dialog, &QDialog::accept);

    dialog.exec();
}

/****************************************************************
 * @brief Loads persistent history from QSettings.
 ***************************************************************/
void MainWindow::loadHistory()
{
    QSettings s(kOrganizationName, kApplicationName);
    historyRecentLocal = s.value("history/recentLocal").toStringList();
    historyRecentWeb = s.value("history/recentWeb").toStringList();

    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
}

/****************************************************************
 * @brief Saves persistent history to QSettings.
 ***************************************************************/
void MainWindow::saveHistory()
{
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("history/recentLocal", historyRecentLocal);
    s.setValue("history/recentWeb", historyRecentWeb);
}

/****************************************************************
 * @brief Normalizes a raw URL string.
 ***************************************************************/
QString MainWindow::normalizeRawUrl(const QString &inputUrl)
{
    QString url = inputUrl.trimmed();
    if (!url.startsWith("http://") && !url.startsWith("https://"))
    {
        url.prepend("https://");
    }
    return url;
}

/****************************************************************
 * @brief Reads all lines from a text file.
 ***************************************************************/
QStringList MainWindow::readTextFileLines(const QString &path)
{
    QStringList lines;
    QFile file(path);
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        while (!file.atEnd())
        {
            lines << QString::fromUtf8(file.readLine()).trimmed();
        }
        file.close();
    }
    return lines;
}

/****************************************************************
 * @brief Validates requirements.txt lines.
 ***************************************************************/
bool MainWindow::validateRequirementsWithErrors(const QStringList &lines, QStringList &errors)
{
    errors.clear();
    bool valid = true;
    for (const QString &line : lines)
    {
        if (line.isEmpty())
        {
            continue;
        }
        // Example validation: must not start with a dash or space
        if (line.startsWith('-') || line.startsWith(' '))
        {
            errors << tr("Invalid line: %1").arg(line);
            valid = false;
        }
        // Add more validation rules as needed
    }
    return valid;
}

/****************************************************************
 * @brief Downloads text from a URL.
 ***************************************************************/
bool MainWindow::downloadText(const QString &url, QByteArray &out)
{
    QNetworkAccessManager manager;
    QNetworkRequest request{QUrl(url)};
    QNetworkReply *reply = manager.get(request);
    QEventLoop loop;
    connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
    loop.exec();
    if (reply->error() != QNetworkReply::NoError)
    {
        reply->deleteLater();
        return false;
    }
    out = reply->readAll();
    reply->deleteLater();
    return true;
}

/****************************************************************
 * @brief Returns the logs directory path.
 ***************************************************************/
QString MainWindow::logsDir()
{
    QString dir = QDir::homePath() + "/PipMatrixResolverLogs";
    QDir().mkpath(dir);
    return dir;
}

/****************************************************************
 * @brief Starts matrix resolution (stub).
 ***************************************************************/
void MainWindow::startResolve()
{
    appendLog(tr("Starting matrix resolution..."));
    // Add your matrix resolution logic here
}

/****************************************************************
 * @brief Pauses matrix resolution (stub).
 ***************************************************************/
void MainWindow::pauseResolve()
{
    appendLog(tr("Pausing..."));
    // Add your pause logic here
}

/****************************************************************
 * @brief Resumes matrix resolution (stub).
 ***************************************************************/
void MainWindow::resumeResolve()
{
    appendLog(tr("Resuming..."));
    // Add your resume logic here
}

/****************************************************************
 * @brief Stops matrix resolution (stub).
 ***************************************************************/
void MainWindow::stopResolve()
{
    appendLog(tr("Stopping..."));
    // Add your stop logic here
}

/****************************************************************
 * @brief Adds a new entry to the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localAddButton_clicked()
{
    bool ok;
    QString path = QInputDialog::getText(this,
                                         tr("Add Local File"),
                                         tr("File path:"),
                                         QLineEdit::Normal,
                                         "",
                                         &ok);
    if (ok && !path.isEmpty())
    {
        QSettings s(kOrganizationName, kApplicationName);
        QStringList list = s.value("history/recentLocal").toStringList();
        list.prepend(path);
        s.setValue("history/recentLocal", list);
        refreshHistoryTables();
    }
}

/****************************************************************
 * @brief Edits the selected entry in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localEditButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid())
        return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    QString oldValue = list.at(idx.row());
    bool ok;
    QString newValue = QInputDialog::getText(this,
                                             tr("Edit Local File"),
                                             tr("File path:"),
                                             QLineEdit::Normal,
                                             oldValue,
                                             &ok);
    if (!ok)
        return; // User cancelled, do nothing
    if (newValue.isEmpty())
        return; // Optionally, do nothing if empty
    list[idx.row()] = newValue;
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Deletes the selected entry from the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localDeleteButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid())
        return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    list.removeAt(idx.row());
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Moves the selected entry up in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localUpButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid() || idx.row() == 0)
        return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    list.swapItemsAt(idx.row(), idx.row() - 1);
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
    localHistoryTable->selectRow(idx.row() - 1);
}

/****************************************************************
 * @brief Moves the selected entry down in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localDownButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    if (!idx.isValid() || idx.row() >= list.size() - 1)
        return;
    list.swapItemsAt(idx.row(), idx.row() + 1);
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
    localHistoryTable->selectRow(idx.row() + 1);
}

/****************************************************************
 * @brief Adds a new entry to the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webAddButton_clicked()
{
    bool ok;
    QString url
        = QInputDialog::getText(this, tr("Add Web URL"), tr("URL:"), QLineEdit::Normal, "", &ok);
    if (ok && !url.isEmpty())
    {
        QSettings s(kOrganizationName, kApplicationName);
        QStringList list = s.value("history/recentWeb").toStringList();
        list.prepend(url);
        s.setValue("history/recentWeb", list);
        refreshHistoryTables();
    }
}

/****************************************************************
 * @brief Edits the selected entry in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webEditButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid())
        return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    QString oldValue = list.at(idx.row());
    bool ok;
    QString newValue = QInputDialog::getText(this,
                                             tr("Edit Web URL"),
                                             tr("URL:"),
                                             QLineEdit::Normal,
                                             oldValue,
                                             &ok);
    if (!ok)
        return; // User cancelled, do nothing
    if (newValue.isEmpty())
        return; // Optionally, do nothing if empty
    list[idx.row()] = newValue;
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Deletes the selected entry from the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webDeleteButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid())
        return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    list.removeAt(idx.row());
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Moves the selected entry up in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webUpButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid() || idx.row() == 0)
        return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    list.swapItemsAt(idx.row(), idx.row() - 1);
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
    webHistoryTable->selectRow(idx.row() - 1);
}

/****************************************************************
 * @brief Moves the selected entry down in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webDownButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    if (!idx.isValid() || idx.row() >= list.size() - 1)
        return;
    list.swapItemsAt(idx.row(), idx.row() + 1);
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
    webHistoryTable->selectRow(idx.row() + 1);
}

/****************************************************************
 * @brief Enables/disables local history buttons based on selection and table size.
 ***************************************************************/
void MainWindow::updateLocalHistoryButtons()
{
    QItemSelectionModel *sel = localHistoryTable->selectionModel();
    int rowCount = localHistoryModel->rowCount();
    bool hasSelection = sel->hasSelection();

    localEditButton->setEnabled(hasSelection);
    localDeleteButton->setEnabled(hasSelection);

    // Up: enabled if selected and not first row, and more than 1 item
    bool canUp = hasSelection && rowCount > 1;
    if (canUp)
    {
        QModelIndex idx = sel->currentIndex();
        canUp = idx.isValid() && idx.row() > 0;
    }
    localUpButton->setEnabled(canUp);

    // Down: enabled if selected and not last row, and more than 1 item
    bool canDown = hasSelection && rowCount > 1;
    if (canDown)
    {
        QModelIndex idx = sel->currentIndex();
        canDown = idx.isValid() && idx.row() < rowCount - 1;
    }
    localDownButton->setEnabled(canDown);
}

/****************************************************************
 * @brief Enables/disables web history buttons based on selection and table size.
 ***************************************************************/
void MainWindow::updateWebHistoryButtons()
{
    QItemSelectionModel *sel = webHistoryTable->selectionModel();
    int rowCount = webHistoryModel->rowCount();
    bool hasSelection = sel->hasSelection();

    webEditButton->setEnabled(hasSelection);
    webDeleteButton->setEnabled(hasSelection);

    // Up: enabled if selected and not first row, and more than 1 item
    bool canUp = hasSelection && rowCount > 1;
    if (canUp)
    {
        QModelIndex idx = sel->currentIndex();
        canUp = idx.isValid() && idx.row() > 0;
    }
    webUpButton->setEnabled(canUp);

    // Down: enabled if selected and not last row, and more than 1 item
    bool canDown = hasSelection && rowCount > 1;
    if (canDown)
    {
        QModelIndex idx = sel->currentIndex();
        canDown = idx.isValid() && idx.row() < rowCount - 1;
    }
    webDownButton->setEnabled(canDown);
}

/****************************************************************
 * @brief save Settings.
 ***************************************************************/
void MainWindow::saveSettings()
{
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("settings/pythonVersion", pythonVersionEdit->text());
    s.setValue("settings/pipVersion", pipVersionEdit->text());
    s.setValue("settings/pipToolsVersion", pipToolsVersionEdit->text());
    s.setValue("settings/maxItems", spinMaxItems->value());
    s.setValue("settings/useCpu", useCpuCheckBox->isChecked());
    s.setValue("settings/cuda", cudaCheckBox->isChecked());
}

/****************************************************************
 * @brief check And Restore Settings.
 ***************************************************************/
void MainWindow::checkAndRestoreSettings()
{
    QSettings s(kOrganizationName, kApplicationName);

    // Python version
    QString pythonVersion = s.value("settings/pythonVersion", DEFAULT_PYTHON_VERSION).toString();
    if (pythonVersion.isEmpty())
    {
        pythonVersion = DEFAULT_PYTHON_VERSION;
        s.setValue("settings/pythonVersion", pythonVersion);
    }
    pythonVersionEdit->setText(pythonVersion);

    // pip version
    QString pipVersion = s.value("settings/pipVersion", DEFAULT_PIP_VERSION).toString();
    if (pipVersion.isEmpty())
    {
        pipVersion = DEFAULT_PIP_VERSION;
        s.setValue("settings/pipVersion", pipVersion);
    }
    pipVersionEdit->setText(pipVersion);

    // pip-tools version
    QString pipToolsVersion = s.value("settings/pipToolsVersion", DEFAULT_PIPTOOLS_VERSION)
                                  .toString();
    if (pipToolsVersion.isEmpty())
    {
        pipToolsVersion = DEFAULT_PIPTOOLS_VERSION;
        s.setValue("settings/pipToolsVersion", pipToolsVersion);
    }
    pipToolsVersionEdit->setText(pipToolsVersion);

    // Max items
    int maxItems = s.value("settings/maxItems", DEFAULT_MAX_ITEMS).toInt();
    if (maxItems == 0)
    {
        maxItems = DEFAULT_MAX_ITEMS;
        s.setValue("settings/maxItems", maxItems);
    }
    spinMaxItems->setValue(maxItems);
}

/****************************************************************
 * @brief Restores CPU and Cuda settings from QSettings to UI.
 ***************************************************************/
void MainWindow::restoreCpuCudaSettings()
{
    QSettings s(kOrganizationName, kApplicationName);
    useCpuCheckBox->setChecked(s.value("settings/useCpu", false).toBool());
    cudaCheckBox->setChecked(s.value("settings/cuda", true).toBool());
}

/****************************************************************
 * @brief Detect OS System.
 ***************************************************************/
void MainWindow::detectSystem()
{
    // GPU detection (simple: check for NVIDIA)
    bool gpuDetected = false;
    QString os, release, version;
#if defined(Q_OS_WIN)
    os = "Windows";
    release = QSysInfo::productType();
    version = QSysInfo::productVersion();
#elif defined(Q_OS_MAC)
    os = "Mac";
    release = QSysInfo::productType();
    version = QSysInfo::productVersion();
#elif defined(Q_OS_LINUX)
    os = "Linux";
    QFile f("/etc/os-release");
    if (f.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        while (!f.atEnd())
        {
            QString line = f.readLine();
            if (line.startsWith("ID="))
                release = line.mid(3).trimmed().replace("\"", "");
            if (line.startsWith("VERSION_ID="))
                version = line.mid(11).trimmed().replace("\"", "");
        }
    }
#endif
    osEdit->setText(os);
    osReleaseEdit->setText(release);
    osVersionEdit->setText(version);

#if defined(Q_OS_WIN)
    QProcess proc;
    proc.start("wmic path win32_VideoController get name");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive))
        gpuDetected = true;
#elif defined(Q_OS_LINUX)
    QProcess proc;
    proc.start("lspci");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive))
        gpuDetected = true;
#elif defined(Q_OS_MAC)
    QProcess proc;
    proc.start("system_profiler SPDisplaysDataType");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive))
        gpuDetected = true;
#endif
    if (!gpuDetected)
    {
        gpuDetected = detectNvidiaGpu();
    }
    gpuDetectedCheckBox->setChecked(gpuDetected);

    // Save to QSettings
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("settings/os", os);
    s.setValue("settings/osRelease", release);
    s.setValue("settings/osVersion", version);
    s.setValue("settings/gpuDetected", gpuDetected);
    if (gpuDetected)
    {
        statusBar->showMessage(tr("GPU Detected"));
    }
    else
    {
        statusBar->showMessage(tr("GPU Not Detected"));
    }
}

/****************************************************************
 * @brief on Create Venv.
 ***************************************************************/
void MainWindow::onCreateVenv()
{
    // Get Python version from settings
    QString pythonVersion = pythonVersionEdit->text().trimmed();
    if (pythonVersion.isEmpty())
    {
        pythonVersion = DEFAULT_PYTHON_VERSION;
    }

    // Get pip and pip-tools versions (currently informational)
    QString pipVersion = pipVersionEdit->text().trimmed();
    QString pipToolsVersion = pipToolsVersionEdit->text().trimmed();
    Q_UNUSED(pipVersion);
    Q_UNUSED(pipToolsVersion);

    // Set venv path
    QString venvPath = QDir::currentPath() + "/.venv";
    terminalEngine->setVenvPath(venvPath);

    // Switch to terminal tab
    mainTabs->setCurrentWidget(tabTerminal);

    // Clear terminal and show progress
    terminalOutput->clear();
    appendTerminalOutput("=== Creating Virtual Environment ===", false);
    appendTerminalOutput(QString("Python version: %1").arg(pythonVersion), false);
    appendTerminalOutput(QString("Virtual environment path: %1").arg(venvPath), false);
    appendTerminalOutput("", false);

    // UI state during creation
    QApplication::setOverrideCursor(Qt::WaitCursor);
    runCommandBtn->setEnabled(false);
    stopCommandBtn->setEnabled(false);

    bool success = terminalEngine->createVirtualEnvironment(pythonVersion);

    runCommandBtn->setEnabled(true);
    stopCommandBtn->setEnabled(false);
    QApplication::restoreOverrideCursor();

    int terminalTabIndex = mainTabs->indexOf(tabTerminal);

    if (success)
    {
        appendTerminalOutput("", false);
        appendTerminalOutput("=== Virtual Environment Ready ===", false);
        appendTerminalOutput("You can now run Python commands, pip, and pip-tools", false);

        // Try to activate and enable Terminal tab
        if (terminalEngine->activateVenv())
        {
            if (terminalTabIndex >= 0)
            {
                mainTabs->setTabEnabled(terminalTabIndex, true);
            }
            statusBar->showMessage(tr("Virtual environment created and activated"), 5000);
        }
        else
        {
            statusBar->showMessage(tr("Virtual environment created, but activation failed"), 5000);
        }
    }
    else
    {
        appendTerminalOutput("", false);
        appendTerminalOutput("=== Virtual Environment Creation Failed ===", true);
        if (terminalTabIndex >= 0)
        {
            mainTabs->setTabEnabled(terminalTabIndex, false);
        }
        statusBar->showMessage(tr("Failed to create virtual environment"), 5000);
    }
}

/****************************************************************
 * @brief on Run Command.
 ***************************************************************/
void MainWindow::onRunCommand()
{
    QString command = commandInput->text().trimmed();
    if (command.isEmpty())
    {
        return;
    }

    // Clear input
    commandInput->clear();

    // Execute command
    terminalEngine->executeCommand(command);
}

/****************************************************************
 * @brief on Clear Terminal.
 ***************************************************************/
void MainWindow::onClearTerminal()
{
    terminalOutput->clear();
}

/****************************************************************
 * @brief on Stop Command.
 ***************************************************************/
void MainWindow::onStopCommand()
{
    terminalEngine->stopCurrentProcess();
}

/****************************************************************
 * @brief Handles terminal output from TerminalEngine.
 ***************************************************************/
void MainWindow::onTerminalOutput(const QString &output, bool isError)
{
    appendTerminalOutput(output, isError);
}

/****************************************************************
 * @brief Handles terminal command started event.
 ***************************************************************/
void MainWindow::onTerminalCommandStarted(const QString &command)
{
    runCommandBtn->setEnabled(false);
    stopCommandBtn->setEnabled(true);
    statusBar->showMessage(QString("Executing: %1").arg(command));
}

/****************************************************************
 * @brief Handles terminal command finished event.
 ***************************************************************/
void MainWindow::onTerminalCommandFinished(int exitCode, QProcess::ExitStatus exitStatus)
{
    runCommandBtn->setEnabled(true);
    stopCommandBtn->setEnabled(false);

    if (exitStatus == QProcess::NormalExit && exitCode == 0)
    {
        statusBar->showMessage(tr("Command completed successfully"), 3000);
    }
    else
    {
        statusBar->showMessage(tr("Command failed"), 3000);
    }
}

/****************************************************************
 * @brief Handles venv progress messages.
 ***************************************************************/
void MainWindow::onVenvProgress(const QString &message)
{
    appendTerminalOutput(message, false);
    QApplication::processEvents(); // Update UI
}

/****************************************************************
 * @brief Helper to append text to terminal output with color.
 ***************************************************************/
void MainWindow::appendTerminalOutput(const QString &text, bool isError)
{
    if (text.isEmpty())
    {
        terminalOutput->appendPlainText("");
        return;
    }

    QTextCursor cursor = terminalOutput->textCursor();
    cursor.movePosition(QTextCursor::End);

    QTextCharFormat format;
    if (isError)
    {
        format.setForeground(QColor(Qt::red));
    }
    else if (text.startsWith("===") || text.startsWith("$"))
    {
        format.setForeground(QColor(Qt::blue));
        format.setFontWeight(QFont::Bold);
    }
    else
    {
        format.setForeground(QColor(Qt::black));
    }

    cursor.setCharFormat(format);
    cursor.insertText(text + "\n");

    terminalOutput->setTextCursor(cursor);
    terminalOutput->ensureCursorVisible();
}

/****************************************************************
 * @brief Sets up venv_running and venv_testing paths and saves to QSettings.
 ***************************************************************/
void MainWindow::setupVenvPaths()
{
    QSettings s(kOrganizationName, kApplicationName);
    QString projectRoot = QDir::currentPath();
    QString venvRunning = projectRoot + "/.venvs/venv_running";
    QString venvTesting = projectRoot + "/.venvs/venv_testing";
    s.setValue("venv/venv_running", venvRunning);
    s.setValue("venv/venv_testing", venvTesting);
}

/****************************************************************
 * @brief detect Gpu Via PowerShell.
 ***************************************************************/
bool MainWindow::detectGpuViaPowerShell()
{
    QProcess proc;
    proc.start(
        "powershell",
        QStringList() << "-Command"
                      << "Get-WmiObject Win32_VideoController | Select-Object -ExpandProperty Name");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    return output.contains("NVIDIA", Qt::CaseInsensitive);
}

/****************************************************************
 * @brief detect Gpu Via DxDiag.
 ***************************************************************/
bool MainWindow::detectGpuViaDxDiag()
{
    QProcess proc;
    proc.start("cmd", QStringList() << "/c" << "dxdiag /t dxdiag.txt");
    proc.waitForFinished();
    QFile file("dxdiag.txt");
    bool found = false;
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        QString dxdiagOutput = file.readAll();
        found = dxdiagOutput.contains("NVIDIA", Qt::CaseInsensitive);
        file.remove(); // Clean up
    }
    return found;
}

/****************************************************************
 * @brief detect Gpu Via Nvidia Smi.
 ***************************************************************/
bool MainWindow::detectGpuViaNvidiaSmi()
{
    QProcess proc;
    proc.start("nvidia-smi");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    return output.contains("NVIDIA", Qt::CaseInsensitive);
}

/****************************************************************
 * @brief detect Nvidia Gpu.
 ***************************************************************/
bool MainWindow::detectNvidiaGpu()
{
    // Primary test: PowerShell WMI
    if (detectGpuViaPowerShell())
        return true;
    // Fallback 1: dxdiag
    if (detectGpuViaDxDiag())
        return true;
    // Fallback 2: nvidia-smi
    if (detectGpuViaNvidiaSmi())
        return true;
    // Not detected
    return false;
}

/****************************************************************
 * @brief on Search Package.
 ***************************************************************/
void MainWindow::onSearchPackage()
{
    QString pkg = packageNameInput->text().trimmed();
    if (pkg.isEmpty())
    {
        packageOutput->appendPlainText("Enter a package name to search.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "search", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QStringList lines = output.split('\n', Qt::SkipEmptyParts);
    for (int i = 0; i < lines.size(); ++i)
    {
        installedPackagesList->addItem(lines.at(i));
    }
}

/****************************************************************
 * @brief Handles double-click on installed package list item.
 * @param index The model index of the double-clicked item.
 ***************************************************************/
void MainWindow::onInstalledPackagesListDoubleClicked(const QModelIndex &index)
{
    QString pkg = installedPackagesList->item(index.row())->text().split('=')[0];
    packageNameInput->setText(pkg);
    onUninstallPackage();
}

/****************************************************************
 * @brief on Install Package.
 ***************************************************************/
void MainWindow::onInstallPackage()
{
    QString pkg = packageNameInput->text().trimmed();
    if (pkg.isEmpty())
    {
        packageOutput->appendPlainText("Enter a package name to install.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "install", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief on Uninstall Package.
 ***************************************************************/
void MainWindow::onUninstallPackage()
{
    QString pkg = packageNameInput->text().trimmed();
    if (pkg.isEmpty())
    {
        packageOutput->appendPlainText("Enter a package name to uninstall.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "uninstall", "-y", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief Refreshes the list of installed packages in venv.
 ***************************************************************/
void MainWindow::refreshInstalledPackages()
{
    installedPackagesList->clear();
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "list", "--format=freeze"};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QStringList lines = output.split('\n', Qt::SkipEmptyParts);
    for (int i = 0; i < lines.size(); ++i)
    {
        installedPackagesList->addItem(lines.at(i));
    }
}

/****************************************************************
 * @brief Handles immediate UI update when Python version changes.
 * @param newVersion The new Python version string (e.g., "3.11").
 ***************************************************************/
void MainWindow::onPythonVersionChanged(const QString &newVersion)
{
    // Update the Settings field immediately
    if (pythonVersionEdit)
        pythonVersionEdit->setText(newVersion);

    // Reload other settings for consistency
    loadAppSettings();

    DEBUG_MSG() << "[DEBUG] UI updated to Python version:" << newVersion;
}

/****************************************************************
 * @brief Refreshes the Python version displayed in the Settings UI.
 ***************************************************************/
void MainWindow::refreshPythonVersionUI()
{
    QSettings settings;
    QString currentVersion = settings.value("PythonVersion", "3.10").toString();

    if (pythonVersionEdit)
        pythonVersionEdit->setText(currentVersion);
}

/************** End of MainWindow.cpp ***************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.h
 * @brief Declares the main application window class.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.7
 * @date    2025-11-03
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Main window interface for PipMatrixResolver Qt application.
 * Includes settings API, history, menus, and shared loaders for
 * files and URLs. Uses C-style braces. Now with dynamic UI.
 ***************************************************************/

#pragma once
#include <QMainWindow>
#include <QStringList>
#include <QTimer>
#include <QStandardItemModel>
#include <QTableView>
#include <QPlainTextEdit>
#include <QProgressBar>
#include <QMenu>
#include <QMenuBar>
#include <QToolBar>
#include <QStatusBar>
#include <QAction>
#include <QDialogButtonBox>
#include <QPushButton>
#include <QFile>
#include <QDir>
#include <QFileInfo>
#include <QByteArray>
#include <QDialog>
#include <QTextBrowser>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QInputDialog>
#include <QMessageBox>
#include <QSettings>
#include <QDateTime>
#include <QDebug>
#include <QTabWidget>
#include <QSplitter>
#include <QCheckBox>
#include <QLineEdit>
#include <QSpinBox>
#include <QListWidget>
#include "CommandsTab.h"
#include "TerminalEngine.h"

/****************************************************************
 * @class MainWindow
 * @brief Implements the main application window.
 ***************************************************************/
class MainWindow : public QMainWindow
{
    Q_OBJECT
public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

    // QSettings
    static const QString kOrganizationName;
    static const QString kApplicationName;
    // Globals
    static QString appVersion;

private slots:
    void openLocalRequirements();
    void fetchRequirementsFromUrl();
    void refreshRecentMenus();
    void clearAllHistory();
    void onSaveSettings();
    void onApplySettings();
    void onRestoreDefaults();
    void saveAppSettings();
    void loadAppSettings();
    void validateAppSettings();
    void applySettingsFromUi();
    void updateUiFromSettings();
    void startResolve();
    void pauseResolve();
    void resumeResolve();
    void stopResolve();
    void appendLog(const QString &line);
    void updateProgress(int percent);
    void showCompiledResult(const QString &path);
    void showAboutBox();
    void showReadmeDialog();
    void exitApp();
    void writeTableToModel(const QStringList &lines);
    // Local history slots
    void on_localAddButton_clicked();
    void on_localEditButton_clicked();
    void on_localDeleteButton_clicked();
    void on_localUpButton_clicked();
    void on_localDownButton_clicked();

    // Web history slots
    void on_webAddButton_clicked();
    void on_webEditButton_clicked();
    void on_webDeleteButton_clicked();
    void on_webUpButton_clicked();
    void on_webDownButton_clicked();

    void updateLocalHistoryButtons();
    void updateWebHistoryButtons();
    // Slot for menu action
    void onCreateVenv();

    void onRunCommand();
    void onClearTerminal();
    void onStopCommand();

    // Package Manager tab
    void onSearchPackage();
    void onInstallPackage();
    void onUninstallPackage();

    void refreshInstalledPackages();
    void onInstalledPackagesListDoubleClicked(const QModelIndex &index);

    // Terminal engine slots
    void onTerminalOutput(const QString &output, bool isError);
    void onTerminalCommandStarted(const QString &command);
    void onTerminalCommandFinished(int exitCode, QProcess::ExitStatus exitStatus);
    void onVenvProgress(const QString &message);
    //void onVenvStatusChanged(bool active);

    void onPythonVersionChanged(const QString &newVersion);

private:
    void setupUi();
    void loadRequirementsFromFile(const QString &path);
    void loadRequirementsFromUrl(const QString &url);
    void saveHistory();
    void loadHistory();
    /****************************************************************
     * @brief Populates the local and web history tables in the
     *        History tab with the current history data.
     ***************************************************************/
    void refreshHistoryTables();
    /****************************************************************
    * @brief Checks all settings in the Settings tab at startup,
    *        restores defaults if missing, and updates the UI.
    ***************************************************************/
    void checkAndRestoreSettings();

    bool detectGpuViaPowerShell();
    bool detectNvidiaGpu();
    bool detectGpuViaNvidiaSmi();
    bool detectGpuViaDxDiag();
    /****************************************************************
    * @brief Saves all settings from the Settings tab to QSettings.
    ***************************************************************/
    void saveSettings();
    // Startup/system functions
    void detectSystem();
    void restoreCpuCudaSettings();
    void setupVenvPaths();

    // Utility functions moved from MatrixUtility
    QStringList readTextFileLines(const QString &path);
    bool validateRequirementsWithErrors(const QStringList &lines, QStringList &errors);
    QString normalizeRawUrl(const QString &inputUrl);
    bool downloadText(const QString &url, QByteArray &out);
    QString logsDir();
    void appendTerminalOutput(const QString &text, bool isError);
    void refreshPythonVersionUI();

    // History data
    QStringList historyRecentLocal;
    QStringList historyRecentWeb;

    // UI widgets - Main Window
    QWidget *centralWidget;
    QTabWidget *mainTabs;
    QMenuBar *menuBar;
    QToolBar *mainToolBar;
    QStatusBar *statusBar;

    // Menus
    QMenu *menuFile;
    QMenu *menuTools;
    QMenu *menuBatch;
    QMenu *menuHelp;

    // Actions
    QAction *actionOpenRequirements;
    QAction *actionFetchRequirements;
    QAction *actionExit;
    QAction *actionCreateVenv;
    QAction *actionResolveMatrix;
    QAction *actionPause;
    QAction *actionResume;
    QAction *actionStop;
    QAction *actionRunBatch;
    QAction *actionAbout;
    QAction *actionViewReadme;

    // Tab: Main
    QWidget *tabMain;
    QSplitter *splitter;
    QSplitter *bottomSplitter;
    QStandardItemModel *requirementsModel;
    QTableView *requirementsView;
    QTableView *matrixView;
    QPlainTextEdit *logView;
    QProgressBar *progress;

    // Tab: History
    QWidget *tabHistory;
    QTableView *localHistoryTable;
    QTableView *webHistoryTable;
    QStandardItemModel *localHistoryModel;
    QStandardItemModel *webHistoryModel;
    QPushButton *localAddButton;
    QPushButton *localEditButton;
    QPushButton *localDeleteButton;
    QPushButton *localUpButton;
    QPushButton *localDownButton;
    QPushButton *webAddButton;
    QPushButton *webEditButton;
    QPushButton *webDeleteButton;
    QPushButton *webUpButton;
    QPushButton *webDownButton;

    // Tab: Terminal
    QWidget *tabTerminal;
    QPlainTextEdit *terminalOutput;
    QLineEdit *commandInput;
    QPushButton *runCommandBtn;
    QPushButton *clearTerminalBtn;
    QPushButton *stopCommandBtn;

    // Tab: Package Manager
    QWidget *tabPackageManager;
    QLineEdit *packageNameInput;
    QPushButton *searchPackageBtn;
    QPushButton *installPackageBtn;
    QPushButton *uninstallPackageBtn;
    QListWidget *installedPackagesList;
    QPlainTextEdit *packageOutput;

    // Tab: Commands
    QWidget *tabCommands;
    CommandsTab *commandsTab;

    // Tab: Settings
    QWidget *tabSettings;
    QLineEdit *pythonVersionEdit;
    QLineEdit *pipVersionEdit;
    QLineEdit *pipToolsVersionEdit;
    QSpinBox *spinMaxItems;
    QCheckBox *gpuDetectedCheckBox;
    QCheckBox *useCpuCheckBox;
    QCheckBox *cudaCheckBox;
    QLineEdit *osEdit;
    QLineEdit *osReleaseEdit;
    QLineEdit *osVersionEdit;
    QPushButton *saveSettingsButton;
    QPushButton *restoreDefaultsButton;
    QDialogButtonBox *buttonBoxPreferences;

    QMenu *recentLocalMenu;
    QMenu *recentWebMenu;

    // Venv paths
    QString venvRunningPath;
    QString venvTestingPath;

    // Terminal engine
    TerminalEngine *terminalEngine;

    // Settings
    int maxHistoryItems; // -1=unlimited, 0 invalid, â‰¥1 valid

};

/************** End of MainWindow.h ****************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.ui
#-------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>900</width>
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Pip Matrix Resolver</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <widget class="QTabWidget" name="mainTabs">
      <property name="currentIndex">
       <number>3</number>
      </property>
      <widget class="QWidget" name="tabMain">
       <attribute name="title">
        <string>Main</string>
       </attribute>
       <layout class="QVBoxLayout" name="mainLayout">
        <item>
         <widget class="QSplitter" name="splitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QTableView" name="requirementsView"/>
          <widget class="QTableView" name="matrixView"/>
         </widget>
        </item>
        <item>
         <widget class="QSplitter" name="bottomSplitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QPlainTextEdit" name="logView">
           <property name="readOnly">
            <bool>true</bool>
           </property>
          </widget>
          <widget class="QProgressBar" name="progressBar"/>
         </widget>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabHistory">
       <attribute name="title">
        <string>History</string>
       </attribute>
       <layout class="QVBoxLayout" name="historyLayout">
        <item>
         <widget class="QTableView" name="localHistoryTable"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="localHistoryButtonBar">
          <item>
           <widget class="QPushButton" name="localAddButton">
            <property name="text">
             <string>Add</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localEditButton">
            <property name="text">
             <string>Edit</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localDeleteButton">
            <property name="text">
             <string>Delete</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localUpButton">
            <property name="text">
             <string>Up</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localDownButton">
            <property name="text">
             <string>Down</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QTableView" name="webHistoryTable"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="webHistoryButtonBar">
          <item>
           <widget class="QPushButton" name="webAddButton">
            <property name="text">
             <string>Add</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webEditButton">
            <property name="text">
             <string>Edit</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webDeleteButton">
            <property name="text">
             <string>Delete</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webUpButton">
            <property name="text">
             <string>Up</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webDownButton">
            <property name="text">
             <string>Down</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabTerminal">
       <attribute name="title">
        <string>Terminal</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_terminal">
        <item>
         <widget class="QPlainTextEdit" name="terminalOutput"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_terminal">
          <item>
           <widget class="QLineEdit" name="commandInput"/>
          </item>
          <item>
           <widget class="QPushButton" name="runCommandBtn">
            <property name="text">
             <string>Run Command</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="clearTerminalBtn">
            <property name="text">
             <string>Clear</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabPackageManager">
       <attribute name="title">
        <string>Package Manager</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_packageManager">
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_packageManager">
          <item>
           <widget class="QLineEdit" name="packageNameInput"/>
          </item>
          <item>
           <widget class="QPushButton" name="searchPackageBtn">
            <property name="text">
             <string>Search</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="installPackageBtn">
            <property name="text">
             <string>Install</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="uninstallPackageBtn">
            <property name="text">
             <string>Uninstall</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QListWidget" name="installedPackagesList"/>
        </item>
        <item>
         <widget class="QPlainTextEdit" name="packageOutput"/>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabSettings">
       <attribute name="title">
        <string>Settings</string>
       </attribute>
       <layout class="QVBoxLayout" name="settingsLayout">
        <item>
         <layout class="QFormLayout" name="formLayout">
          <item row="0" column="0">
           <widget class="QLabel" name="labelPythonVersion">
            <property name="text">
             <string>Python version:</string>
            </property>
           </widget>
          </item>
          <item row="0" column="1">
           <widget class="QLineEdit" name="pythonVersionEdit"/>
          </item>
          <item row="1" column="0">
           <widget class="QLabel" name="labelPipVersion">
            <property name="text">
             <string>pip version:</string>
            </property>
           </widget>
          </item>
          <item row="1" column="1">
           <widget class="QLineEdit" name="pipVersionEdit"/>
          </item>
          <item row="2" column="0">
           <widget class="QLabel" name="labelPipToolsVersion">
            <property name="text">
             <string>pip-tools version:</string>
            </property>
           </widget>
          </item>
          <item row="2" column="1">
           <widget class="QLineEdit" name="pipToolsVersionEdit"/>
          </item>
          <item row="3" column="0">
           <widget class="QLabel" name="labelMaxItems">
            <property name="text">
             <string>Maximum number of items:</string>
            </property>
           </widget>
          </item>
          <item row="3" column="1">
           <layout class="QHBoxLayout" name="spinMaxItemsLayout">
            <item>
             <widget class="QSpinBox" name="spinMaxItems">
              <property name="toolTip">
               <string>-1 = unlimited, 0 not allowed, â‰¥1 valid</string>
              </property>
              <property name="minimum">
               <number>-1</number>
              </property>
              <property name="maximum">
               <number>2147483647</number>
              </property>
              <property name="value">
               <number>10</number>
              </property>
             </widget>
            </item>
            <item>
             <spacer name="spinMaxItemsSpacer">
              <property name="orientation">
               <enum>Qt::Orientation::Horizontal</enum>
              </property>
              <property name="sizeType">
               <enum>QSizePolicy::Policy::Expanding</enum>
              </property>
              <property name="sizeHint" stdset="0">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
             </spacer>
            </item>
           </layout>
          </item>
          <item row="4" column="0">
           <widget class="QLabel" name="labelGpuDetected">
            <property name="text">
             <string>GPU Detected:</string>
            </property>
           </widget>
          </item>
          <item row="4" column="1">
           <widget class="QCheckBox" name="gpuDetectedCheckBox">
            <property name="enabled">
             <bool>false</bool>
            </property>
           </widget>
          </item>
          <item row="5" column="0">
           <widget class="QLabel" name="labelUseCpu">
            <property name="text">
             <string>Use CPU:</string>
            </property>
           </widget>
          </item>
          <item row="5" column="1">
           <widget class="QCheckBox" name="useCpuCheckBox"/>
          </item>
          <item row="6" column="0">
           <widget class="QLabel" name="labelCuda">
            <property name="text">
             <string>Cuda:</string>
            </property>
           </widget>
          </item>
          <item row="6" column="1">
           <widget class="QCheckBox" name="cudaCheckBox"/>
          </item>
          <item row="7" column="0">
           <widget class="QLabel" name="labelOs">
            <property name="text">
             <string>OS:</string>
            </property>
           </widget>
          </item>
          <item row="7" column="1">
           <widget class="QLineEdit" name="osEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="8" column="0">
           <widget class="QLabel" name="labelOsRelease">
            <property name="text">
             <string>Release:</string>
            </property>
           </widget>
          </item>
          <item row="8" column="1">
           <widget class="QLineEdit" name="osReleaseEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="9" column="0">
           <widget class="QLabel" name="labelOsVersion">
            <property name="text">
             <string>Version:</string>
            </property>
           </widget>
          </item>
          <item row="9" column="1">
           <widget class="QLineEdit" name="osVersionEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QPushButton" name="saveSettingsButton">
          <property name="text">
           <string>Save Settings</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="restoreDefaultsButton">
          <property name="text">
           <string>Restore Defaults</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QDialogButtonBox" name="buttonBoxPreferences">
          <property name="standardButtons">
           <set>QDialogButtonBox::StandardButton::Apply|QDialogButtonBox::StandardButton::Cancel|QDialogButtonBox::StandardButton::Ok</set>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>900</width>
     <height>20</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>&amp;File</string>
    </property>
    <addaction name="actionOpenRequirements"/>
    <addaction name="actionFetchRequirements"/>
    <addaction name="separator"/>
    <addaction name="actionExit"/>
   </widget>
   <widget class="QMenu" name="menuTools">
    <property name="title">
     <string>&amp;Tools</string>
    </property>
    <addaction name="actionCreateVenv"/>
    <addaction name="actionResolveMatrix"/>
    <addaction name="actionPause"/>
    <addaction name="actionResume"/>
    <addaction name="actionStop"/>
   </widget>
   <widget class="QMenu" name="menuBatch">
    <property name="title">
     <string>&amp;Batch</string>
    </property>
    <addaction name="actionRunBatch"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>&amp;Help</string>
    </property>
    <addaction name="actionAbout"/>
    <addaction name="actionViewReadme"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuTools"/>
   <addaction name="menuBatch"/>
   <addaction name="menuHelp"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="mainToolBar">
   <property name="windowTitle">
    <string>Main Toolbar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="actionOpenRequirements"/>
   <addaction name="actionFetchRequirements"/>
   <addaction name="actionCreateVenv"/>
   <addaction name="actionResolveMatrix"/>
   <addaction name="actionPause"/>
   <addaction name="actionResume"/>
   <addaction name="actionStop"/>
   <addaction name="actionRunBatch"/>
   <addaction name="actionAbout"/>
   <addaction name="actionViewReadme"/>
  </widget>
  <action name="actionOpenRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/open.svg</normaloff>:/icons/icons/open.svg</iconset>
   </property>
   <property name="text">
    <string>Open requirements file...</string>
   </property>
  </action>
  <action name="actionFetchRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/url.svg</normaloff>:/icons/icons/url.svg</iconset>
   </property>
   <property name="text">
    <string>Fetch requirements from URL...</string>
   </property>
  </action>
  <action name="actionExit">
   <property name="text">
    <string>Exit</string>
   </property>
  </action>
  <action name="actionCreateVenv">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/venv.svg</normaloff>:/icons/icons/venv.svg</iconset>
   </property>
   <property name="text">
    <string>Create/Update venv</string>
   </property>
  </action>
  <action name="actionResolveMatrix">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resolve.svg</normaloff>:/icons/icons/resolve.svg</iconset>
   </property>
   <property name="text">
    <string>Resolve matrix</string>
   </property>
  </action>
  <action name="actionPause">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/pause.svg</normaloff>:/icons/icons/pause.svg</iconset>
   </property>
   <property name="text">
    <string>Pause</string>
   </property>
  </action>
  <action name="actionResume">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resume.svg</normaloff>:/icons/icons/resume.svg</iconset>
   </property>
   <property name="text">
    <string>Resume</string>
   </property>
  </action>
  <action name="actionStop">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/stop.svg</normaloff>:/icons/icons/stop.svg</iconset>
   </property>
   <property name="text">
    <string>Stop</string>
   </property>
  </action>
  <action name="actionRunBatch">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/batch.svg</normaloff>:/icons/icons/batch.svg</iconset>
   </property>
   <property name="text">
    <string>Run batch</string>
   </property>
  </action>
  <action name="actionAbout">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/info.svg</normaloff>:/icons/icons/info.svg</iconset>
   </property>
   <property name="text">
    <string>About</string>
   </property>
  </action>
  <action name="actionViewReadme">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/readme.svg</normaloff>:/icons/icons/readme.svg</iconset>
   </property>
   <property name="text">
    <string>View README</string>
   </property>
  </action>
  <action name="separator">
   <property name="separator" stdset="0">
    <bool>true</bool>
   </property>
  </action>
 </widget>
 <resources>
  <include location="../PipMatrixResolverQt.qrc"/>
 </resources>
 <connections/>
</ui>

#-------------------------------------------------------------------------------
# File: src/Settings.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file Settings.cpp
 * @brief Implements the Settings persistence and accessors.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.6 [Increment]
 * @date    2025-11-06 [Todays date]
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * This file implements the Settings class using QSettings for
 * persistence. It ensures centralized defaults and onboarding
 * parity for the Python interpreter command resolution.
 ***************************************************************/
#include "Settings.h"
#include "Constants.h"
#include <QSettings>

Settings* Settings::instance()
{
    static Settings s;
    return &s;
}

Settings::Settings()
{
    QSettings qset;
    m_pythonInterpreter = qset.value(
                                  QStringLiteral("PythonInterpreter"),
                                  DEFAULT_PYTHON_INTERPRETER()
                                  ).toString();
}

QString Settings::pythonInterpreter() const
{
    return m_pythonInterpreter;
}

QString Settings::defaultPythonInterpreter() const
{
    return DEFAULT_PYTHON_INTERPRETER();
}

void Settings::setPythonInterpreter(const QString& command)
{
    m_pythonInterpreter = command;
    QSettings qset;
    qset.setValue(QStringLiteral("PythonInterpreter"), command);
}

/************** End of Settings.cpp **************************/

#-------------------------------------------------------------------------------
# File: src/Settings.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file Settings.h
 * @brief Settings API providing source of truth for configuration.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.6 [Increment]
 * @date    2025-11-06 [Todays date]
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * This file declares the Settings class that centralizes access
 * to persistent configuration, including the Python interpreter
 * command used at runtime and shown in onboarding UI.
 ***************************************************************/
#pragma once
#include <QString>

class QSettings;

/****************************************************************
 * @class Settings
 * @brief Centralized configuration backed by QSettings.
 ***************************************************************/
class Settings
{
public:
    /****************************************************************
     * @brief Singleton accessor.
     * @return Pointer to the Settings instance.
     ***************************************************************/
    static Settings* instance();

    /****************************************************************
     * @brief Returns the user-configured Python interpreter command.
     * @return Configured Python interpreter command (name or path).
     ***************************************************************/
    QString pythonInterpreter() const;

    /****************************************************************
     * @brief Returns the project-wide default interpreter command.
     * @return Default Python interpreter command (platform-aware).
     ***************************************************************/
    QString defaultPythonInterpreter() const;

    /****************************************************************
     * @brief Updates the interpreter command and persists the value.
     * @param command Interpreter command (name or absolute path).
     ***************************************************************/
    void setPythonInterpreter(const QString& command);

private:
    /****************************************************************
     * @brief Constructs Settings and loads persisted values.
     ***************************************************************/
    Settings();

private:
    QString m_pythonInterpreter;
};

/************** End of Settings.h **************************/

#-------------------------------------------------------------------------------
# File: src/TerminalEngine.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file TerminalEngine.cpp
 * @brief Implements the TerminalEngine class for terminal operations.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.8
 * @date    2025-11-04
 * @section License MIT
 * @section DESCRIPTION
 * This file contains the implementation of TerminalEngine class.
 ***************************************************************/
#include "TerminalEngine.h"
#include <QFileInfo>
#include <QDebug>
#include <QCoreApplication>
#include <QStandardPaths>
#include <QMessageBox>
#include <QDesktopServices>
#include <QSettings>
#include <QUrl>
#include <QPushButton>
#include <QProcess>
#include "Settings.h"        // central source of truth
#include "Config.h"

#define SHOW_DEBUG 1

// Static globals
QString TerminalEngine::g_pythonExe;
QStringList TerminalEngine::g_pythonBaseArgs;
/****************************************************************
 * @brief Constructor: Initializes the terminal engine.
 ***************************************************************/
TerminalEngine::TerminalEngine(QObject *parent) : QObject(parent), currentProcess(nullptr)
{
    venvPath = QDir::current().filePath(".venv");
}

/****************************************************************
 * @brief Destructor: Cleans up resources.
 ***************************************************************/
TerminalEngine::~TerminalEngine()
{
    if (currentProcess)
    {
        if (currentProcess->state() != QProcess::NotRunning)
        {
            currentProcess->kill();
            currentProcess->waitForFinished();
        }
        delete currentProcess;
    }
}

/****************************************************************
 * @brief Sets the virtual environment path.
 ***************************************************************/
void TerminalEngine::setVenvPath(const QString &path)
{
    venvPath = path;
}

/****************************************************************
 * @brief Gets the current virtual environment path.
 ***************************************************************/
QString TerminalEngine::getVenvPath() const
{
    return venvPath;
}

/****************************************************************
 * @brief Sets the global Python command based on Settings version.
 *        Validates actual interpreter version and warns if mismatch.
 * @param versionFromSettings Version string (e.g., "3.10 or 3.11").
 ***************************************************************/
/****************************************************************
 * @brief Sets the Python command based on Settings or defaults.
 *        Probes the actual interpreter version and handles
 *        mismatches by prompting the user to install or switch.
 *
 * @param versionFromSettings The Python version string from Settings.
 ***************************************************************/
void TerminalEngine::setPythonCommand(const QString &versionFromSettings)
{
    g_pythonExe.clear();
    g_pythonBaseArgs.clear();

#ifdef Q_OS_WIN
    QString pyPath = QStandardPaths::findExecutable("py");
    if (!pyPath.isEmpty())
    {
        g_pythonExe = pyPath;
        g_pythonBaseArgs << (versionFromSettings.isEmpty() ? "-3" : "-" + versionFromSettings);
    }
    else
    {
        QString pythonPath = QStandardPaths::findExecutable("python");
        g_pythonExe = pythonPath.isEmpty() ? "python" : pythonPath;
    }
#else
    g_pythonExe = versionFromSettings.isEmpty()
                      ? "python3"
                      : QString("python%1").arg(versionFromSettings);
#endif

    // Probe actual version
    QProcess proc;
    proc.start(g_pythonExe, g_pythonBaseArgs + QStringList{"--version"});
    proc.waitForFinished(3000);
    QString output = QString::fromUtf8(proc.readAllStandardOutput()).trimmed();

    if (!versionFromSettings.isEmpty() && !output.contains(versionFromSettings))
    {
        // Detect available versions
        QStringList detectedVersions;
        QStringList candidates = {"python3.10", "python3.11", "python3.12", "python3.13", "python"};

        // FIX: use index-based loop to avoid detach warning
        for (int i = 0; i < candidates.size(); ++i)
        {
            const QString &candidate = candidates.at(i);
            QString exe = QStandardPaths::findExecutable(candidate);
            if (!exe.isEmpty())
            {
                QProcess p;
                p.start(exe, {"--version"});
                p.waitForFinished(2000);
                QString verOut = QString::fromUtf8(p.readAllStandardOutput()).trimmed();
                if (!verOut.isEmpty())
                {
                    detectedVersions << verOut;
                }
            }
        }

        // Load configured default version from Settings
        QSettings settings;
        QString defaultVersion = settings.value("PythonVersion", "3.10").toString();

        QMessageBox msgBox;
        msgBox.setWindowTitle(tr("Python Version Mismatch"));
        msgBox.setText(tr("Requested Python %1, but found %2.")
                           .arg(versionFromSettings, output));
        msgBox.setInformativeText(tr("Choose an action:"));

        QPushButton *installBtn = msgBox.addButton(
            tr("Install Python %1").arg(defaultVersion),
            QMessageBox::ActionRole);

        QVector<QPushButton*> switchButtons;
        for (int i = 0; i < detectedVersions.size(); ++i)
        {
            const QString &ver = detectedVersions.at(i);
            QPushButton *btn = msgBox.addButton(
                tr("Switch default to %1").arg(ver),
                QMessageBox::ActionRole);
            switchButtons.append(btn);
        }

        msgBox.addButton(QMessageBox::Cancel);
        msgBox.exec();

        if (msgBox.clickedButton() == installBtn)
        {
            // Build installer URL dynamically
            QString installerUrl = QString("https://www.python.org/ftp/python/%1.0/python-%1.0-amd64.exe")
                                       .arg(defaultVersion);
            QDesktopServices::openUrl(QUrl(installerUrl));

            // Update Settings to reflect chosen default
            settings.setValue("PythonVersion", defaultVersion);
            settings.sync();
        }
        else
        {
            for (int i = 0; i < switchButtons.size(); ++i)
            {
                if (msgBox.clickedButton() == switchButtons[i])
                {
                    QString chosenVersion = detectedVersions[i].section(' ', 1, 1);
                    settings.setValue("PythonVersion", chosenVersion);
                    settings.sync();

                    // Reâ€‘apply with new version
                    TerminalEngine::setPythonCommand(chosenVersion);
                    break;
                }
            }
        }
    }

    DEBUG_MSG() << "[DEBUG] setPythonCommand resolved:" << g_pythonExe << g_pythonBaseArgs << "Reported:" << output;
}

/****************************************************************
 * @brief Returns base args (e.g., -3.11).
 ***************************************************************/
QStringList TerminalEngine::pythonBaseArgs()
{
    return g_pythonBaseArgs;
}

/****************************************************************
 * @brief Creates a Python virtual environment and upgrades pip/pip-tools.
 *        Handles both Windows launcher (py.exe) and direct python.exe.
 *        Removes any existing venv first, then runs the command.
 *
 * @param pythonVersion Version selector (e.g. "-3.10") if using py.exe
 * @return true if venv created successfully, false otherwise
 ***************************************************************/
bool TerminalEngine::createVirtualEnvironment(const QString &pythonVersion)
{
    DEBUG_MSG() << "Enter createVirtualEnvironment()";
    DEBUG_MSG() << "Target venv path:" << venvPath;

    emit venvProgress("Checking for existing virtual environment...");

    if (venvExists())
    {
        DEBUG_MSG() << "Existing venv found, removing...";
        if (!removeVirtualEnvironment())
        {
            emit outputReceived("Failed to remove existing virtual environment", true);
            return false;
        }
    }

    QString pythonExe = pythonCommand();
    QStringList args = pythonBaseArgs();

    if (pythonExe.contains("py.exe", Qt::CaseInsensitive) && !pythonVersion.isEmpty())
    {
        DEBUG_MSG() << "Detected py.exe â†’ adding version selector:" << pythonVersion;
        args << pythonVersion << "-m" << "venv" << venvPath;
    }
    else
    {
        DEBUG_MSG() << "Detected direct python interpreter â†’ no version selector";
        args << "-m" << "venv" << venvPath;
    }

    DEBUG_MSG() << "Using Python executable:" << pythonExe;
    DEBUG_MSG() << "Command line:" << pythonExe << args;

    QProcess process;
    process.setProcessChannelMode(QProcess::MergedChannels);
    process.start(pythonExe, args);

    if (!process.waitForStarted(5000))
    {
        emit outputReceived("Failed to start Python process", true);
        return false;
    }

    bool finished = process.waitForFinished(60000);

    QString stdOut = QString::fromUtf8(process.readAllStandardOutput());
    QString stdErr = QString::fromUtf8(process.readAllStandardError());

    DEBUG_MSG() << "Process finished:" << finished
                << " Exit code:" << process.exitCode()
                << " Exit status:" << process.exitStatus()
                << " Error:" << process.error();
    DEBUG_MSG() << "StdOut:" << stdOut;
    DEBUG_MSG() << "StdErr:" << stdErr;

    if (!finished || process.exitCode() != 0 || !venvExists())
    {
        emit outputReceived(QString("Failed to create virtual environment: %1").arg(stdErr), true);
        return false;
    }

    emit venvProgress("Virtual environment created successfully");

    // ðŸ”§ NEW STEP: upgrade pip and install pip-tools
    QString venvPython = venvPath + "/Scripts/python.exe"; // Windows path
    QStringList upgradeArgs;
    upgradeArgs << "-m" << "pip" << "install" << "--upgrade" << "pip" << "pip-tools";

    DEBUG_MSG() << "Upgrading pip and installing pip-tools...";
    QProcess upgradeProc;
    upgradeProc.setProcessChannelMode(QProcess::MergedChannels);
    upgradeProc.start(venvPython, upgradeArgs);
    upgradeProc.waitForFinished(60000);

    QString upgradeOut = QString::fromUtf8(upgradeProc.readAllStandardOutput());
    QString upgradeErr = QString::fromUtf8(upgradeProc.readAllStandardError());

    DEBUG_MSG() << "Upgrade StdOut:" << upgradeOut;
    DEBUG_MSG() << "Upgrade StdErr:" << upgradeErr;

    if (upgradeProc.exitCode() != 0)
    {
        emit outputReceived(QString("pip upgrade failed: %1").arg(upgradeErr), true);
        return false;
    }

    emit venvProgress("pip and pip-tools upgraded successfully");
    return true;
}

/****************************************************************
 * @brief Attempts to activate the virtual environment by probing python.
 * @return true if activation succeeds, false otherwise.
 ***************************************************************/
bool TerminalEngine::activateVenv()
{
    DEBUG_MSG() << "Enter activateVenv()";

    // Use global Python command resolved at startup
    QString pythonExe = TerminalEngine::pythonCommand();
    QStringList args = TerminalEngine::pythonBaseArgs();
    args << "--version";

    DEBUG_MSG() << "Activation probe:" << pythonExe << args;

    QProcess proc;
    proc.start(pythonExe, args);

    if (!proc.waitForStarted(5000))
    {
        DEBUG_MSG() << "Activation probe failed to start:" << proc.errorString();
        return false;
    }

    bool finished = proc.waitForFinished(10000);
    QString stdOut = QString::fromUtf8(proc.readAllStandardOutput());
    QString stdErr = QString::fromUtf8(proc.readAllStandardError());

    DEBUG_MSG() << "Finished:" << finished
                          << "Exit code:" << proc.exitCode()
                          << "StdOut:" << stdOut
                          << "StdErr:" << stdErr;

    if (!finished || proc.exitCode() != 0)
    {
        return false;
    }

    // If we got a version string back, consider activation successful
    return !stdOut.isEmpty() || !stdErr.isEmpty();
}


/****************************************************************
 * @brief Gets venv status information.
 * @return Status string describing venv state.
 ***************************************************************/
QString TerminalEngine::getVenvStatus() const
{
    if (!venvExists())
    {
        return QString("venv: missing (%1)").arg(venvPath);
    }

    QFileInfo pyInfo(getPythonExecutable());
    QFileInfo pipInfo(getPipExecutable());

    QStringList parts;
    parts << QString("venv: present (%1)").arg(venvPath);
    parts << QString("python: %1 %2").arg(pyInfo.exists() ? "OK" : "MISSING").arg(pyInfo.filePath());
    parts << QString("pip: %1 %2").arg(pipInfo.exists() ? "OK" : "MISSING").arg(pipInfo.filePath());

    return parts.join(" | ");
}

/****************************************************************
 * @brief Checks if virtual environment exists.
 ***************************************************************/
bool TerminalEngine::venvExists() const
{
    QFileInfo venvInfo(venvPath);
    if (!venvInfo.exists() || !venvInfo.isDir())
    {
        return false;
    }

    // Check for Python executable
    QString pythonExe = getPythonExecutable();
    QFileInfo pythonInfo(pythonExe);
    return pythonInfo.exists() && pythonInfo.isFile();
}

/****************************************************************
 * @brief Upgrades pip inside the virtual environment.
 * @return true if successful, false otherwise.
 ***************************************************************/
bool TerminalEngine::upgradePip()
{
    QStringList args = TerminalEngine::pythonBaseArgs();
    args << "-m" << "pip" << "install" << "--upgrade" << "pip";
    QString pythonExe = TerminalEngine::pythonCommand();

    DEBUG_MSG() << "Upgrading pip with:" << pythonExe << args;

    QProcess proc;
    proc.start(pythonExe, args);
    proc.waitForFinished(30000);

    DEBUG_MSG() << "Exit code:" << proc.exitCode() << "StdErr:" << QString::fromUtf8(proc.readAllStandardError());

    return proc.exitCode() == 0;
}

/****************************************************************
 * @brief Installs pip-tools in the virtual environment.
 ***************************************************************/
bool TerminalEngine::installPipTools(const QString &version)
{
    if (!venvExists())
    {
        emit outputReceived("Virtual environment does not exist", true);
        return false;
    }

    QString pythonExe = getPythonExecutable();
    QStringList args;
    args << "-m" << "pip" << "install";

    if (version.isEmpty())
    {
        args << "pip-tools";
    }
    else
    {
        args << QString("pip-tools==%1").arg(version);
    }

    QProcess process;
    process.start(pythonExe, args);
    process.waitForFinished(120000); // 2 minute timeout

    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();

    emit outputReceived(output, false);
    if (!error.isEmpty())
    {
        emit outputReceived(error, true);
    }

    return process.exitCode() == 0;
}

/****************************************************************
 * @brief Executes a command in the terminal.
 ***************************************************************/
void TerminalEngine::executeCommand(const QString &command)
{
    QString cmd = command.trimmed();
    if (cmd.isEmpty())
    {
        emit outputReceived("No command entered", true);
        return;
    }

    currentCommand = cmd;
    emit commandStarted(currentCommand);

    logMessage(QString("$ %1").arg(currentCommand));

    parseAndExecuteCommand(currentCommand);
}

/****************************************************************
 * @brief Stops the currently running process.
 ***************************************************************/
void TerminalEngine::stopCurrentProcess()
{
    if (currentProcess && currentProcess->state() != QProcess::NotRunning)
    {
        emit outputReceived("Terminating process...", false);
        currentProcess->kill();
        currentProcess->waitForFinished();
        emit outputReceived("Process terminated", false);
    }
}

/****************************************************************
 * @brief Gets the Python executable path for the venv.
 ***************************************************************/
QString TerminalEngine::getPythonExecutable() const
{
#if defined(Q_OS_WIN)
    return QDir(venvPath).filePath("Scripts/python.exe");
#else
    return QDir(venvPath).filePath("bin/python");
#endif
}

/****************************************************************
 * @brief Gets the pip executable path for the venv.
 ***************************************************************/
QString TerminalEngine::getPipExecutable() const
{
#if defined(Q_OS_WIN)
    return QDir(venvPath).filePath("Scripts/pip.exe");
#else
    return QDir(venvPath).filePath("bin/pip");
#endif
}

/****************************************************************
 * @brief Slot for standard output ready.
 ***************************************************************/
void TerminalEngine::onReadyReadStandardOutput()
{
    if (currentProcess)
    {
        QString output = QString::fromUtf8(currentProcess->readAllStandardOutput());
        emit outputReceived(output, false);
    }
}

/****************************************************************
 * @brief Slot for standard error ready.
 ***************************************************************/
void TerminalEngine::onReadyReadStandardError()
{
    if (currentProcess)
    {
        QString error = QString::fromUtf8(currentProcess->readAllStandardError());
        emit outputReceived(error, true);
    }
}

/****************************************************************
 * @brief Slot for process finished.
 ***************************************************************/
void TerminalEngine::onProcessFinished(int exitCode, QProcess::ExitStatus exitStatus)
{
    if (exitStatus == QProcess::CrashExit)
    {
        emit outputReceived("Process crashed", true);
    }
    else if (exitCode != 0)
    {
        emit outputReceived(QString("Process exited with code %1").arg(exitCode), true);
    }

    emit commandFinished(exitCode, exitStatus);
}

/****************************************************************
 * @brief Slot for process error.
 ***************************************************************/
void TerminalEngine::onProcessError(QProcess::ProcessError error)
{
    QString errorMsg;
    switch (error)
    {
    case QProcess::FailedToStart:
        errorMsg = "Failed to start process";
        break;
    case QProcess::Crashed:
        errorMsg = "Process crashed";
        break;
    case QProcess::Timedout:
        errorMsg = "Process timed out";
        break;
    case QProcess::WriteError:
        errorMsg = "Write error";
        break;
    case QProcess::ReadError:
        errorMsg = "Read error";
        break;
    default:
        errorMsg = "Unknown error";
        break;
    }

    emit outputReceived(errorMsg, true);
}

/****************************************************************
 * @brief Parses and routes the command to appropriate handler.
 ***************************************************************/
void TerminalEngine::parseAndExecuteCommand(const QString &command)
{
    // Make a copy to ensure we have a stable string
    QString cmd = command;

    // Check for pip commands
    if (cmd.startsWith("pip "))
    {
        QStringList parts = cmd.split(' ', Qt::SkipEmptyParts);
        parts.removeFirst(); // Remove "pip"
        executePipCommand(parts);
    }
    // Check for pip-compile
    else if (cmd.startsWith("pip-compile"))
    {
        QStringList parts = cmd.split(' ', Qt::SkipEmptyParts);
        parts.removeFirst(); // Remove "pip-compile"
        executePipToolsCommand("compile", parts);
    }
    // Check for pip-sync
    else if (cmd.startsWith("pip-sync"))
    {
        QStringList parts = cmd.split(' ', Qt::SkipEmptyParts);
        parts.removeFirst(); // Remove "pip-sync"
        executePipToolsCommand("sync", parts);
    }
    // Check for python commands
    else if (cmd.startsWith("python "))
    {
        QStringList parts = cmd.split(' ', Qt::SkipEmptyParts);
        parts.removeFirst(); // Remove "python"
        executePythonScript(parts);
    }
    // Check for venv activation (informational only)
    else if (cmd == "activate" || cmd.contains("activate"))
    {
        emit outputReceived("Note: Virtual environment is automatically active in this terminal", false);
        emit outputReceived(QString("Using venv: %1").arg(venvPath), false);
        emit commandFinished(0, QProcess::NormalExit);
    }
    // Check for deactivate (informational only)
    else if (cmd == "deactivate")
    {
        emit outputReceived("Note: Virtual environment cannot be deactivated in this terminal", false);
        emit commandFinished(0, QProcess::NormalExit);
    }
    // Shell commands
    else
    {
        executeShellCommand(cmd);
    }
}

/****************************************************************
 * @brief Executes a pip command.
 ***************************************************************/
void TerminalEngine::executePipCommand(const QStringList &args)
{
    if (!venvExists())
    {
        emit outputReceived("Virtual environment does not exist. Create one first.", true);
        emit commandFinished(1, QProcess::NormalExit);
        return;
    }

    if (currentProcess)
    {
        delete currentProcess;
    }

    currentProcess = new QProcess(this);
    connect(currentProcess, &QProcess::readyReadStandardOutput, this, &TerminalEngine::onReadyReadStandardOutput);
    connect(currentProcess, &QProcess::readyReadStandardError, this, &TerminalEngine::onReadyReadStandardError);
    connect(currentProcess, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            this, &TerminalEngine::onProcessFinished);
    connect(currentProcess, &QProcess::errorOccurred, this, &TerminalEngine::onProcessError);

    QString pythonExe = getPythonExecutable();
    QStringList fullArgs;
    fullArgs << "-m" << "pip" << args;

    currentProcess->start(pythonExe, fullArgs);
}

/****************************************************************
 * @brief Executes a pip-tools command.
 ***************************************************************/
void TerminalEngine::executePipToolsCommand(const QString &tool, const QStringList &args)
{
    if (!venvExists())
    {
        emit outputReceived("Virtual environment does not exist. Create one first.", true);
        emit commandFinished(1, QProcess::NormalExit);
        return;
    }

    if (currentProcess)
    {
        delete currentProcess;
    }

    currentProcess = new QProcess(this);
    connect(currentProcess, &QProcess::readyReadStandardOutput, this, &TerminalEngine::onReadyReadStandardOutput);
    connect(currentProcess, &QProcess::readyReadStandardError, this, &TerminalEngine::onReadyReadStandardError);
    connect(currentProcess, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            this, &TerminalEngine::onProcessFinished);
    connect(currentProcess, &QProcess::errorOccurred, this, &TerminalEngine::onProcessError);

    QString pythonExe = getPythonExecutable();
    QStringList fullArgs;
    fullArgs << "-m" << "piptools" << tool << args;

    currentProcess->start(pythonExe, fullArgs);
}

/****************************************************************
 * @brief Executes a Python script.
 ***************************************************************/
void TerminalEngine::executePythonScript(const QStringList &args)
{
    if (!venvExists())
    {
        emit outputReceived("Virtual environment does not exist. Create one first.", true);
        emit commandFinished(1, QProcess::NormalExit);
        return;
    }

    if (currentProcess)
    {
        delete currentProcess;
    }

    currentProcess = new QProcess(this);
    connect(currentProcess, &QProcess::readyReadStandardOutput, this, &TerminalEngine::onReadyReadStandardOutput);
    connect(currentProcess, &QProcess::readyReadStandardError, this, &TerminalEngine::onReadyReadStandardError);
    connect(currentProcess, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            this, &TerminalEngine::onProcessFinished);
    connect(currentProcess, &QProcess::errorOccurred, this, &TerminalEngine::onProcessError);

    QString pythonExe = getPythonExecutable();
    currentProcess->start(pythonExe, args);
}

/****************************************************************
 * @brief Executes a shell command.
 ***************************************************************/
void TerminalEngine::executeShellCommand(const QString &command)
{
    if (currentProcess)
    {
        delete currentProcess;
    }

    currentProcess = new QProcess(this);
    connect(currentProcess, &QProcess::readyReadStandardOutput, this, &TerminalEngine::onReadyReadStandardOutput);
    connect(currentProcess, &QProcess::readyReadStandardError, this, &TerminalEngine::onReadyReadStandardError);
    connect(currentProcess, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            this, &TerminalEngine::onProcessFinished);
    connect(currentProcess, &QProcess::errorOccurred, this, &TerminalEngine::onProcessError);

    QString shell = getShell();
    QStringList shellArgs = getShellArgs(command);

    currentProcess->start(shell, shellArgs);
}

/****************************************************************
 * @brief Removes existing virtual environment.
 ***************************************************************/
bool TerminalEngine::removeVirtualEnvironment()
{
    if (!venvExists())
    {
        return true; // Already doesn't exist
    }

    QDir venvDir(venvPath);
    return venvDir.removeRecursively();
}

/****************************************************************
 * @brief Gets the platform-specific shell.
 ***************************************************************/
QString TerminalEngine::getShell() const
{
#if defined(Q_OS_WIN)
    return "cmd.exe";
#else
    return "bash";
#endif
}

/****************************************************************
 * @brief Gets shell arguments for command execution.
 ***************************************************************/
QStringList TerminalEngine::getShellArgs(const QString &command) const
{
    QStringList args;
#if defined(Q_OS_WIN)
    args << "/C" << command;
#else
    args << "-c" << command;
#endif
    return args;
}

/****************************************************************
 * @brief Logs a message with timestamp.
 ***************************************************************/
void TerminalEngine::logMessage(const QString &message, bool isError)
{
    QString timestamp = QDateTime::currentDateTime().toString("[HH:mm:ss]");
    emit outputReceived(QString("%1 %2").arg(timestamp, message), isError);
}

bool TerminalEngine::isCommandRunnable(const QString& command) const
{
    QProcess proc;
    QStringList args;
    args << QStringLiteral("--version");

    proc.start(command, args);
    bool started = proc.waitForStarted(3000);
    if (!started)
    {
        return false;
    }

    bool finished = proc.waitForFinished(5000);
    if (!finished)
    {
        proc.kill();
        proc.waitForFinished(2000);
        return false;
    }

    int exitCode = proc.exitCode();
    return (exitCode == 0);
}

QString TerminalEngine::pythonCommand() const
{
    const QString configured = Settings::instance()->pythonInterpreter();

    if (isCommandRunnable(configured))
    {
        return configured;
    }

    qWarning() << "Configured Python interpreter not runnable:" << configured;

    const QString fallback = Settings::instance()->defaultPythonInterpreter();
    if (isCommandRunnable(fallback))
    {
        qInfo() << "Falling back to default Python interpreter:" << fallback;
        return fallback;
    }

    qCritical() << "No valid Python interpreter found. Update Settings or install the required version.";
    return configured;
}

/****************************************************************
 * @brief Returns the path to the Python executable inside a venv.
 *        Handles Windows, Linux, and macOS layouts.
 ***************************************************************/
QString TerminalEngine::venvPythonPath(const QString& venvPath) const
{
#ifdef Q_OS_WIN
    return QDir(venvPath).filePath("Scripts/python.exe");
#else
    return QDir(venvPath).filePath("bin/python3");
#endif
}

/************** End of TerminalEngine.cpp ***********************/

#-------------------------------------------------------------------------------
# File: src/TerminalEngine.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file TerminalEngine.h
 * @brief Declares the TerminalEngine class for terminal operations.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.8
 * @date    2025-11-04
 * @section License MIT
 * @section DESCRIPTION
 * This file defines the TerminalEngine class for managing virtual
 * environments, executing commands, and handling terminal I/O.
 * Features:
 *   - Virtual environment creation and management
 *   - Cross-platform command execution
 *   - Real-time output streaming
 *   - Python, pip, and pip-tools command support
 *   - Shell command execution
 ***************************************************************/
#ifndef TERMINALENGINE_H
#define TERMINALENGINE_H

#include <QObject>
#include <QString>
#include <QProcess>
#include <QDir>
#include <QFile>
#include <QTextStream>
#include <QDateTime>

/****************************************************************
 * @class TerminalEngine
 * @brief Manages terminal operations and virtual environments.
 ***************************************************************/
class TerminalEngine : public QObject
{
    Q_OBJECT

public:
    explicit TerminalEngine(QObject *parent = nullptr);
    ~TerminalEngine();

    /****************************************************************
     * @brief Sets Python command globally.
     * @param Gets version From Settings.
     ***************************************************************/
    static void setPythonCommand(const QString &versionFromSettings);
    static QStringList pythonBaseArgs();
    /****************************************************************
     * @brief Sets the virtual environment path.
     * @param venvPath Absolute path to the virtual environment.
     ***************************************************************/
    void setVenvPath(const QString &venvPath);

    /****************************************************************
     * @brief Gets the current virtual environment path.
     * @return The virtual environment path.
     ***************************************************************/
    QString getVenvPath() const;

    /****************************************************************
     * @brief Creates a new virtual environment.
     * @param pythonVersion Python version to use (e.g., "3.11").
     * @return true if successful, false otherwise.
     ***************************************************************/
    bool createVirtualEnvironment(const QString &pythonVersion);

    /****************************************************************
     * @brief Checks if virtual environment exists.
     * @return true if venv exists, false otherwise.
     ***************************************************************/
    bool venvExists() const;

    /****************************************************************
     * @brief Activates an existing virtual environment.
     * @return true if successful, false otherwise.
     ***************************************************************/
    bool activateVenv();

    /****************************************************************
     * @brief Gets venv status information.
     * @return Status string describing venv state.
     ***************************************************************/
    QString getVenvStatus() const;

    /****************************************************************
     * @brief Upgrades pip in the virtual environment.
     * @return true if successful, false otherwise.
     ***************************************************************/
    bool upgradePip();

    /****************************************************************
     * @brief Installs pip-tools in the virtual environment.
     * @param version Specific pip-tools version or empty for latest.
     * @return true if successful, false otherwise.
     ***************************************************************/
    bool installPipTools(const QString &version = QString());

    /****************************************************************
     * @brief Executes a command in the terminal.
     * @param command The command to execute.
     ***************************************************************/
    void executeCommand(const QString &command);

    /****************************************************************
     * @brief Stops the currently running process.
     ***************************************************************/
    void stopCurrentProcess();

    /****************************************************************
     * @brief Gets the Python executable path for the venv.
     * @return Path to Python executable.
     ***************************************************************/
    QString getPythonExecutable() const;

    /****************************************************************
     * @brief Gets the pip executable path for the venv.
     * @return Path to pip executable.
     ***************************************************************/
    QString getPipExecutable() const;
    /****************************************************************
     * @brief Resolve the Python interpreter command for execution.
     * @return Validated Python interpreter command (name or path).
     ***************************************************************/
    QString pythonCommand() const;
    QString venvPythonPath(const QString &venvPath) const;
    QString venvPath;

signals:
    /****************************************************************
     * @brief Emitted when output is available.
     * @param output The output text.
     * @param isError true if error output, false for standard output.
     ***************************************************************/
    void outputReceived(const QString &output, bool isError);

    /****************************************************************
     * @brief Emitted when a command starts executing.
     * @param command The command being executed.
     ***************************************************************/
    void commandStarted(const QString &command);

    /****************************************************************
     * @brief Emitted when a command finishes.
     * @param exitCode The process exit code.
     * @param exitStatus The process exit status.
     ***************************************************************/
    void commandFinished(int exitCode, QProcess::ExitStatus exitStatus);

    /****************************************************************
     * @brief Emitted when venv creation progress updates.
     * @param message Progress message.
     ***************************************************************/
    void venvProgress(const QString &message);

private slots:
    void onReadyReadStandardOutput();
    void onReadyReadStandardError();
    void onProcessFinished(int exitCode, QProcess::ExitStatus exitStatus);
    void onProcessError(QProcess::ProcessError error);

private:
    /****************************************************************
     * @brief Checks if a command is runnable by invoking --version.
     * @param command Interpreter command (name or absolute path).
     * @return true if process starts and returns exit code 0.
     ***************************************************************/
    bool isCommandRunnable(const QString& command) const;
    /****************************************************************
     * @brief Parses and routes the command to appropriate handler.
     * @param command The command to parse.
     ***************************************************************/
    void parseAndExecuteCommand(const QString &command);

    /****************************************************************
     * @brief Executes a pip command.
     * @param args Arguments for pip command.
     ***************************************************************/
    void executePipCommand(const QStringList &args);

    /****************************************************************
     * @brief Executes a pip-tools command (pip-compile, pip-sync).
     * @param tool The tool name (compile or sync).
     * @param args Additional arguments.
     ***************************************************************/
    void executePipToolsCommand(const QString &tool, const QStringList &args);

    /****************************************************************
     * @brief Executes a Python script.
     * @param args Arguments including script path.
     ***************************************************************/
    void executePythonScript(const QStringList &args);

    /****************************************************************
     * @brief Executes a shell command.
     * @param command The shell command.
     ***************************************************************/
    void executeShellCommand(const QString &command);

    /****************************************************************
     * @brief Removes existing virtual environment.
     * @return true if successful, false otherwise.
     ***************************************************************/
    bool removeVirtualEnvironment();

    /****************************************************************
     * @brief Gets the platform-specific shell.
     * @return Shell executable name.
     ***************************************************************/
    QString getShell() const;

    /****************************************************************
     * @brief Gets shell arguments for command execution.
     * @param command The command to execute.
     * @return List of shell arguments.
     ***************************************************************/
    QStringList getShellArgs(const QString &command) const;

    /****************************************************************
     * @brief Logs a message with timestamp.
     * @param message The message to log.
     * @param isError true if error message.
     ***************************************************************/
    void logMessage(const QString &message, bool isError = false);

    QProcess *currentProcess;
    QString currentCommand;
    static QString g_pythonExe;
    static QStringList g_pythonBaseArgs;

};

#endif // TERMINALENGINE_H
/************** End of TerminalEngine.h *************************/

#-------------------------------------------------------------------------------
# File: src/main.cpp
#-------------------------------------------------------------------------------
#include <QApplication>
#include <QTranslator>
#include <QLocale>
#include <QFile>
#include <QIcon>
#include <QDebug>
#include "MainWindow.h"
#include "Config.h"

#define SHOW_DEBUG 0

int main(int argc, char *argv[])
{
    // Set app version before MainWindow is constructed
    MainWindow::appVersion = "0.1.3"; // or any version you wan

    QCoreApplication::setOrganizationName(MainWindow::kOrganizationName);
    QCoreApplication::setApplicationName(MainWindow::kApplicationName);

    QApplication theApplication(argc, argv);

    // Register compiled resources
    Q_INIT_RESOURCE(PipMatrixResolverQt);

    // Enable icons in menus globally
    theApplication.setAttribute(Qt::AA_DontShowIconsInMenus, false);

    // Set application icon
    QApplication::setWindowIcon(QIcon(":/icons/icons/app.svg"));

    // Diagnostics
    DEBUG_MSG() << "[RESOURCE CHECK] :/icons/icons/open.svg exists:" << QFile::exists(":/icons/icons/open.svg");
    // Translation loading
    const QString languageCode = QLocale::system().name().split('_').first();
    auto loadTranslator = [&](const QString &baseName) -> bool
    {
        QTranslator *tr = new QTranslator(&theApplication);
        const QString qmFile = QString(":/translations/%1_%2.qm").arg(baseName, languageCode);
        if (tr->load(qmFile))
        {
            theApplication.installTranslator(tr);
            qDebug() << "Loaded translation:" << qmFile;
            return true;
        }
        delete tr;
        return false;
    };

    loadTranslator("PipMatrixResolverQt");
    loadTranslator("MatrixUtility");
    loadTranslator("MatrixHistory");

    MainWindow w;
    w.show();
    return theApplication.exec();
}

#-------------------------------------------------------------------------------
# File: tests/gtest_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity)
{
    ResolverEngine engine;
    // Replace with a real method from your class
    EXPECT_TRUE(engine.isValid());
}

#-------------------------------------------------------------------------------
# File: tests/qt_test_main.cpp
#-------------------------------------------------------------------------------
#include <QTest>
#include "test_mainwindow.h"

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    int status = 0;
    status |= QTest::qExec(new TestMainWindow, argc, argv);
    return status;
}

#-------------------------------------------------------------------------------
# File: tests/qtest_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject {
    Q_OBJECT

private slots:
    void initTestCase() {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

QTEST_MAIN(TestMainWindow)
#include "qtest_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_main.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>

int main(int argc, char **argv) 
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

#-------------------------------------------------------------------------------
# File: tests/test_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase() 
    {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

#include "test_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity) 
{
    ResolverEngine engine;
    EXPECT_TRUE(engine.isValid());
}

# Directory Structure
#-------------------------------------------------------------------------------
â”œâ”€â”€ .qtcreator
â”‚   â”œâ”€â”€ qtc-cmake-presets-YJOCrMpg
â”‚   â””â”€â”€ CMakeLists.txt.user
â”œâ”€â”€ icons
â”‚   â”œâ”€â”€ app.svg
â”‚   â”œâ”€â”€ batch.svg
â”‚   â”œâ”€â”€ cancel.svg
â”‚   â”œâ”€â”€ info.svg
â”‚   â”œâ”€â”€ open.svg
â”‚   â”œâ”€â”€ pause.svg
â”‚   â”œâ”€â”€ readme.svg
â”‚   â”œâ”€â”€ resolve.svg
â”‚   â”œâ”€â”€ resume.svg
â”‚   â”œâ”€â”€ stop.svg
â”‚   â”œâ”€â”€ url.svg
â”‚   â””â”€â”€ venv.svg
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ CommandsTab.cpp
â”‚   â”œâ”€â”€ CommandsTab.h
â”‚   â”œâ”€â”€ Config.h
â”‚   â”œâ”€â”€ Constants.h
â”‚   â”œâ”€â”€ MainWindow.cpp
â”‚   â”œâ”€â”€ MainWindow.h
â”‚   â”œâ”€â”€ MainWindow.ui
â”‚   â”œâ”€â”€ Settings.cpp
â”‚   â”œâ”€â”€ Settings.h
â”‚   â”œâ”€â”€ TerminalEngine.cpp
â”‚   â”œâ”€â”€ TerminalEngine.h
â”‚   â””â”€â”€ main.cpp
â”œâ”€â”€ tests
â”‚   â”œâ”€â”€ gtest_resolver.cpp
â”‚   â”œâ”€â”€ qt_test_main.cpp
â”‚   â”œâ”€â”€ qtest_mainwindow.cpp
â”‚   â”œâ”€â”€ test_main.cpp
â”‚   â”œâ”€â”€ test_mainwindow.cpp
â”‚   â””â”€â”€ test_resolver.cpp
â”œâ”€â”€ translations
â”‚   â”œâ”€â”€ MatrixHistory_en.qm
â”‚   â”œâ”€â”€ MatrixHistory_en.ts
â”‚   â”œâ”€â”€ MatrixHistory_es.qm
â”‚   â”œâ”€â”€ MatrixHistory_es.ts
â”‚   â”œâ”€â”€ MatrixUtility_en.qm
â”‚   â”œâ”€â”€ MatrixUtility_en.ts
â”‚   â”œâ”€â”€ MatrixUtility_es.qm
â”‚   â”œâ”€â”€ MatrixUtility_es.ts
â”‚   â”œâ”€â”€ PipMatrixResolverQt_en.qm
â”‚   â”œâ”€â”€ PipMatrixResolverQt_en.ts
â”‚   â”œâ”€â”€ PipMatrixResolverQt_es.qm
â”‚   â””â”€â”€ PipMatrixResolverQt_es.ts
â”œâ”€â”€ .clang-format
â”œâ”€â”€ .gitignore
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ Installation.txt
â”œâ”€â”€ LICENSE
â”œâ”€â”€ PipMatrixResolverQt.qrc
â”œâ”€â”€ README.md
â”œâ”€â”€ Terminal.Upgrade.Summary.txt
â”œâ”€â”€ The.Plan.txt
â”œâ”€â”€ cleanbash.sh
â”œâ”€â”€ mainwindow_cpp.txt
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ src2txt.bat
â””â”€â”€ src2txt.sh

#*** End of file PipMatrixResolver ***
