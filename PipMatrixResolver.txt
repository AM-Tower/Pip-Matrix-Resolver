#===============================================================================
# Project: PipMatrixResolver
# Generated on: 2025-11-02 18:20:11
# OS: WSL on Ubuntu: 24.04
# This file is used to show full source code, cmake, read me, and file locates.
#================================C

#-------------------------------------------------------------------------------
# File: CMakeLists.txt
#-------------------------------------------------------------------------------
cmake_minimum_required(VERSION 3.24)
project(PipMatrixResolverQt VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

find_package(Qt6 6.10 REQUIRED COMPONENTS Core Gui Widgets LinguistTools Network Concurrent Svg)

qt_standard_project_setup()

# --------------------------------------------------
# Translations
# --------------------------------------------------
set(TS_FILES
    translations/PipMatrixResolverQt_en.ts
    translations/PipMatrixResolverQt_es.ts
)

qt_add_translation(QM_FILES ${TS_FILES})

# --------------------------------------------------
# Resources (icons + translations)
# --------------------------------------------------
qt_add_resources(APP_RESOURCES PipMatrixResolverQt.qrc)

# --------------------------------------------------
# Executable
# --------------------------------------------------
qt_add_executable(PipMatrixResolverQt
    src/main.cpp
    src/MainWindow.cpp
    src/MainWindow.h
    src/MainWindow.ui
    src/ResolverEngine.cpp
    src/ResolverEngine.h
    src/VenvManager.cpp
    src/VenvManager.h
    src/PipToolsRunner.cpp
    src/PipToolsRunner.h
    src/BatchRunner.cpp
    src/BatchRunner.h

    ${APP_RESOURCES}
    ${QM_FILES}
    src/venv_manager.py   # ensures .qm files are built before linking
)

target_link_libraries(PipMatrixResolverQt PRIVATE
    Qt6::Core
    Qt6::Gui
    Qt6::Widgets
    Qt6::Network
    Qt6::Concurrent
    Qt6::Svg
)

target_include_directories(PipMatrixResolverQt PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)
# --------------------------------------------------
# Deployment logic
# --------------------------------------------------
if(WIN32)
    find_program(WINDEPLOYQT_EXECUTABLE NAMES windeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(WINDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${WINDEPLOYQT_EXECUTABLE} --verbose 0 --no-compiler-runtime "$<TARGET_FILE:PipMatrixResolverQt>"
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (Windows)"
        )
    endif()
elseif(APPLE)
    find_program(MACDEPLOYQT_EXECUTABLE NAMES macdeployqt HINTS "${Qt6_DIR}/../../../bin" ENV PATH)
    if(MACDEPLOYQT_EXECUTABLE)
        add_custom_command(TARGET PipMatrixResolverQt POST_BUILD
            COMMAND ${MACDEPLOYQT_EXECUTABLE} "$<TARGET_BUNDLE_DIR:PipMatrixResolverQt>" -verbose=1
            COMMENT "Deploying Qt runtime for PipMatrixResolverQt (macOS)"
        )
    endif()
elseif(UNIX)
    message(STATUS "✅ Linux build — Qt runtime deployment handled by system packages.")
endif()

install(TARGETS PipMatrixResolverQt)

#-------------------------------------------------------------------------------
# File: PipMatrixResolverQt.qrc
#-------------------------------------------------------------------------------
<RCC>
    <!-- Icons -->
    <qresource prefix="/icons">
        <file>icons/app.svg</file>
        <file>icons/open.svg</file>
        <file>icons/url.svg</file>
        <file>icons/venv.svg</file>
        <file>icons/resolve.svg</file>
        <file>icons/pause.svg</file>
        <file>icons/resume.svg</file>
        <file>icons/stop.svg</file>
        <file>icons/batch.svg</file>
        <file>icons/info.svg</file>
        <file>icons/readme.svg</file>
    </qresource>

    <!-- Translations -->
    <qresource prefix="/translations">
        <file>translations/PipMatrixResolverQt_en.qm</file>
        <file>translations/PipMatrixResolverQt_es.qm</file>
    </qresource>

    <!-- Docs -->
    <qresource prefix="/docs">
        <file>README.md</file>
    </qresource>

</RCC>
#-------------------------------------------------------------------------------
# File: README.md
#-------------------------------------------------------------------------------
# PipMatrixResolverQt

## Status:
* Not working.
* Just starting this project, and it will take time to get to a working version.

### A cross platform Qt 6.10 C++ GUI for resolving Python requirements.txt matrices, managing virtual environments, and running batch multimedia conversions.

Features

* Resolve Python dependency matrices with pip-tools
* Manage virtual environments (create, upgrade pip and pip-tools)
* Batch convert audio + image to MP4 with ffmpeg
* Qt GUI with menus, log view, progress bar
* Translation support (English and Spanish)

## Build Instructions
```
cmake -S . -B build -DCMAKE\_PREFIX\_PATH="C:/Qt/6.10.0/mingw\_64"
cmake --build build
```

## On Windows, windeployqt is run automatically after build.

Project Tree

```
Qt/
├── build
├── icons
│   ├── app.svg
│   ├── batch.svg
│   ├── cancel.svg
│   ├── info.svg
│   ├── open.svg
│   ├── pause.svg
│   ├── readme.svg
│   ├── resolve.svg
│   ├── resume.svg
│   ├── stop.svg
│   ├── url.svg
│   └── venv.svg
├── src
│   ├── BatchRunner.cpp
│   ├── BatchRunner.h
│   ├── MainWindow.cpp
│   ├── MainWindow.h
│   ├── MainWindow.ui
│   ├── MatrixHistory.cpp
│   ├── MatrixHistory.h
│   ├── MatrixUtility.cpp
│   ├── MatrixUtility.h
│   ├── PipToolsRunner.cpp
│   ├── PipToolsRunner.h
│   ├── ResolverEngine.cpp
│   ├── ResolverEngine.h
│   ├── VenvManager.cpp
│   ├── VenvManager.h
│   └── main.cpp
├── src_text
│   ├── BatchRunner.cpp.txt
│   ├── BatchRunner.h.txt
│   ├── MainWindow.cpp.txt
│   ├── MainWindow.h.txt
│   ├── MainWindow.ui.autosave.txt
│   ├── MainWindow.ui.txt
│   ├── MatrixHistory.cpp.txt
│   ├── MatrixHistory.h.txt
│   ├── MatrixHistory.ui.txt
│   ├── MatrixUtility.cpp.txt
│   ├── MatrixUtility.h.txt
│   ├── PipMatrixResolverQt.qrc.txt
│   ├── PipToolsRunner.cpp.txt
│   ├── PipToolsRunner.h.txt
│   ├── ResolverEngine.cpp.txt
│   ├── ResolverEngine.h.txt
│   ├── VenvManager.cpp.txt
│   ├── VenvManager.h.txt
│   └── main.cpp.txt
├── tests
│   ├── gtest_resolver.cpp
│   ├── qt_test_main.cpp
│   ├── qtest_mainwindow.cpp
│   ├── test_main.cpp
│   ├── test_mainwindow.cpp
│   └── test_resolver.cpp
├── translations
│   ├── MatrixHistory_en.qm
│   ├── MatrixHistory_en.ts
│   ├── MatrixHistory_es.qm
│   ├── MatrixHistory_es.ts
│   ├── MatrixUtility_en.qm
│   ├── MatrixUtility_en.ts
│   ├── MatrixUtility_es.qm
│   ├── MatrixUtility_es.ts
│   ├── PipMatrixResolverQt_en.qm
│   ├── PipMatrixResolverQt_en.ts
│   ├── PipMatrixResolverQt_es.qm
│   └── PipMatrixResolverQt_es.ts
├── .gitignore
├── CMakeLists.txt
├── CMakeLists.txt.user
├── LICENSE
├── PipMatrixResolverQt.qrc
├── README.md
├── cleanbash.sh
├── requirements.txt
├── source_files.txt
├── src2txt.bat
└── src2txt.sh
```

## File Descriptions

Root
```
CMakeLists.txt – Build script: compiles sources, generates qm from ts, bundles resources
PipMatrixResolverQt.qrc – Qt resource file embedding icons and compiled translations
```

resources/icons
```
SVG icons used in menus and toolbars
```

src
```
main.cpp – Application entry point. Sets up QApplication, loads translations, shows MainWindow
MainWindow.h/.cpp/.ui – Main GUI window. Defines menus, log view, progress bar, and user actions
ResolverEngine.h/.cpp – Core engine for iterating over package version combinations. Emits logs, progress, and success signals
PipToolsRunner.h/.cpp – Wrapper around pip-compile. Runs with retries, logs output, analyzes errors
VenvManager.h/.cpp – Creates and manages Python virtual environments. Upgrades pip and pip-tools
BatchRunner.h/.cpp – Automates ffmpeg jobs. Enqueues tasks, parses progress, emits job completion signals
```

translations
```
PipMatrixResolverQt\_en.ts – English translation source
PipMatrixResolverQt\_es.ts – Spanish translation source
Both are compiled into qm at build time and embedded
```

build
```
Out of source build directory. Keeps generated files separate from source tree
```

Usage

```
File → Open requirements file – Load a local requirements.txt
Tools → Create/Update venv – Create or update a Python virtual environment
Tools → Resolve matrix – Start iterative resolution of package versions
Batch → Run batch conversion to mp4 – Combine audio and image into MP4
Help → About – Show app info
```

## License: 
    Unlicensed, MIT or your chosen license

#-------------------------------------------------------------------------------
# File: src/BatchRunner.cpp
#-------------------------------------------------------------------------------
#include "BatchRunner.h"
#include <QRegularExpression>
#include <QFileInfo>

BatchRunner::BatchRunner(QObject *parent) : QObject(parent), m_running(false)
{
    connect(&m_process, &QProcess::readyReadStandardError, this, &BatchRunner::handleReadyRead);
    connect(&m_process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            this, &BatchRunner::handleFinished);
}

void BatchRunner::enqueue(const BatchJob &job)
{
    m_jobs.enqueue(job);
}

void BatchRunner::start()
{
    if (m_running || m_jobs.isEmpty())
    {
        return;
    }
    m_running = true;
    runNextJob();
}

void BatchRunner::stop()
{
    if (m_running)
    {
        m_process.kill();
        m_jobs.clear();
        m_running = false;
    }
}

void BatchRunner::runNextJob()
{
    if (m_jobs.isEmpty())
    {
        m_running = false;
        emit allJobsFinished();
        return;
    }

    m_currentJob = m_jobs.dequeue();
    emit logMessage(QString("Starting batch job: %1 + %2 → %3")
                    .arg(m_currentJob.imagePath, m_currentJob.audioPath, m_currentJob.outputPath));

    QStringList args = {
        "-y",
        "-i", m_currentJob.audioPath,
        "-i", m_currentJob.imagePath,
        "-c:v", "libx264",
        "-c:a", "aac",
        "-shortest",
        m_currentJob.outputPath
    };

    m_process.setProgram("ffmpeg");
    m_process.setArguments(args);
    m_process.start();
}

void BatchRunner::handleReadyRead()
{
    const QString output = QString::fromUtf8(m_process.readAllStandardError());
    emit logMessage(output);

    // Parse ffmpeg progress lines like: "frame=  100 fps=25 q=28.0 size=..."
    const QStringList lines = output.split('\n');
    for (const QString &line : lines)
    {
        int percent = parseProgress(line);
        if (percent >= 0)
        {
            emit progressChanged(percent);
        }
    }
}

void BatchRunner::handleFinished(int exitCode, QProcess::ExitStatus status)
{
    if (status == QProcess::NormalExit && exitCode == 0)
    {
        emit logMessage(QString("Job finished successfully: %1").arg(m_currentJob.outputPath));
        emit jobFinished(m_currentJob.outputPath);
    }
    else
    {
        emit logMessage(QString("Job failed: %1").arg(m_currentJob.outputPath));
    }

    runNextJob();
}

int BatchRunner::parseProgress(const QString &line)
{
    // Very basic parser: look for "time=" and estimate percent
    QRegularExpression re("time=(\\d+):(\\d+):(\\d+\\.\\d+)");
    QRegularExpressionMatch match = re.match(line);
    if (match.hasMatch())
    {
        int hours = match.captured(1).toInt();
        int minutes = match.captured(2).toInt();
        double seconds = match.captured(3).toDouble();
        double elapsed = hours * 3600 + minutes * 60 + seconds;

        // For demo: assume 60 seconds total
        double percent = (elapsed / 60.0) * 100.0;
        if (percent > 100.0) percent = 100.0;
        return static_cast<int>(percent);
    }
    return -1;
}
#-------------------------------------------------------------------------------
# File: src/BatchRunner.h
#-------------------------------------------------------------------------------
#pragma once
#include <QObject>
#include <QQueue>
#include <QProcess>

struct BatchJob
{
    QString imagePath;
    QString audioPath;
    QString outputPath;
};

class BatchRunner : public QObject
{
    Q_OBJECT
public:
    explicit BatchRunner(QObject *parent = nullptr);

    void enqueue(const BatchJob &job);
    void start();
    void stop();

signals:
    void logMessage(const QString &line);
    void progressChanged(int percent);
    void jobFinished(const QString &outputPath);
    void allJobsFinished();

private slots:
    void handleReadyRead();
    void handleFinished(int exitCode, QProcess::ExitStatus status);

private:
    void runNextJob();
    int parseProgress(const QString &line);

    QQueue<BatchJob> m_jobs;
    QProcess m_process;
    BatchJob m_currentJob;
    bool m_running;
};
#-------------------------------------------------------------------------------
# File: src/MainWindow.cpp
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.cpp
 * @brief Implements the main application window.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.6
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Implements the main window logic: settings, history, menus,
 * file and URL loaders, logging, and UI dialog wiring.
 ***************************************************************/

#include "MainWindow.h"
#include "ui_MainWindow.h"
#include <QApplication>
#include <QFileDialog>
#include <QHeaderView>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QEventLoop>
#include <QUrl>
#include <utility> // Add this to your includes for std::as_const
#include <QSysInfo>
#include <QProcess>
#include <QPlainTextEdit>
#include <QLineEdit>
#include <QDir>

/****************************************************************
 * @brief Globals for MainWindow.
 ***************************************************************/
QString MainWindow::appVersion = "1.0";
const QString DEFAULT_PYTHON_VERSION = "3.11";
const QString DEFAULT_PIP_VERSION = "23.2";
const QString DEFAULT_PIPTOOLS_VERSION = "6.13";
const int DEFAULT_MAX_ITEMS = 10;
const QString DEFAULT_APP_VERSION = "1.0";
const QString MainWindow::kOrganizationName = "AM-Tower";
const QString MainWindow::kApplicationName = "PipMatrixResolver";
/****************************************************************
 * @brief Constructor for MainWindow.
 ***************************************************************/
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent),
    ui(new Ui::MainWindow),
    requirementsModel(new QStandardItemModel(this)),
    requirementsView(nullptr),
    logView(nullptr),
    progress(nullptr),
    recentLocalMenu(nullptr),
    recentWebMenu(nullptr),
    maxHistoryItems(10)
{
    ui->setupUi(this);

    // Manually add Recent Local and Recent Web submenus after actionFetchRequirements
    QList<QAction*> actions = ui->menuFile->actions();
    int insertIndex = -1;
    for (int i = 0; i < actions.size(); ++i)
    {
        if (actions[i] == ui->actionFetchRequirements)
        {
            insertIndex = i;
            break;
        }
    }
    recentLocalMenu = new QMenu(tr("Recent Local"), this);
    recentWebMenu = new QMenu(tr("Recent Web"), this);
    if (insertIndex != -1)
    {
        ui->menuFile->insertMenu(actions[insertIndex + 1], recentLocalMenu);
        ui->menuFile->insertMenu(actions[insertIndex + 1], recentWebMenu);
    }
    else
    {
        ui->menuFile->addMenu(recentLocalMenu);
        ui->menuFile->addMenu(recentWebMenu);
    }

    requirementsView = ui->requirementsView;
    logView = ui->logView;
    localHistoryTable = ui->localHistoryTable;
    webHistoryTable = ui->webHistoryTable;
    localHistoryModel = new QStandardItemModel(this);
    webHistoryModel = new QStandardItemModel(this);
    localHistoryTable->setModel(localHistoryModel);
    webHistoryTable->setModel(webHistoryModel);
    progress = ui->progressBar;

    gpuDetectedCheckBox = ui->gpuDetectedCheckBox;
    useCpuCheckBox = ui->useCpuCheckBox;
    cudaCheckBox = ui->cudaCheckBox;
    osEdit = ui->osEdit;
    osReleaseEdit = ui->osReleaseEdit;
    osVersionEdit = ui->osVersionEdit;

    requirementsView->setModel(requirementsModel);
    requirementsView->setAlternatingRowColors(true);
    requirementsView->setSelectionBehavior(QAbstractItemView::SelectRows);
    requirementsView->setSelectionMode(QAbstractItemView::ExtendedSelection);
    requirementsView->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    requirementsView->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    requirementsView->resizeColumnsToContents();
    requirementsView->resizeRowsToContents();
    requirementsView->setSizeAdjustPolicy(QAbstractScrollArea::AdjustToContents);
    requirementsView->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
    requirementsView->setHorizontalScrollMode(QAbstractItemView::ScrollPerPixel);

    loadAppSettings();
    loadHistory();

    connect(ui->actionOpenRequirements, &QAction::triggered, this, &MainWindow::openLocalRequirements);
    connect(ui->actionFetchRequirements, &QAction::triggered, this, &MainWindow::fetchRequirementsFromUrl);
    connect(ui->actionExit, &QAction::triggered, this, &MainWindow::exitApp);

    if (ui->buttonBoxPreferences)
    {
        connect(ui->buttonBoxPreferences, &QDialogButtonBox::accepted, this, &MainWindow::saveAppSettings);
        QPushButton *applyBtn = ui->buttonBoxPreferences->button(QDialogButtonBox::Apply);
        if (applyBtn)
        {
            connect(applyBtn, &QPushButton::clicked, this, &MainWindow::saveAppSettings);
        }
    }
    connect(ui->actionAbout, &QAction::triggered, this, &MainWindow::showAboutBox);
    connect(ui->actionViewReadme, &QAction::triggered, this, &MainWindow::showReadmeDialog);
    ui->mainTabs->setCurrentIndex(0);
    ui->mainTabs->setCurrentWidget(ui->tabMain);

    // History tables and models
    localHistoryTable = ui->localHistoryTable;
    webHistoryTable = ui->webHistoryTable;
    localHistoryModel = new QStandardItemModel(this);
    webHistoryModel = new QStandardItemModel(this);
    localHistoryTable->setModel(localHistoryModel);
    webHistoryTable->setModel(webHistoryModel);

    connect(localHistoryTable->selectionModel(), &QItemSelectionModel::selectionChanged,
            this, &MainWindow::updateLocalHistoryButtons);
    connect(webHistoryTable->selectionModel(), &QItemSelectionModel::selectionChanged,
            this, &MainWindow::updateWebHistoryButtons);
    connect(ui->actionCreateVenv, &QAction::triggered, this, &MainWindow::onCreateVenv);

    // Terminal tab
    connect(ui->runCommandBtn, &QPushButton::clicked, this, &MainWindow::onRunCommand);
    connect(ui->clearTerminalBtn, &QPushButton::clicked, this, &MainWindow::onClearTerminal);

    // Package Manager tab
    connect(ui->searchPackageBtn, &QPushButton::clicked, this, &MainWindow::onSearchPackage);
    connect(ui->installPackageBtn, &QPushButton::clicked, this, &MainWindow::onInstallPackage);
    connect(ui->uninstallPackageBtn, &QPushButton::clicked, this, &MainWindow::onUninstallPackage);
/*
 * Auto connected
    // Connect local history buttons
    connect(ui->localAddButton,    &QPushButton::clicked, this, &MainWindow::on_localAddButton_clicked);
    connect(ui->localEditButton,   &QPushButton::clicked, this, &MainWindow::on_localEditButton_clicked);
    connect(ui->localDeleteButton, &QPushButton::clicked, this, &MainWindow::on_localDeleteButton_clicked);
    connect(ui->localUpButton,     &QPushButton::clicked, this, &MainWindow::on_localUpButton_clicked);
    connect(ui->localDownButton,   &QPushButton::clicked, this, &MainWindow::on_localDownButton_clicked);

    // Connect web history buttons
    connect(ui->webAddButton,    &QPushButton::clicked, this, &MainWindow::on_webAddButton_clicked);
    connect(ui->webEditButton,   &QPushButton::clicked, this, &MainWindow::on_webEditButton_clicked);
    connect(ui->webDeleteButton, &QPushButton::clicked, this, &MainWindow::on_webDeleteButton_clicked);
    connect(ui->webUpButton,     &QPushButton::clicked, this, &MainWindow::on_webUpButton_clicked);
    connect(ui->webDownButton,   &QPushButton::clicked, this, &MainWindow::on_webDownButton_clicked);
*/
    // Refresh tables on startup
    refreshRecentMenus();
    refreshHistoryTables();
    checkAndRestoreSettings();

    detectSystem();         // Detect OS, release, version, GPU
    restoreCpuCudaSettings(); // Restore CPU/Cuda settings from QSettings
    setupVenvPaths();       // Set up venv_running and venv_testing paths
}

/****************************************************************
 * @brief Destructor for MainWindow.
 ***************************************************************/
MainWindow::~MainWindow()
{
    delete ui;
}

/****************************************************************
 * @brief Exits the application.
 ***************************************************************/
void MainWindow::exitApp()
{
    QApplication::quit();
}

/****************************************************************
 * @brief Opens requirements from a local file via dialog.
 ***************************************************************/
void MainWindow::openLocalRequirements()
{
    QString path = QFileDialog::getOpenFileName(this, tr("Open requirements.txt"), QString(), tr("Text Files (*.txt)"));
    if (path.isEmpty())
    {
        return;
    }
    loadRequirementsFromFile(path);
}

/****************************************************************
 * @brief Fetches requirements from a URL via dialog.
 ***************************************************************/
void MainWindow::fetchRequirementsFromUrl()
{
    bool ok = false;
    QString inputUrl = QInputDialog::getText(
        this,
        tr("Fetch requirements"),
        tr("Enter URL:"),
        QLineEdit::Normal,
        "",
        &ok
    );
    if (!ok || inputUrl.isEmpty())
    {
        return;
    }
    const QString rawUrl = normalizeRawUrl(inputUrl);
    loadRequirementsFromUrl(rawUrl);
}

/****************************************************************
 * @brief Loads requirements from a local file.
 ***************************************************************/
void MainWindow::loadRequirementsFromFile(const QString &path)
{
    if (path.isEmpty())
    {
        return;
    }
    if (!QFile::exists(path))
    {
        QMessageBox::warning(this, tr("File missing"), tr("File no longer exists:\n%1").arg(path));
        historyRecentLocal.removeAll(path);
        refreshRecentMenus();
        saveHistory();
        return;
    }
    const QStringList lines = readTextFileLines(path);
    QStringList errors;
    if (!validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(
            this,
            tr("Invalid requirements.txt"),
            tr("Validation failed:\n%1").arg(errors.join("\n"))
        );
        return;
    }
    if (requirementsModel)
    {
        requirementsModel->clear();
        writeTableToModel(lines);
    }
    applySettingsFromUi();
    historyRecentLocal.removeAll(path);
    historyRecentLocal.prepend(path);
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Loaded %1 requirements from %2").arg(requirementsModel->rowCount()).arg(path));
}

/****************************************************************
 * @brief Loads requirements from a URL.
 ***************************************************************/
void MainWindow::loadRequirementsFromUrl(const QString &url)
{
    if (url.isEmpty())
    {
        return;
    }
    QByteArray content;
    if (!downloadText(url, content))
    {
        QMessageBox::warning(
            this,
            tr("Download failed"),
            tr("Failed to fetch requirements from URL:\n%1").arg(url)
        );
        historyRecentWeb.removeAll(url);
        refreshRecentMenus();
        saveHistory();
        return;
    }
    const QStringList lines = QString::fromUtf8(content).split('\n', Qt::KeepEmptyParts);
    QStringList errors;
    if (!validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(
            this,
            tr("Invalid requirements.txt"),
            tr("Fetched content failed validation:\n%1").arg(errors.join("\n"))
        );
        return;
    }
    if (requirementsModel)
    {
        requirementsModel->clear();
        writeTableToModel(lines);
    }
    applySettingsFromUi();
    historyRecentWeb.removeAll(url);
    historyRecentWeb.prepend(url);
    if (maxHistoryItems != -1)
    {
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Fetched %1 requirements from URL: %2")
        .arg(requirementsModel->rowCount())
        .arg(url));
}

/****************************************************************
 * @brief Populates the local and web history tables in the
 *        History tab with the current history data from QSettings.
 ***************************************************************/
void MainWindow::refreshHistoryTables()
{
    QSettings s(kOrganizationName, kApplicationName);
    QStringList localList = s.value("history/recentLocal").toStringList();
    QStringList webList = s.value("history/recentWeb").toStringList();

    localHistoryModel->clear();
    localHistoryModel->setHorizontalHeaderLabels({tr("Recent Local Files")});
    for (const QString &path : std::as_const(localList))
    {
        QList<QStandardItem*> row;
        row << new QStandardItem(path);
        localHistoryModel->appendRow(row);
    }
    localHistoryTable->resizeColumnsToContents();

    webHistoryModel->clear();
    webHistoryModel->setHorizontalHeaderLabels({tr("Recent Web URLs")});
    for (const QString &url : std::as_const(webList))
    {
        QList<QStandardItem*> row;
        row << new QStandardItem(url);
        webHistoryModel->appendRow(row);
    }
    webHistoryTable->resizeColumnsToContents();
    updateLocalHistoryButtons();
    updateWebHistoryButtons();
}

/****************************************************************
 * @brief Refreshes recent file and URL menus safely.
 ***************************************************************/
void MainWindow::refreshRecentMenus()
{
    if (!recentLocalMenu || !recentWebMenu)
    {
        qWarning() << "refreshRecentMenus: menus not available, skipping";
        return;
    }
    recentLocalMenu->clear();
    recentWebMenu->clear();

    // Populate Recent Local
    for (int i = 0; i < historyRecentLocal.size(); ++i)
    {
        const QString &path = historyRecentLocal.at(i);
        QAction *act = recentLocalMenu->addAction(path);
        connect(act, &QAction::triggered, this, [this, path]()
        {
            loadRequirementsFromFile(path);
        });
    }
    if (!historyRecentLocal.isEmpty())
    {
        recentLocalMenu->addSeparator();
        QAction *clearLocal = recentLocalMenu->addAction(tr("Clear Local History"));
        connect(clearLocal, &QAction::triggered, this, [this]()
        {
            historyRecentLocal.clear();
            refreshRecentMenus();
            saveHistory();
        });
    }

    // Populate Recent Web
    for (int i = 0; i < historyRecentWeb.size(); ++i)
    {
        const QString &url = historyRecentWeb.at(i);
        QAction *act = recentWebMenu->addAction(url);
        connect(act, &QAction::triggered, this, [this, url]()
        {
            loadRequirementsFromUrl(url);
        });
    }
    if (!historyRecentWeb.isEmpty())
    {
        recentWebMenu->addSeparator();
        QAction *clearWeb = recentWebMenu->addAction(tr("Clear Web History"));
        connect(clearWeb, &QAction::triggered, this, [this]()
        {
            historyRecentWeb.clear();
            refreshRecentMenus();
            saveHistory();
        });
    }
}

/****************************************************************
 * @brief Clears both local and web recent history lists.
 ***************************************************************/
void MainWindow::clearAllHistory()
{
    historyRecentLocal.clear();
    historyRecentWeb.clear();
    refreshRecentMenus();
    saveHistory();
    appendLog(tr("Cleared all history"));
}

/****************************************************************
 * @brief Loads application settings from QSettings to UI.
 ***************************************************************/
void MainWindow::loadAppSettings()
{
    QSettings settings;
    maxHistoryItems = settings.value("app/maxItems", 10).toInt();
    validateAppSettings();
    updateUiFromSettings();
}

/****************************************************************
 * @brief Saves application settings from UI to QSettings.
 ***************************************************************/
void MainWindow::saveAppSettings()
{
    applySettingsFromUi();
    validateAppSettings();
    QSettings settings;
    settings.setValue("app/maxItems", maxHistoryItems);
    statusBar()->showMessage(tr("Settings saved"), 2000);
    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
    refreshRecentMenus();
    saveHistory();
}

/****************************************************************
 * @brief Validates and clamps settings to safe ranges.
 ***************************************************************/
void MainWindow::validateAppSettings()
{
    if (maxHistoryItems == 0)
    {
        maxHistoryItems = 10;
    }
    else if (maxHistoryItems < -1)
    {
        maxHistoryItems = 1;
    }
}

/****************************************************************
 * @brief Applies settings from UI widgets to member state.
 ***************************************************************/
void MainWindow::applySettingsFromUi()
{
    maxHistoryItems = ui->spinMaxItems->value();
}

/****************************************************************
 * @brief Updates UI widgets to reflect current settings.
 ***************************************************************/
void MainWindow::updateUiFromSettings()
{
    ui->spinMaxItems->setMinimum(-1);
    ui->spinMaxItems->setMaximum(std::numeric_limits<int>::max());
    ui->spinMaxItems->setToolTip(tr("-1 = unlimited, 0 not allowed, ≥1 valid"));
    ui->spinMaxItems->setValue(maxHistoryItems);
}

/****************************************************************
 * @brief Writes requirements into a one-column model.
 ***************************************************************/
void MainWindow::writeTableToModel(const QStringList &lines)
{
    if (!requirementsModel || !requirementsView) { return; }
    requirementsModel->clear();
    requirementsModel->setColumnCount(1);
    requirementsModel->setHorizontalHeaderLabels({tr("requirements.txt")});
    requirementsView->resizeRowsToContents();

    for (const QString &line : lines)
    {
        const QString trimmed = line.trimmed();
        if (trimmed.isEmpty())
        {
            continue;
        }
        auto *item = new QStandardItem(trimmed);
        item->setEditable(false);
        requirementsModel->appendRow(item);
    }
    requirementsView->resizeColumnsToContents();
    requirementsView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
    requirementsView->horizontalHeader()->setSectionResizeMode(QHeaderView::Interactive);
    requirementsView->resizeColumnsToContents();
    requirementsView->resizeRowsToContents();

    // Get the actual width of requirementsView and add 66px
    int reqWidth = requirementsView->verticalHeader()->width();
    for (int col = 0; col < requirementsModel->columnCount(); ++col)
    {
        reqWidth += requirementsView->columnWidth(col);
    }
    reqWidth += 66;

    // Set the splitter sizes
    QSplitter *splitter = qobject_cast<QSplitter*>(requirementsView->parentWidget());
    if (splitter)
    {
        QList<int> sizes;
        sizes << reqWidth << qMax(100, splitter->width() - reqWidth);
        splitter->setSizes(sizes);
    }
    refreshHistoryTables();
}

/****************************************************************
 * @brief Appends a line to the log view with timestamp.
 * @param line The message line to append.
 ***************************************************************/
void MainWindow::appendLog(const QString &line)
{
    QString time = QDateTime::currentDateTime().toString("HH:mm:ss");
    logView->appendPlainText(QString("[%1] %2").arg(time, line));
}

/****************************************************************
 * @brief Updates progress bar percent.
 * @param percent The progress value (0-100).
 ***************************************************************/
void MainWindow::updateProgress(int percent)
{
    progress->setValue(percent);
}

/****************************************************************
 * @brief Shows compiled result message path.
 * @param path The compiled output path.
 ***************************************************************/
void MainWindow::showCompiledResult(const QString &path)
{
    appendLog(tr("Successfully compiled: %1").arg(path));
    statusBar()->showMessage(tr("Compiled successfully"));
}

/****************************************************************
 * @brief Shows About dialog using current appVersion.
 ***************************************************************/
void MainWindow::showAboutBox()
{
    QMessageBox::about(
        this,
        tr("About Pip Matrix Resolver"),
        tr("<b>Pip Matrix Resolver</b><br>"
           "Cross-platform Qt tool to resolve "
           "Python dependency matrices.<br>"
           "Version %1").arg(appVersion)
        );
}

/****************************************************************
 * @brief Shows README dialog from resources.
 ***************************************************************/
void MainWindow::showReadmeDialog()
{
    QFile file(":/docs/README.md");
    QString markdown;
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        markdown = QString::fromUtf8(file.readAll());
    }
    else
    {
        markdown = tr("README.md not found in resources.");
    }

    QDialog dialog(this);
    dialog.setWindowTitle(tr("README"));
    dialog.resize(700, 500);

    QVBoxLayout layout(&dialog);
    QTextBrowser viewer(&dialog);
    viewer.setMarkdown(markdown);
    viewer.setOpenExternalLinks(true);

    QPushButton closeButton(tr("Close"), &dialog);
    layout.addWidget(&viewer);
    layout.addWidget(&closeButton);

    connect(&closeButton, &QPushButton::clicked, &dialog, &QDialog::accept);

    dialog.exec();
}

/****************************************************************
 * @brief Loads persistent history from QSettings.
 ***************************************************************/
void MainWindow::loadHistory()
{
    QSettings s(kOrganizationName, kApplicationName);
    historyRecentLocal = s.value("history/recentLocal").toStringList();
    historyRecentWeb = s.value("history/recentWeb").toStringList();

    if (maxHistoryItems != -1)
    {
        while (historyRecentLocal.size() > maxHistoryItems)
        {
            historyRecentLocal.removeLast();
        }
        while (historyRecentWeb.size() > maxHistoryItems)
        {
            historyRecentWeb.removeLast();
        }
    }
}

/****************************************************************
 * @brief Saves persistent history to QSettings.
 ***************************************************************/
void MainWindow::saveHistory()
{
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("history/recentLocal", historyRecentLocal);
    s.setValue("history/recentWeb", historyRecentWeb);
}

/****************************************************************
 * @brief Normalizes a raw URL string.
 ***************************************************************/
QString MainWindow::normalizeRawUrl(const QString &inputUrl)
{
    QString url = inputUrl.trimmed();
    if (!url.startsWith("http://") && !url.startsWith("https://"))
    {
        url.prepend("https://");
    }
    return url;
}

/****************************************************************
 * @brief Reads all lines from a text file.
 ***************************************************************/
QStringList MainWindow::readTextFileLines(const QString &path)
{
    QStringList lines;
    QFile file(path);
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        while (!file.atEnd())
        {
            lines << QString::fromUtf8(file.readLine()).trimmed();
        }
        file.close();
    }
    return lines;
}

/****************************************************************
 * @brief Validates requirements.txt lines.
 ***************************************************************/
bool MainWindow::validateRequirementsWithErrors(const QStringList &lines, QStringList &errors)
{
    errors.clear();
    bool valid = true;
    for (const QString &line : lines)
    {
        if (line.isEmpty())
        {
            continue;
        }
        // Example validation: must not start with a dash or space
        if (line.startsWith('-') || line.startsWith(' '))
        {
            errors << tr("Invalid line: %1").arg(line);
            valid = false;
        }
        // Add more validation rules as needed
    }
    return valid;
}

/****************************************************************
 * @brief Downloads text from a URL.
 ***************************************************************/
bool MainWindow::downloadText(const QString &url, QByteArray &out)
{
    QNetworkAccessManager manager;
    QNetworkRequest request{QUrl(url)};
    QNetworkReply *reply = manager.get(request);
    QEventLoop loop;
    connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
    loop.exec();
    if (reply->error() != QNetworkReply::NoError)
    {
        reply->deleteLater();
        return false;
    }
    out = reply->readAll();
    reply->deleteLater();
    return true;
}

/****************************************************************
 * @brief Returns the logs directory path.
 ***************************************************************/
QString MainWindow::logsDir()
{
    QString dir = QDir::homePath() + "/PipMatrixResolverLogs";
    QDir().mkpath(dir);
    return dir;
}

/****************************************************************
 * @brief Starts matrix resolution (stub).
 ***************************************************************/
void MainWindow::startResolve()
{
    appendLog(tr("Starting matrix resolution..."));
    // Add your matrix resolution logic here
}

/****************************************************************
 * @brief Pauses matrix resolution (stub).
 ***************************************************************/
void MainWindow::pauseResolve()
{
    appendLog(tr("Pausing..."));
    // Add your pause logic here
}

/****************************************************************
 * @brief Resumes matrix resolution (stub).
 ***************************************************************/
void MainWindow::resumeResolve()
{
    appendLog(tr("Resuming..."));
    // Add your resume logic here
}

/****************************************************************
 * @brief Stops matrix resolution (stub).
 ***************************************************************/
void MainWindow::stopResolve()
{
    appendLog(tr("Stopping..."));
    // Add your stop logic here
}

/****************************************************************
 * @brief Adds a new entry to the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localAddButton_clicked()
{
    bool ok;
    QString path = QInputDialog::getText(this, tr("Add Local File"), tr("File path:"), QLineEdit::Normal, "", &ok);
    if (ok && !path.isEmpty())
    {
        QSettings s(kOrganizationName, kApplicationName);
        QStringList list = s.value("history/recentLocal").toStringList();
        list.prepend(path);
        s.setValue("history/recentLocal", list);
        refreshHistoryTables();
    }
}

/****************************************************************
 * @brief Edits the selected entry in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localEditButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    QString oldValue = list.at(idx.row());
    bool ok;
    QString newValue = QInputDialog::getText(this, tr("Edit Local File"), tr("File path:"), QLineEdit::Normal, oldValue, &ok);
    if (!ok) return; // User cancelled, do nothing
    if (newValue.isEmpty()) return; // Optionally, do nothing if empty
    list[idx.row()] = newValue;
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Deletes the selected entry from the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localDeleteButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    list.removeAt(idx.row());
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Moves the selected entry up in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localUpButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    if (!idx.isValid() || idx.row() == 0) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    list.swapItemsAt(idx.row(), idx.row() - 1);
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
    localHistoryTable->selectRow(idx.row() - 1);
}

/****************************************************************
 * @brief Moves the selected entry down in the local history table and QSettings.
 ***************************************************************/
void MainWindow::on_localDownButton_clicked()
{
    QModelIndex idx = localHistoryTable->currentIndex();
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentLocal").toStringList();
    if (!idx.isValid() || idx.row() >= list.size() - 1) return;
    list.swapItemsAt(idx.row(), idx.row() + 1);
    s.setValue("history/recentLocal", list);
    refreshHistoryTables();
    localHistoryTable->selectRow(idx.row() + 1);
}

/****************************************************************
 * @brief Adds a new entry to the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webAddButton_clicked()
{
    bool ok;
    QString url = QInputDialog::getText(this, tr("Add Web URL"), tr("URL:"), QLineEdit::Normal, "", &ok);
    if (ok && !url.isEmpty())
    {
        QSettings s(kOrganizationName, kApplicationName);
        QStringList list = s.value("history/recentWeb").toStringList();
        list.prepend(url);
        s.setValue("history/recentWeb", list);
        refreshHistoryTables();
    }
}

/****************************************************************
 * @brief Edits the selected entry in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webEditButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    QString oldValue = list.at(idx.row());
    bool ok;
    QString newValue = QInputDialog::getText(this, tr("Edit Web URL"), tr("URL:"), QLineEdit::Normal, oldValue, &ok);
    if (!ok) return; // User cancelled, do nothing
    if (newValue.isEmpty()) return; // Optionally, do nothing if empty
    list[idx.row()] = newValue;
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
}
/****************************************************************
 * @brief Deletes the selected entry from the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webDeleteButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid()) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    list.removeAt(idx.row());
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
}

/****************************************************************
 * @brief Moves the selected entry up in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webUpButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    if (!idx.isValid() || idx.row() == 0) return;
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    list.swapItemsAt(idx.row(), idx.row() - 1);
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
    webHistoryTable->selectRow(idx.row() - 1);
}

/****************************************************************
 * @brief Moves the selected entry down in the web history table and QSettings.
 ***************************************************************/
void MainWindow::on_webDownButton_clicked()
{
    QModelIndex idx = webHistoryTable->currentIndex();
    QSettings s(kOrganizationName, kApplicationName);
    QStringList list = s.value("history/recentWeb").toStringList();
    if (!idx.isValid() || idx.row() >= list.size() - 1) return;
    list.swapItemsAt(idx.row(), idx.row() + 1);
    s.setValue("history/recentWeb", list);
    refreshHistoryTables();
    webHistoryTable->selectRow(idx.row() + 1);
}

/****************************************************************
 * @brief Enables/disables local history buttons based on selection and table size.
 ***************************************************************/
void MainWindow::updateLocalHistoryButtons()
{
    QItemSelectionModel *sel = localHistoryTable->selectionModel();
    int rowCount = localHistoryModel->rowCount();
    bool hasSelection = sel->hasSelection();

    ui->localEditButton->setEnabled(hasSelection);
    ui->localDeleteButton->setEnabled(hasSelection);

    // Up: enabled if selected and not first row, and more than 1 item
    bool canUp = hasSelection && rowCount > 1;
    if (canUp)
    {
        QModelIndex idx = sel->currentIndex();
        canUp = idx.isValid() && idx.row() > 0;
    }
    ui->localUpButton->setEnabled(canUp);

    // Down: enabled if selected and not last row, and more than 1 item
    bool canDown = hasSelection && rowCount > 1;
    if (canDown)
    {
        QModelIndex idx = sel->currentIndex();
        canDown = idx.isValid() && idx.row() < rowCount - 1;
    }
    ui->localDownButton->setEnabled(canDown);
}

/****************************************************************
 * @brief Enables/disables web history buttons based on selection and table size.
 ***************************************************************/
void MainWindow::updateWebHistoryButtons()
{
    QItemSelectionModel *sel = webHistoryTable->selectionModel();
    int rowCount = webHistoryModel->rowCount();
    bool hasSelection = sel->hasSelection();

    ui->webEditButton->setEnabled(hasSelection);
    ui->webDeleteButton->setEnabled(hasSelection);

    // Up: enabled if selected and not first row, and more than 1 item
    bool canUp = hasSelection && rowCount > 1;
    if (canUp)
    {
        QModelIndex idx = sel->currentIndex();
        canUp = idx.isValid() && idx.row() > 0;
    }
    ui->webUpButton->setEnabled(canUp);

    // Down: enabled if selected and not last row, and more than 1 item
    bool canDown = hasSelection && rowCount > 1;
    if (canDown)
    {
        QModelIndex idx = sel->currentIndex();
        canDown = idx.isValid() && idx.row() < rowCount - 1;
    }
    ui->webDownButton->setEnabled(canDown);
}

/****************************************************************
 * @brief save Settings.
 ***************************************************************/
void MainWindow::saveSettings()
{
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("settings/pythonVersion", ui->pythonVersionEdit->text());
    s.setValue("settings/pipVersion", ui->pipVersionEdit->text());
    s.setValue("settings/pipToolsVersion", ui->pipToolsVersionEdit->text());
    s.setValue("settings/maxItems", ui->spinMaxItems->value());
    s.setValue("settings/useCpu", useCpuCheckBox->isChecked());
    s.setValue("settings/cuda", cudaCheckBox->isChecked());
}

/****************************************************************
 * @brief check And Restore Settings.
 ***************************************************************/
void MainWindow::checkAndRestoreSettings()
{
    QSettings s(kOrganizationName, kApplicationName);

    // Python version
    QString pythonVersion = s.value("settings/pythonVersion", DEFAULT_PYTHON_VERSION).toString();
    if (pythonVersion.isEmpty())
    {
        pythonVersion = DEFAULT_PYTHON_VERSION;
        s.setValue("settings/pythonVersion", pythonVersion);
    }
    ui->pythonVersionEdit->setText(pythonVersion);

    // pip version
    QString pipVersion = s.value("settings/pipVersion", DEFAULT_PIP_VERSION).toString();
    if (pipVersion.isEmpty())
    {
        pipVersion = DEFAULT_PIP_VERSION;
        s.setValue("settings/pipVersion", pipVersion);
    }
    ui->pipVersionEdit->setText(pipVersion);

    // pip-tools version
    QString pipToolsVersion = s.value("settings/pipToolsVersion", DEFAULT_PIPTOOLS_VERSION).toString();
    if (pipToolsVersion.isEmpty())
    {
        pipToolsVersion = DEFAULT_PIPTOOLS_VERSION;
        s.setValue("settings/pipToolsVersion", pipToolsVersion);
    }
    ui->pipToolsVersionEdit->setText(pipToolsVersion);

    // Max items
    int maxItems = s.value("settings/maxItems", DEFAULT_MAX_ITEMS).toInt();
    if (maxItems == 0)
    {
        maxItems = DEFAULT_MAX_ITEMS;
        s.setValue("settings/maxItems", maxItems);
    }
    ui->spinMaxItems->setValue(maxItems);
}

/****************************************************************
 * @brief Restores CPU and Cuda settings from QSettings to UI.
 ***************************************************************/
void MainWindow::restoreCpuCudaSettings()
{
    QSettings s(kOrganizationName, kApplicationName);
    ui->useCpuCheckBox->setChecked(s.value("settings/useCpu", false).toBool());
    ui->cudaCheckBox->setChecked(s.value("settings/cuda", true).toBool());
}

/****************************************************************
 * @brief Detect OS System.
 ***************************************************************/
void MainWindow::detectSystem()
{
    // GPU detection (simple: check for NVIDIA)
    bool gpuDetected = false;
    QString os, release, version;
#if defined(Q_OS_WIN)
    os = "Windows";
    release = QSysInfo::productType();
    version = QSysInfo::productVersion();
#elif defined(Q_OS_MAC)
    os = "Mac";
    release = QSysInfo::productType();
    version = QSysInfo::productVersion();
#elif defined(Q_OS_LINUX)
    os = "Linux";
    QFile f("/etc/os-release");
    if (f.open(QIODevice::ReadOnly | QIODevice::Text)) {
        while (!f.atEnd()) {
            QString line = f.readLine();
            if (line.startsWith("ID=")) release = line.mid(3).trimmed().replace("\"", "");
            if (line.startsWith("VERSION_ID=")) version = line.mid(11).trimmed().replace("\"", "");
        }
    }
#endif
    osEdit->setText(os);
    osReleaseEdit->setText(release);
    osVersionEdit->setText(version);

#if defined(Q_OS_WIN)
    QProcess proc;
    proc.start("wmic path win32_VideoController get name");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive)) gpuDetected = true;
#elif defined(Q_OS_LINUX)
    QProcess proc;
    proc.start("lspci");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive)) gpuDetected = true;
#elif defined(Q_OS_MAC)
    QProcess proc;
    proc.start("system_profiler SPDisplaysDataType");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    if (output.contains("NVIDIA", Qt::CaseInsensitive)) gpuDetected = true;
#endif
    gpuDetected = detectNvidiaGpu();
    ui->gpuDetectedCheckBox->setChecked(gpuDetected);

    // Save to QSettings
    QSettings s(kOrganizationName, kApplicationName);
    s.setValue("settings/os", os);
    s.setValue("settings/osRelease", release);
    s.setValue("settings/osVersion", version);
    s.setValue("settings/gpuDetected", gpuDetected);
}

/****************************************************************
 * @brief on Create Venv.
 ***************************************************************/
void MainWindow::onCreateVenv()
{
    // Check if python, pip, or pip-tools settings have changed
    // If so, rebuild venv_running
    // (You can compare current settings to those saved in QSettings)

    // Call your bash script using QProcess
    QProcess proc;
    QString script = "/path/to/pip-matrix-common.sh";
    QStringList args;
    args << "--create-venv-running"; // You can define this flag in your script
    proc.start(script, args);
    proc.waitForFinished(-1);
    QString output = proc.readAllStandardOutput();
    QMessageBox::information(this, tr("Create venv_running"), output);
}

/****************************************************************
 * @brief Sets up venv_running and venv_testing paths and saves to QSettings.
 ***************************************************************/
void MainWindow::setupVenvPaths()
{
    QSettings s(kOrganizationName, kApplicationName);
    QString projectRoot = QDir::currentPath();
    QString venvRunning = projectRoot + "/.venvs/venv_running";
    QString venvTesting = projectRoot + "/.venvs/venv_testing";
    s.setValue("venv/venv_running", venvRunning);
    s.setValue("venv/venv_testing", venvTesting);
}

/****************************************************************
 * @brief detect Gpu Via PowerShell.
 ***************************************************************/
bool MainWindow::detectGpuViaPowerShell()
{
    QProcess proc;
    proc.start("powershell", QStringList() << "-Command" << "Get-WmiObject Win32_VideoController | Select-Object -ExpandProperty Name");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    // Debug: print output if needed
    // QMessageBox::information(nullptr, "PowerShell GPU Output", output);
    return output.contains("NVIDIA", Qt::CaseInsensitive);
}

/****************************************************************
 * @brief detect Gpu Via DxDiag.
 ***************************************************************/
bool MainWindow::detectGpuViaDxDiag()
{
    QProcess proc;
    proc.start("cmd", QStringList() << "/c" << "dxdiag /t dxdiag.txt");
    proc.waitForFinished();
    QFile file("dxdiag.txt");
    bool found = false;
    if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QString dxdiagOutput = file.readAll();
        found = dxdiagOutput.contains("NVIDIA", Qt::CaseInsensitive);
        file.remove(); // Clean up
    }
    // Debug: print output if needed
    // QMessageBox::information(nullptr, "dxdiag GPU Output", dxdiagOutput);
    return found;
}

/****************************************************************
 * @brief detect Gpu Via Nvidia Smi.
 ***************************************************************/
bool MainWindow::detectGpuViaNvidiaSmi()
{
    QProcess proc;
    proc.start("nvidia-smi");
    proc.waitForFinished();
    QString output = proc.readAllStandardOutput();
    // Debug: print output if needed
    // QMessageBox::information(nullptr, "nvidia-smi Output", output);
    return output.contains("NVIDIA", Qt::CaseInsensitive);
}

/****************************************************************
 * @brief detect Nvidia Gpu.
 ***************************************************************/
bool MainWindow::detectNvidiaGpu()
{
    // Primary test: PowerShell WMI
    if (detectGpuViaPowerShell()) return true;
    // Fallback 1: dxdiag
    if (detectGpuViaDxDiag()) return true;
    // Fallback 2: nvidia-smi
    if (detectGpuViaNvidiaSmi()) return true;
    // Not detected
    return false;
}

/****************************************************************
 * @brief .
 ***************************************************************/
void MainWindow::onRunCommand()
{
    QString command = ui->commandInput->text().trimmed();
    if (command.isEmpty()) {
        ui->terminalOutput->appendPlainText("No command entered.");
        return;
    }

    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif

    QStringList args;
    bool usedVenv = false;

    if (command.startsWith("pip ")) {
        args << "-m" << "pip";
        args << command.mid(4).split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    } else if (command.startsWith("pip-compile")) {
        args << "-m" << "piptools" << "compile";
        QString rest = command.mid(QString("pip-compile").length()).trimmed();
        if (!rest.isEmpty()) args << rest.split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    } else if (command.startsWith("pip-sync")) {
        args << "-m" << "piptools" << "sync";
        QString rest = command.mid(QString("pip-sync").length()).trimmed();
        if (!rest.isEmpty()) args << rest.split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    } else if (command.startsWith("python ")) {
        args = command.mid(7).split(' ');
        process.start(venvPython, args);
        usedVenv = true;
    } else {
#if defined(Q_OS_WIN)
        process.start("cmd.exe", QStringList() << "/C" << command);
#else
        process.start("bash", QStringList() << "-c" << command);
#endif
    }

    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();

    if (usedVenv)
        ui->terminalOutput->appendPlainText("[venv] " + command);

    if (!output.isEmpty())
        ui->terminalOutput->appendPlainText(output);
    if (!error.isEmpty())
        ui->terminalOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief .
 ***************************************************************/
void MainWindow::onClearTerminal()
{
    ui->terminalOutput->clear();
}

/****************************************************************
 * @brief .
 ***************************************************************/
void MainWindow::onSearchPackage()
{
    QString pkg = ui->packageNameInput->text().trimmed();
    if (pkg.isEmpty()) {
        ui->packageOutput->appendPlainText("Enter a package name to search.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "search", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        ui->packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        ui->packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief .
 ***************************************************************/
void MainWindow::onInstallPackage()
{
    QString pkg = ui->packageNameInput->text().trimmed();
    if (pkg.isEmpty()) {
        ui->packageOutput->appendPlainText("Enter a package name to install.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "install", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        ui->packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        ui->packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief .
 ***************************************************************/
void MainWindow::onUninstallPackage()
{
    QString pkg = ui->packageNameInput->text().trimmed();
    if (pkg.isEmpty()) {
        ui->packageOutput->appendPlainText("Enter a package name to uninstall.");
        return;
    }
    QProcess process;
    QString venvPython;
#if defined(Q_OS_WIN)
    venvPython = QDir::current().filePath("venv_running/Scripts/python.exe");
#else
    venvPython = QDir::current().filePath("venv_running/bin/python");
#endif
    QStringList args = {"-m", "pip", "uninstall", "-y", pkg};
    process.start(venvPython, args);
    process.waitForFinished();
    QString output = process.readAllStandardOutput();
    QString error = process.readAllStandardError();
    if (!output.isEmpty())
        ui->packageOutput->appendPlainText(output);
    if (!error.isEmpty())
        ui->packageOutput->appendPlainText("[ERROR] " + error);
}

/****************************************************************
 * @brief .
 ***************************************************************/

/****************************************************************
 * @brief .
 ***************************************************************/

/************** End of MainWindow.cpp **************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.h
#-------------------------------------------------------------------------------
/****************************************************************
 * @file MainWindow.h
 * @brief Declares the main application window class.
 *
 * @author Jeffrey Scott Flesher
 * @version 0.6
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Main window interface for PipMatrixResolver Qt application.
 * Includes settings API, history, menus, and shared loaders for
 * files and URLs. Uses C-style braces.
 ***************************************************************/

#pragma once
#include <QMainWindow>
#include <QStringList>
#include <QTimer>
#include <QStandardItemModel>
#include <QTableView>
#include <QPlainTextEdit>
#include <QProgressBar>
#include <QMenu>
#include <QAction>
#include <QDialogButtonBox>
#include <QPushButton>
#include <QFile>
#include <QDir>
#include <QFileInfo>
#include <QByteArray>
#include <QDialog>
#include <QTextBrowser>
#include <QVBoxLayout>
#include <QInputDialog>
#include <QMessageBox>
#include <QSettings>
#include <QDateTime>
#include <QDebug>

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE

/****************************************************************
 * @class MainWindow
 * @brief Implements the main application window.
 ***************************************************************/
class MainWindow : public QMainWindow
{
    Q_OBJECT
public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

    // QSettings
    static const QString kOrganizationName;
    static const QString kApplicationName;
    // Globals
    static QString appVersion;

private slots:
    void openLocalRequirements();
    void fetchRequirementsFromUrl();
    void refreshRecentMenus();
    void clearAllHistory();
    void loadAppSettings();
    void saveAppSettings();
    void validateAppSettings();
    void applySettingsFromUi();
    void updateUiFromSettings();
    void startResolve();
    void pauseResolve();
    void resumeResolve();
    void stopResolve();
    void appendLog(const QString &line);
    void updateProgress(int percent);
    void showCompiledResult(const QString &path);
    void showAboutBox();
    void showReadmeDialog();
    void exitApp();
    void writeTableToModel(const QStringList &lines);
    // Local history slots
    void on_localAddButton_clicked();
    void on_localEditButton_clicked();
    void on_localDeleteButton_clicked();
    void on_localUpButton_clicked();
    void on_localDownButton_clicked();

    // Web history slots
    void on_webAddButton_clicked();
    void on_webEditButton_clicked();
    void on_webDeleteButton_clicked();
    void on_webUpButton_clicked();
    void on_webDownButton_clicked();

    void updateLocalHistoryButtons();
    void updateWebHistoryButtons();
    // Slot for menu action
    void onCreateVenv();

    void onRunCommand();
    void onClearTerminal();

    // Package Manager tab
    void onSearchPackage();
    void onInstallPackage();
    void onUninstallPackage();

private:
    void loadRequirementsFromFile(const QString &path);
    void loadRequirementsFromUrl(const QString &url);
    void saveHistory();
    void loadHistory();
    /****************************************************************
     * @brief Populates the local and web history tables in the
     *        History tab with the current history data.
     ***************************************************************/
    void refreshHistoryTables();
    /****************************************************************
    * @brief Checks all settings in the Settings tab at startup,
    *        restores defaults if missing, and updates the UI.
    ***************************************************************/
    void checkAndRestoreSettings();

    bool detectGpuViaPowerShell();
    bool detectNvidiaGpu();
    bool detectGpuViaNvidiaSmi();
    bool detectGpuViaDxDiag();
    /****************************************************************
    * @brief Saves all settings from the Settings tab to QSettings.
    ***************************************************************/
    void saveSettings();
    // Startup/system functions
    void detectSystem();
    void restoreCpuCudaSettings();
    void setupVenvPaths();

    // Utility functions moved from MatrixUtility
    QStringList readTextFileLines(const QString &path);
    bool validateRequirementsWithErrors(const QStringList &lines, QStringList &errors);
    QString normalizeRawUrl(const QString &inputUrl);
    bool downloadText(const QString &url, QByteArray &out);
    QString logsDir();

    // History data
    QStringList historyRecentLocal;
    QStringList historyRecentWeb;

    // UI pointers
    Ui::MainWindow *ui;
    QStandardItemModel *requirementsModel;
    QTableView *requirementsView;
    QPlainTextEdit *logView;
    QTableView *localHistoryTable;
    QTableView *webHistoryTable;
    QStandardItemModel *localHistoryModel;
    QStandardItemModel *webHistoryModel;
    QProgressBar *progress;
    QMenu *recentLocalMenu;
    QMenu *recentWebMenu;

    // Settings tab widgets
    QCheckBox *gpuDetectedCheckBox;
    QCheckBox *useCpuCheckBox;
    QCheckBox *cudaCheckBox;
    QLineEdit *osEdit;
    QLineEdit *osReleaseEdit;
    QLineEdit *osVersionEdit;

    // Venv paths
    QString venvRunningPath;
    QString venvTestingPath;

    // Settings
    int maxHistoryItems; // -1=unlimited, 0 invalid, ≥1 valid
};

/************** End of MainWindow.h **************************/

#-------------------------------------------------------------------------------
# File: src/MainWindow.ui
#-------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>900</width>
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Pip Matrix Resolver</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <widget class="QTabWidget" name="mainTabs">
      <property name="currentIndex">
       <number>2</number>
      </property>
      <widget class="QWidget" name="tabMain">
       <attribute name="title">
        <string>Main</string>
       </attribute>
       <layout class="QVBoxLayout" name="mainLayout">
        <item>
         <widget class="QSplitter" name="splitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QTableView" name="requirementsView"/>
          <widget class="QTableView" name="matrixView"/>
         </widget>
        </item>
        <item>
         <widget class="QSplitter" name="bottomSplitter">
          <property name="orientation">
           <enum>Qt::Orientation::Horizontal</enum>
          </property>
          <widget class="QPlainTextEdit" name="logView">
           <property name="readOnly">
            <bool>true</bool>
           </property>
          </widget>
          <widget class="QProgressBar" name="progressBar"/>
         </widget>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabHistory">
       <attribute name="title">
        <string>History</string>
       </attribute>
       <layout class="QVBoxLayout" name="historyLayout">
        <item>
         <widget class="QTableView" name="localHistoryTable"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="localHistoryButtonBar">
          <item>
           <widget class="QPushButton" name="localAddButton">
            <property name="text">
             <string>Add</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localEditButton">
            <property name="text">
             <string>Edit</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localDeleteButton">
            <property name="text">
             <string>Delete</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localUpButton">
            <property name="text">
             <string>Up</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="localDownButton">
            <property name="text">
             <string>Down</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QTableView" name="webHistoryTable"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="webHistoryButtonBar">
          <item>
           <widget class="QPushButton" name="webAddButton">
            <property name="text">
             <string>Add</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webEditButton">
            <property name="text">
             <string>Edit</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webDeleteButton">
            <property name="text">
             <string>Delete</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webUpButton">
            <property name="text">
             <string>Up</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="webDownButton">
            <property name="text">
             <string>Down</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabTerminal">
       <attribute name="title">
        <string>Terminal</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_terminal">
        <item>
         <widget class="QPlainTextEdit" name="terminalOutput"/>
        </item>
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_terminal">
          <item>
           <widget class="QLineEdit" name="commandInput"/>
          </item>
          <item>
           <widget class="QPushButton" name="runCommandBtn">
            <property name="text">
             <string>Run Command</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="clearTerminalBtn">
            <property name="text">
             <string>Clear</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabSettings">
       <attribute name="title">
        <string>Settings</string>
       </attribute>
       <layout class="QVBoxLayout" name="settingsLayout">
        <item>
         <layout class="QFormLayout" name="formLayout">
          <item row="0" column="0">
           <widget class="QLabel" name="labelPythonVersion">
            <property name="text">
             <string>Python version:</string>
            </property>
           </widget>
          </item>
          <item row="0" column="1">
           <widget class="QLineEdit" name="pythonVersionEdit"/>
          </item>
          <item row="1" column="0">
           <widget class="QLabel" name="labelPipVersion">
            <property name="text">
             <string>pip version:</string>
            </property>
           </widget>
          </item>
          <item row="1" column="1">
           <widget class="QLineEdit" name="pipVersionEdit"/>
          </item>
          <item row="2" column="0">
           <widget class="QLabel" name="labelPipToolsVersion">
            <property name="text">
             <string>pip-tools version:</string>
            </property>
           </widget>
          </item>
          <item row="2" column="1">
           <widget class="QLineEdit" name="pipToolsVersionEdit"/>
          </item>
          <item row="3" column="0">
           <widget class="QLabel" name="labelMaxItems">
            <property name="text">
             <string>Maximum number of items:</string>
            </property>
           </widget>
          </item>
          <item row="3" column="1">
           <layout class="QHBoxLayout" name="spinMaxItemsLayout">
            <item>
             <widget class="QSpinBox" name="spinMaxItems">
              <property name="toolTip">
               <string>-1 = unlimited, 0 not allowed, ≥1 valid</string>
              </property>
              <property name="minimum">
               <number>-1</number>
              </property>
              <property name="maximum">
               <number>2147483647</number>
              </property>
              <property name="value">
               <number>10</number>
              </property>
             </widget>
            </item>
            <item>
             <spacer name="spinMaxItemsSpacer">
              <property name="orientation">
               <enum>Qt::Orientation::Horizontal</enum>
              </property>
              <property name="sizeType">
               <enum>QSizePolicy::Policy::Expanding</enum>
              </property>
              <property name="sizeHint" stdset="0">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
             </spacer>
            </item>
           </layout>
          </item>
          <item row="4" column="0">
           <widget class="QLabel" name="labelGpuDetected">
            <property name="text">
             <string>GPU Detected:</string>
            </property>
           </widget>
          </item>
          <item row="4" column="1">
           <widget class="QCheckBox" name="gpuDetectedCheckBox">
            <property name="enabled">
             <bool>false</bool>
            </property>
           </widget>
          </item>
          <item row="5" column="0">
           <widget class="QLabel" name="labelUseCpu">
            <property name="text">
             <string>Use CPU:</string>
            </property>
           </widget>
          </item>
          <item row="5" column="1">
           <widget class="QCheckBox" name="useCpuCheckBox"/>
          </item>
          <item row="6" column="0">
           <widget class="QLabel" name="labelCuda">
            <property name="text">
             <string>Cuda:</string>
            </property>
           </widget>
          </item>
          <item row="6" column="1">
           <widget class="QCheckBox" name="cudaCheckBox"/>
          </item>
          <item row="7" column="0">
           <widget class="QLabel" name="labelOs">
            <property name="text">
             <string>OS:</string>
            </property>
           </widget>
          </item>
          <item row="7" column="1">
           <widget class="QLineEdit" name="osEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="8" column="0">
           <widget class="QLabel" name="labelOsRelease">
            <property name="text">
             <string>Release:</string>
            </property>
           </widget>
          </item>
          <item row="8" column="1">
           <widget class="QLineEdit" name="osReleaseEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="9" column="0">
           <widget class="QLabel" name="labelOsVersion">
            <property name="text">
             <string>Version:</string>
            </property>
           </widget>
          </item>
          <item row="9" column="1">
           <widget class="QLineEdit" name="osVersionEdit">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <widget class="QPushButton" name="saveSettingsButton">
          <property name="text">
           <string>Save Settings</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="restoreDefaultsButton">
          <property name="text">
           <string>Restore Defaults</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QDialogButtonBox" name="buttonBoxPreferences">
          <property name="standardButtons">
           <set>QDialogButtonBox::StandardButton::Apply|QDialogButtonBox::StandardButton::Cancel|QDialogButtonBox::StandardButton::Ok</set>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>900</width>
     <height>20</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>&amp;File</string>
    </property>
    <addaction name="actionOpenRequirements"/>
    <addaction name="actionFetchRequirements"/>
    <addaction name="separator"/>
    <addaction name="actionExit"/>
   </widget>
   <widget class="QMenu" name="menuTools">
    <property name="title">
     <string>&amp;Tools</string>
    </property>
    <addaction name="actionCreateVenv"/>
    <addaction name="actionResolveMatrix"/>
    <addaction name="actionPause"/>
    <addaction name="actionResume"/>
    <addaction name="actionStop"/>
   </widget>
   <widget class="QMenu" name="menuBatch">
    <property name="title">
     <string>&amp;Batch</string>
    </property>
    <addaction name="actionRunBatch"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>&amp;Help</string>
    </property>
    <addaction name="actionAbout"/>
    <addaction name="actionViewReadme"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuTools"/>
   <addaction name="menuBatch"/>
   <addaction name="menuHelp"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="mainToolBar">
   <property name="windowTitle">
    <string>Main Toolbar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="actionOpenRequirements"/>
   <addaction name="actionFetchRequirements"/>
   <addaction name="actionCreateVenv"/>
   <addaction name="actionResolveMatrix"/>
   <addaction name="actionPause"/>
   <addaction name="actionResume"/>
   <addaction name="actionStop"/>
   <addaction name="actionRunBatch"/>
   <addaction name="actionAbout"/>
   <addaction name="actionViewReadme"/>
  </widget>
  <action name="actionOpenRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/open.svg</normaloff>:/icons/icons/open.svg</iconset>
   </property>
   <property name="text">
    <string>Open requirements file...</string>
   </property>
  </action>
  <action name="actionFetchRequirements">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/url.svg</normaloff>:/icons/icons/url.svg</iconset>
   </property>
   <property name="text">
    <string>Fetch requirements from URL...</string>
   </property>
  </action>
  <action name="actionExit">
   <property name="text">
    <string>Exit</string>
   </property>
  </action>
  <action name="actionCreateVenv">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/venv.svg</normaloff>:/icons/icons/venv.svg</iconset>
   </property>
   <property name="text">
    <string>Create/Update venv</string>
   </property>
  </action>
  <action name="actionResolveMatrix">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resolve.svg</normaloff>:/icons/icons/resolve.svg</iconset>
   </property>
   <property name="text">
    <string>Resolve matrix</string>
   </property>
  </action>
  <action name="actionPause">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/pause.svg</normaloff>:/icons/icons/pause.svg</iconset>
   </property>
   <property name="text">
    <string>Pause</string>
   </property>
  </action>
  <action name="actionResume">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/resume.svg</normaloff>:/icons/icons/resume.svg</iconset>
   </property>
   <property name="text">
    <string>Resume</string>
   </property>
  </action>
  <action name="actionStop">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/stop.svg</normaloff>:/icons/icons/stop.svg</iconset>
   </property>
   <property name="text">
    <string>Stop</string>
   </property>
  </action>
  <action name="actionRunBatch">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/batch.svg</normaloff>:/icons/icons/batch.svg</iconset>
   </property>
   <property name="text">
    <string>Run batch</string>
   </property>
  </action>
  <action name="actionAbout">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/info.svg</normaloff>:/icons/icons/info.svg</iconset>
   </property>
   <property name="text">
    <string>About</string>
   </property>
  </action>
  <action name="actionViewReadme">
   <property name="icon">
    <iconset resource="../PipMatrixResolverQt.qrc">
     <normaloff>:/icons/icons/readme.svg</normaloff>:/icons/icons/readme.svg</iconset>
   </property>
   <property name="text">
    <string>View README</string>
   </property>
  </action>
  <action name="separator">
   <property name="separator" stdset="0">
    <bool>true</bool>
   </property>
  </action>
 </widget>
 <resources>
  <include location="../PipMatrixResolverQt.qrc"/>
 </resources>
 <connections/>
</ui>

#-------------------------------------------------------------------------------
# File: src/PipToolsRunner.cpp
#-------------------------------------------------------------------------------
#include "PipToolsRunner.h"
#include <QProcess>
#include <QFile>
#include <QThread>

PipToolsRunner::PipToolsRunner(const QString &python, QObject *parent) : QObject(parent), m_python(python)
{
}

bool PipToolsRunner::runOnce(const QString &inFile, const QString &outFile)
{
    QProcess p;
    p.setProgram("pip-compile");
    p.setArguments({
        "--resolver=backtracking",
        "--prefer-binary",
        "--upgrade",
        "--output-file", outFile,
        inFile
    });

    connect(&p, &QProcess::readyReadStandardOutput, [&]()
    {
        emit logMessage(QString::fromUtf8(p.readAllStandardOutput()));
    });
    connect(&p, &QProcess::readyReadStandardError, [&]()
    {
        emit logMessage(QString::fromUtf8(p.readAllStandardError()));
    });

    p.start();
    if (!p.waitForStarted())
    {
        emit logMessage("Failed to start pip-compile process.");
        return false;
    }

    p.waitForFinished(-1);
    return p.exitStatus() == QProcess::NormalExit && p.exitCode() == 0;
}

bool PipToolsRunner::pipCompile(const QString &inFile, const QString &outFile, int retries)
{
    for (int attempt = 1; attempt <= retries; ++attempt)
    {
        emit logMessage(QString("Attempting pip-compile (try %1/%2)").arg(attempt).arg(retries));
        if (runOnce(inFile, outFile))
        {
            emit logMessage("pip-compile succeeded.");
            return true;
        }

        analyzeLog("logs/pip_compile.log");
        if (attempt < retries)
        {
            emit logMessage("Retrying in 5 seconds...");
            QThread::sleep(5);
        }
    }
    return false;
}

void PipToolsRunner::analyzeLog(const QString &logPath)
{
    QFile f(logPath);
    if (!f.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        emit logMessage("No pip-compile log found to analyze.");
        return;
    }

    const QString text = QString::fromUtf8(f.readAll());
    if (text.contains("No matching distribution found for"))
    {
        emit logMessage("Detected missing distribution; consider adjusting baseline.");
    }
    else if (text.contains("requires"))
    {
        emit logMessage("Dependency conflict detected; consider adjusting dependent baseline.");
    }
}
#-------------------------------------------------------------------------------
# File: src/PipToolsRunner.h
#-------------------------------------------------------------------------------
#pragma once
#include <QObject>

class PipToolsRunner : public QObject
{
    Q_OBJECT
public:
    explicit PipToolsRunner(const QString &python, QObject *parent = nullptr);
    bool pipCompile(const QString &inFile, const QString &outFile, int retries);

signals:
    void logMessage(const QString &line);

private:
    QString m_python;
    bool runOnce(const QString &inFile, const QString &outFile);
    void analyzeLog(const QString &logPath);
};
#-------------------------------------------------------------------------------
# File: src/ResolverEngine.cpp
#-------------------------------------------------------------------------------
#include "ResolverEngine.h"
#include "PipToolsRunner.h"

#include <QFile>
#include <QTextStream>
#include <QThread>
#include <QtMath>   // for qRound

ResolverEngine::ResolverEngine(QObject *parent)
    : QObject(parent),
    m_running(false),
    m_paused(false),
    m_stateFile("logs/ITERATION_STATE.txt"),
    valid(true)
{
}

void ResolverEngine::loadRequirementsFromFile(const QString &path)
{
    emit logMessage(QString("Loading requirements from file: %1").arg(path));
    // TODO: parse requirements.txt into m_pkgs
}

void ResolverEngine::loadRequirementsFromUrl(const QString &url)
{
    emit logMessage(QString("Fetching requirements from URL: %1").arg(url));
    // TODO: download and parse into m_pkgs
}

void ResolverEngine::start()
{
    m_running = true;
    m_paused = false;

    int combinationCount = 0;
    QFile sf(m_stateFile);
    if (sf.open(QIODevice::ReadOnly))
    {
        QTextStream ts(&sf);
        ts >> combinationCount;
        sf.close();
    }

    while (m_running)
    {
        if (m_paused)
        {
            QThread::msleep(200);
            continue;
        }

        ++combinationCount;
        QFile sfw(m_stateFile);
        if (sfw.open(QIODevice::WriteOnly | QIODevice::Truncate))
        {
            QTextStream ts(&sfw);
            ts << combinationCount;
        }

        QString inFile, comboStr;
        buildNextConstraints(inFile, comboStr);
        emit logMessage(QString("Attempt #%1: %2").arg(combinationCount).arg(comboStr));

        QString outFile = QString("logs/tmp/compiled_requirements_%1.txt").arg(combinationCount);
        PipToolsRunner runner(QString(), this);
        if (runner.pipCompile(inFile, outFile, 3))
        {
            emit successCompiled(outFile);
            break;
        }

        if (!incrementOdometer())
        {
            emit logMessage("All combinations exhausted.");
            stop();
        }

        emit progressChanged(qRound((double)combinationCount / 1000.0 * 100.0));
    }
}

void ResolverEngine::pause()
{
    m_paused = true;
}

void ResolverEngine::resume()
{
    m_paused = false;
}

void ResolverEngine::stop()
{
    m_running = false;
}

void ResolverEngine::buildNextConstraints(QString &inFile, QString &comboStr)
{
    // TODO: build constraints.in file from current indices
    inFile = "logs/tmp/temp_constraints.in";
    comboStr = "example==1.0.0";
}

bool ResolverEngine::incrementOdometer()
{
    for (int j = m_indices.size() - 1; j >= 0; --j)
    {
        m_indices[j]++;
        if (m_indices[j] <= m_maxIndices[j])
        {
            return true;
        }
        m_indices[j] = 0;
    }
    return false;
}

bool ResolverEngine::isValid() const
{
    return valid;
}

bool ResolverEngine::resolve(const QString &path)
{
    // Stub implementation: succeed if path is non-empty
    return !path.isEmpty();
}

#-------------------------------------------------------------------------------
# File: src/ResolverEngine.h
#-------------------------------------------------------------------------------
#pragma once

#include <QObject>
#include <QVector>
#include <QStringList>
#include <QString>

struct PackageCandidates
{
    QString pkg;
    QStringList versions;
};

class ResolverEngine : public QObject
{
    Q_OBJECT
public:
    explicit ResolverEngine(QObject *parent = nullptr);

    void loadRequirementsFromFile(const QString &path);
    void loadRequirementsFromUrl(const QString &url);

    void start();
    void pause();
    void resume();
    void stop();

    // Example methods for unit tests
    bool isValid() const;
    bool resolve(const QString &path);

signals:
    void logMessage(const QString &line);
    void progressChanged(int percent);
    void successCompiled(const QString &compiledPath);

private:
    QVector<PackageCandidates> m_pkgs;
    QVector<int> m_indices;
    QVector<int> m_maxIndices;
    bool m_running;
    bool m_paused;
    QString m_stateFile;
    bool valid;

    void buildNextConstraints(QString &inFile, QString &comboStr);
    bool incrementOdometer();
};

#-------------------------------------------------------------------------------
# File: src/VenvManager.cpp
#-------------------------------------------------------------------------------
#include "VenvManager.h"
#include <QDebug>

VenvManager::VenvManager(QObject *parent) : QObject(parent)
{
}

bool VenvManager::createVenv(const QString &dir, const QString &pythonVer)
{
    // TODO: implement actual venv creation logic
    emit logMessage(QString("Creating venv at %1 with Python %2").arg(dir, pythonVer));
    return true;
}

bool VenvManager::upgradePip(const QString &pipVer, const QString &pipToolsVer)
{
    // TODO: implement actual pip upgrade logic
    emit logMessage(QString("Upgrading pip to %1 and pip-tools to %2").arg(pipVer, pipToolsVer));
    return true;
}

bool VenvManager::createOrUpdate(const QString &dir,
                                 const QString &pythonVer,
                                 const QString &pipVer,
                                 const QString &pipToolsVer)
{
    emit logMessage("Starting createOrUpdate workflow...");

    if (!createVenv(dir, pythonVer)) {
        emit logMessage("createVenv failed");
        return false;
    }

    if (!upgradePip(pipVer, pipToolsVer)) {
        emit logMessage("upgradePip failed");
        return false;
    }

    emit logMessage("createOrUpdate completed successfully");
    return true;
}

#-------------------------------------------------------------------------------
# File: src/VenvManager.h
#-------------------------------------------------------------------------------
#pragma once
#include <QObject>
#include <QString>

class VenvManager : public QObject
{
    Q_OBJECT
public:
    explicit VenvManager(QObject *parent = nullptr);

    // Existing API
    bool createVenv(const QString &dir, const QString &pythonVer);
    bool upgradePip(const QString &pipVer, const QString &pipToolsVer);

    // New convenience wrapper
    bool createOrUpdate(const QString &dir = "venv",
                        const QString &pythonVer = "3.11",
                        const QString &pipVer = "24.0",
                        const QString &pipToolsVer = "7.4.1");

signals:
    void logMessage(const QString &line);
};

#-------------------------------------------------------------------------------
# File: src/main.cpp
#-------------------------------------------------------------------------------
#include <QApplication>
#include <QTranslator>
#include <QLocale>
#include <QFile>
#include <QDebug>
#include <QIcon>
#include "MainWindow.h"

int main(int argc, char *argv[])
{
    // Set app version before MainWindow is constructed
    MainWindow::appVersion = "0.1.3"; // or any version you wan

    QCoreApplication::setOrganizationName(MainWindow::kOrganizationName);
    QCoreApplication::setApplicationName(MainWindow::kApplicationName);

    QApplication theApplication(argc, argv);

    // Register compiled resources
    Q_INIT_RESOURCE(PipMatrixResolverQt);

    // Enable icons in menus globally
    theApplication.setAttribute(Qt::AA_DontShowIconsInMenus, false);

    // Set application icon
    QApplication::setWindowIcon(QIcon(":/icons/icons/app.svg"));

    // Diagnostics
    qDebug() << "[RESOURCE CHECK] :/icons/icons/open.svg exists:" << QFile::exists(":/icons/icons/open.svg");

    // Translation loading
    const QString languageCode = QLocale::system().name().split('_').first();
    auto loadTranslator = [&](const QString &baseName) -> bool
    {
        QTranslator *tr = new QTranslator(&theApplication);
        const QString qmFile = QString(":/translations/%1_%2.qm").arg(baseName, languageCode);
        if (tr->load(qmFile))
        {
            theApplication.installTranslator(tr);
            qDebug() << "Loaded translation:" << qmFile;
            return true;
        }
        delete tr;
        return false;
    };

    loadTranslator("PipMatrixResolverQt");
    loadTranslator("MatrixUtility");
    loadTranslator("MatrixHistory");

    MainWindow w;
    w.show();
    return theApplication.exec();
}

#-------------------------------------------------------------------------------
# File: tests/gtest_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity)
{
    ResolverEngine engine;
    // Replace with a real method from your class
    EXPECT_TRUE(engine.isValid());
}

#-------------------------------------------------------------------------------
# File: tests/qt_test_main.cpp
#-------------------------------------------------------------------------------
#include <QTest>
#include "test_mainwindow.h"

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    int status = 0;
    status |= QTest::qExec(new TestMainWindow, argc, argv);
    return status;
}

#-------------------------------------------------------------------------------
# File: tests/qtest_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject {
    Q_OBJECT

private slots:
    void initTestCase() {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

QTEST_MAIN(TestMainWindow)
#include "qtest_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_main.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>

int main(int argc, char **argv) 
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

#-------------------------------------------------------------------------------
# File: tests/test_mainwindow.cpp
#-------------------------------------------------------------------------------
#include <QtTest/QtTest>
#include "MainWindow.h"

class TestMainWindow : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase() 
    {
        // Runs before all tests
    }

    void testFetchRequirementsAction() {
        MainWindow w;
        QAction *action = w.findChild<QAction*>("actionFetchRequirements");
        QVERIFY(action != nullptr);
    }

    void cleanupTestCase() {
        // Runs after all tests
    }
};

#include "test_mainwindow.moc"

#-------------------------------------------------------------------------------
# File: tests/test_resolver.cpp
#-------------------------------------------------------------------------------
#include <gtest/gtest.h>
#include "ResolverEngine.h"

TEST(ResolverEngineTest, BasicSanity) 
{
    ResolverEngine engine;
    EXPECT_TRUE(engine.isValid());
}

# Directory Structure
#-------------------------------------------------------------------------------
├── .qtcreator
│   ├── qtc-cmake-presets-uEazGGiR
│   └── CMakeLists.txt.user
├── icons
│   ├── app.svg
│   ├── batch.svg
│   ├── cancel.svg
│   ├── info.svg
│   ├── open.svg
│   ├── pause.svg
│   ├── readme.svg
│   ├── resolve.svg
│   ├── resume.svg
│   ├── stop.svg
│   ├── url.svg
│   └── venv.svg
├── src
│   ├── BatchRunner.cpp
│   ├── BatchRunner.h
│   ├── MainWindow.cpp
│   ├── MainWindow.h
│   ├── MainWindow.ui
│   ├── PipToolsRunner.cpp
│   ├── PipToolsRunner.h
│   ├── ResolverEngine.cpp
│   ├── ResolverEngine.h
│   ├── VenvManager.cpp
│   ├── VenvManager.h
│   ├── main.cpp
│   └── venv_manager.py
├── tests
│   ├── gtest_resolver.cpp
│   ├── qt_test_main.cpp
│   ├── qtest_mainwindow.cpp
│   ├── test_main.cpp
│   ├── test_mainwindow.cpp
│   └── test_resolver.cpp
├── translations
│   ├── MatrixHistory_en.qm
│   ├── MatrixHistory_en.ts
│   ├── MatrixHistory_es.qm
│   ├── MatrixHistory_es.ts
│   ├── MatrixUtility_en.qm
│   ├── MatrixUtility_en.ts
│   ├── MatrixUtility_es.qm
│   ├── MatrixUtility_es.ts
│   ├── PipMatrixResolverQt_en.qm
│   ├── PipMatrixResolverQt_en.ts
│   ├── PipMatrixResolverQt_es.qm
│   └── PipMatrixResolverQt_es.ts
├── .gitignore
├── CMakeLists.txt
├── LICENSE
├── PipMatrixResolverQt.qrc
├── README.md
├── cleanbash.sh
├── requirements.txt
├── src2txt.bat
└── src2txt.sh

#*** End of file PipMatrixResolver ***
