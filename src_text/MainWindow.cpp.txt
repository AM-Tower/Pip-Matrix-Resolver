/****************************************************************
 * @file MainWindow.cpp
 * @brief Implements the main application window for
 *        PipMatrixResolverQt.
 *
 * @author Jeffrey
 * @version 0.6
 * @date    2025-11-01
 * @section License Unlicensed, MIT, or any.
 * @section DESCRIPTION
 * Provides requirements.txt loading (local & web), integration
 * with ResolverEngine, VenvManager, BatchRunner, MatrixHistory,
 * and MatrixUtility. Handles menus, logs, and progress updates.
 ***************************************************************/

#include "MainWindow.h"
#include "ui_MainWindow.h"
#include "ResolverEngine.h"
#include "VenvManager.h"
#include "BatchRunner.h"
#include "MatrixHistory.h"
#include "MatrixUtility.h"

#include <QFileDialog>
#include <QInputDialog>
#include <QMessageBox>
#include <QPushButton>
#include <QTextBrowser>
#include <QDialog>
#include <QDateTime>
#include <QFileInfo>
#include <QDir>
#include <QStandardItemModel>
#include <QSettings>
#include <QVBoxLayout>

/****************************************************************
 * @brief Constructor.
 ***************************************************************/
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent),
    ui(new Ui::MainWindow),
    resolver(new ResolverEngine(this)),
    venv(new VenvManager(this)),
    batch(new BatchRunner(this)),
    requirementsModel(new QStandardItemModel(this)),
    hasValidRequirements(false)
{
    ui->setupUi(this);

    requirementsView = ui->requirementsView;
    matrixView       = ui->matrixView;
    logView          = ui->logView;
    progress         = ui->progressBar;
    historyWidget    = ui->matrixHistoryWidget;

    recentLocalMenu = menuBar()->findChild<QMenu*>("recentLocalMenu");
    recentWebMenu   = menuBar()->findChild<QMenu*>("recentWebMenu");

    bindSignals();
    applyToolsEnabled(false);
    statusBar()->showMessage(tr("Ready"));

    connect(ui->actionAbout, &QAction::triggered,
            this, &MainWindow::showAboutBox);
    connect(ui->actionViewReadme, &QAction::triggered,
            this, &MainWindow::showReadmeDialog);
    connect(ui->actionExit, &QAction::triggered,
            this, &MainWindow::close);

    connect(ui->actionOpenRequirements, &QAction::triggered,
            this, &MainWindow::openLocalRequirements);
    connect(ui->actionFetchRequirements, &QAction::triggered,
            this, &MainWindow::fetchRequirementsFromUrl);

    connect(ui->actionCreateVenv, &QAction::triggered,
            this, &MainWindow::createOrUpdateVenv);
    connect(ui->actionResolveMatrix, &QAction::triggered,
            this, &MainWindow::startResolve);
    connect(ui->actionPause, &QAction::triggered,
            this, &MainWindow::pauseResolve);
    connect(ui->actionResume, &QAction::triggered,
            this, &MainWindow::resumeResolve);
    connect(ui->actionStop, &QAction::triggered,
            this, &MainWindow::stopResolve);

    connect(ui->actionRunBatch, &QAction::triggered,
            this, &MainWindow::runBatch);

    loadHistory();
    syncHistoryToWidget();
    refreshRecentMenus();
}

/****************************************************************
 * @brief Destructor.
 ***************************************************************/
MainWindow::~MainWindow()
{
    saveHistory();
    delete ui;
}

/****************************************************************
 * @brief Bind signals between components.
 ***************************************************************/
void MainWindow::bindSignals()
{
    connect(resolver, &ResolverEngine::logMessage,
            this, &MainWindow::appendLog);
    connect(resolver, &ResolverEngine::progressChanged,
            this, &MainWindow::updateProgress);
    connect(resolver, &ResolverEngine::successCompiled,
            this, &MainWindow::showCompiledResult);

    connect(venv, &VenvManager::logMessage,
            this, &MainWindow::appendLog);

    connect(batch, &BatchRunner::logMessage,
            this, &MainWindow::appendLog);
    connect(batch, &BatchRunner::progressChanged,
            this, &MainWindow::updateProgress);
    connect(batch, &BatchRunner::allJobsFinished,
            this, [this]()
            {
                statusBar()->showMessage(tr("Batch jobs complete"));
            });

    connect(historyWidget, &MatrixHistory::historyChanged,
            this, &MainWindow::onHistoryChanged);
}

/****************************************************************
 * @brief Enable or disable tool actions.
 ***************************************************************/
void MainWindow::applyToolsEnabled(bool enabled)
{
    ui->actionCreateVenv->setEnabled(enabled);
    ui->actionResolveMatrix->setEnabled(enabled);
    ui->actionPause->setEnabled(enabled);
    ui->actionResume->setEnabled(enabled);
    ui->actionStop->setEnabled(enabled);
    ui->actionRunBatch->setEnabled(enabled);
}

/****************************************************************
 * @brief Load persisted history from QSettings.
 ***************************************************************/
void MainWindow::loadHistory()
{
    QSettings settings;
    historyRecentLocal =
        settings.value("historyRecentLocal").toStringList();
    historyRecentWeb =
        settings.value("historyRecentWeb").toStringList();
}

/****************************************************************
 * @brief Save history back to QSettings.
 ***************************************************************/
void MainWindow::saveHistory()
{
    QSettings settings;
    settings.setValue("historyRecentLocal", historyRecentLocal);
    settings.setValue("historyRecentWeb", historyRecentWeb);
}

/****************************************************************
 * @brief Refresh recent file and URL menus.
 ***************************************************************/
/****************************************************************
 * @brief Refresh recent file and URL menus.
 ***************************************************************/
void MainWindow::refreshRecentMenus()
{
    // Clear existing menu items
    recentLocalMenu->clear();
    recentWebMenu->clear();

    // Populate local history menu
    for (int i = 0; i < historyRecentLocal.size(); ++i)
    {
        const QString &path = historyRecentLocal.at(i);
        QAction *act = recentLocalMenu->addAction(path);

        connect(act, &QAction::triggered, this,
                [this, path]()
                {
                    const QStringList lines =
                        MatrixUtility::readTextFileLines(path);

                    QStringList errors;
                    if (!MatrixUtility::validateRequirementsWithErrors(
                            lines, errors))
                    {
                        QMessageBox::warning(
                            this,
                            tr("Invalid requirements.txt"),
                            tr("Validation failed:\n%1")
                                .arg(errors.join("\n"))
                            );
                        return;
                    }

                    requirementsView->setModel(requirementsModel);
                    MatrixUtility::writeTableToModel(requirementsModel,
                                                     lines);
                    MatrixUtility::ensureViewScrollable(requirementsView);
                    applyToolsEnabled(true);

                    appendLog(tr("Loaded %1 requirements from %2")
                                  .arg(requirementsModel->rowCount())
                                  .arg(path));
                });
    }

    // Populate web history menu
    for (int i = 0; i < historyRecentWeb.size(); ++i)
    {
        const QString &url = historyRecentWeb.at(i);
        QAction *act = recentWebMenu->addAction(url);

        connect(act, &QAction::triggered, this,
                [this, url]()
                {
                    QByteArray content;
                    if (!MatrixUtility::downloadText(url, content))
                    {
                        QMessageBox::warning(
                            this,
                            tr("Download failed"),
                            tr("Failed to fetch requirements from URL:\n%1")
                                .arg(url)
                            );
                        return;
                    }

                    const QStringList lines =
                        QString::fromUtf8(content)
                            .split('\n', Qt::KeepEmptyParts);

                    QStringList errors;
                    if (!MatrixUtility::validateRequirementsWithErrors(
                            lines, errors))
                    {
                        QMessageBox::warning(
                            this,
                            tr("Invalid requirements.txt"),
                            tr("Fetched content failed validation:\n%1")
                                .arg(errors.join("\n"))
                            );
                        return;
                    }

                    requirementsView->setModel(requirementsModel);
                    MatrixUtility::writeTableToModel(requirementsModel,
                                                     lines);
                    MatrixUtility::ensureViewScrollable(requirementsView);
                    applyToolsEnabled(true);

                    appendLog(
                        tr("Fetched %1 requirements from URL: %2")
                            .arg(requirementsModel->rowCount())
                            .arg(url));
                });
    }
}

/****************************************************************
 * @brief Sync history lists into the MatrixHistory widget.
 ***************************************************************/
void MainWindow::syncHistoryToWidget()
{
    QStringList combined = historyRecentLocal;
    combined.append(historyRecentWeb);
    historyWidget->setHistory(combined);
}

/****************************************************************
 * @brief Handle history changed signal from widget.
 ***************************************************************/
void MainWindow::onHistoryChanged()
{
    saveHistory();
    refreshRecentMenus();
}

/****************************************************************
 * @brief Open requirements from a local file.
 ***************************************************************/
void MainWindow::openLocalRequirements()
{
    QString path = QFileDialog::getOpenFileName(
        this,
        tr("Open requirements.txt"),
        QString(),
        tr("Text Files (*.txt)")
        );

    if (path.isEmpty())
    {
        return;
    }

    const QStringList lines = MatrixUtility::readTextFileLines(path);

    QStringList errors;
    if (!MatrixUtility::validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(
            this,
            tr("Invalid requirements.txt"),
            tr("Validation failed:\n%1").arg(errors.join("\n"))
            );
        return;
    }

    requirementsView->setModel(requirementsModel);
    MatrixUtility::writeTableToModel(requirementsModel, lines);
    MatrixUtility::ensureViewScrollable(requirementsView);
    applyToolsEnabled(true);

    // ðŸ”‘ Add to local history
    historyRecentLocal.removeAll(path);
    historyRecentLocal.prepend(path);
    while (historyRecentLocal.size() > 10)
    {
        historyRecentLocal.removeLast();
    }
    refreshRecentMenus();
    saveHistory();

    appendLog(tr("Loaded %1 requirements from %2")
                  .arg(requirementsModel->rowCount()).arg(path));
}

/****************************************************************
 * @brief Fetch requirements from a URL.
 ***************************************************************/
void MainWindow::fetchRequirementsFromUrl()
{
    bool ok = false;
    QString inputUrl = QInputDialog::getText(
        this,
        tr("Fetch requirements"),
        tr("Enter URL:"),
        QLineEdit::Normal,
        "",
        &ok
        );

    if (!ok || inputUrl.isEmpty())
    {
        return;
    }

    const QString rawUrl = MatrixUtility::normalizeRawUrl(inputUrl);

    QByteArray content;
    if (!MatrixUtility::downloadText(rawUrl, content))
    {
        QMessageBox::warning(
            this,
            tr("Download failed"),
            tr("Failed to fetch requirements from URL:\n%1")
                .arg(rawUrl)
            );
        return;
    }

    const QStringList lines =
        QString::fromUtf8(content).split('\n', Qt::KeepEmptyParts);

    QStringList errors;
    if (!MatrixUtility::validateRequirementsWithErrors(lines, errors))
    {
        QMessageBox::warning(
            this,
            tr("Invalid requirements.txt"),
            tr("Fetched content failed validation:\n%1")
                .arg(errors.join("\n"))
            );
        return;
    }

    requirementsView->setModel(requirementsModel);
    MatrixUtility::writeTableToModel(requirementsModel, lines);
    MatrixUtility::ensureViewScrollable(requirementsView);
    applyToolsEnabled(true);

    // ðŸ”‘ Add to web history
    historyRecentWeb.removeAll(rawUrl);
    historyRecentWeb.prepend(rawUrl);
    while (historyRecentWeb.size() > 10)
    {
        historyRecentWeb.removeLast();
    }
    refreshRecentMenus();
    saveHistory();

    appendLog(
        tr("Fetched %1 requirements from URL: %2")
            .arg(requirementsModel->rowCount())
            .arg(rawUrl)
        );
}

/****************************************************************
 * @brief Create or update a virtual environment.
 ***************************************************************/
void MainWindow::createOrUpdateVenv()
{
    appendLog(tr("Creating or updating virtual environment..."));
    venv->createOrUpdate();
}
/****************************************************************
 * @brief Start matrix resolution.
 ***************************************************************/
void MainWindow::startResolve()
{
    appendLog(tr("Starting matrix resolution..."));
    resolver->start();
}

/****************************************************************
 * @brief Pause matrix resolution.
 ***************************************************************/
void MainWindow::pauseResolve()
{
    appendLog(tr("Pausing..."));
    resolver->pause();
}

/****************************************************************
 * @brief Resume matrix resolution.
 ***************************************************************/
void MainWindow::resumeResolve()
{
    appendLog(tr("Resuming..."));
    resolver->resume();
}

/****************************************************************
 * @brief Stop matrix resolution.
 ***************************************************************/
void MainWindow::stopResolve()
{
    appendLog(tr("Stopping..."));
    resolver->stop();
}

/****************************************************************
 * @brief Run a batch job.
 ***************************************************************/
void MainWindow::runBatch()
{
    BatchJob job;
    job.imagePath = QFileDialog::getOpenFileName(
        this,
        tr("Select image"),
        QString(),
        tr("Images (*.png *.jpg *.jpeg)")
        );

    if (job.imagePath.isEmpty())
    {
        return;
    }

    job.audioPath = QFileDialog::getOpenFileName(
        this,
        tr("Select audio"),
        QString(),
        tr("Audio Files (*.wav *.mp3)")
        );

    if (job.audioPath.isEmpty())
    {
        return;
    }

    QString baseName = QFileInfo(job.imagePath).completeBaseName();
    QString outFile = QDir(MatrixUtility::logsDir())
                          .filePath(baseName + "_output.mp4");

    job.outputPath = outFile;

    batch->enqueue(job);
    batch->start();
}

/****************************************************************
 * @brief Append a line to the log view.
 * @param line Message to append.
 ***************************************************************/
void MainWindow::appendLog(const QString &line)
{
    QString time = QDateTime::currentDateTime().toString("HH:mm:ss");
    logView->appendPlainText(QString("[%1] %2").arg(time, line));
}

/****************************************************************
 * @brief Update progress bar.
 * @param percent Progress value 0â€“100.
 ***************************************************************/
void MainWindow::updateProgress(int percent)
{
    progress->setValue(percent);
}

/****************************************************************
 * @brief Show compiled result message.
 * @param path Absolute path to compiled artifact.
 ***************************************************************/
void MainWindow::showCompiledResult(const QString &path)
{
    appendLog(tr("Successfully compiled: %1").arg(path));
    statusBar()->showMessage(tr("Compiled successfully"));
}

/****************************************************************
 * @brief Show About dialog.
 ***************************************************************/
void MainWindow::showAboutBox()
{
    QMessageBox::about(
        this,
        tr("About Pip Matrix Resolver"),
        tr("<b>Pip Matrix Resolver</b><br>"
           "Cross-platform Qt tool to resolve "
           "Python dependency matrices.<br>"
           "Version 0.6")
        );
}

/****************************************************************
 * @brief Show README dialog.
 ***************************************************************/
void MainWindow::showReadmeDialog()
{
    QFile file(":/docs/README.md");
    QString markdown;

    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        markdown = QString::fromUtf8(file.readAll());
    }
    else
    {
        markdown = tr("README.md not found in resources.");
    }

    QDialog dialog(this);
    dialog.setWindowTitle(tr("README"));
    dialog.resize(700, 500);

    QVBoxLayout layout(&dialog);
    QTextBrowser viewer(&dialog);
    viewer.setMarkdown(markdown);
    viewer.setOpenExternalLinks(true);

    QPushButton closeButton(tr("Close"), &dialog);
    layout.addWidget(&viewer);
    layout.addWidget(&closeButton);

    connect(&closeButton, &QPushButton::clicked,
            &dialog, &QDialog::accept);

    dialog.exec();
}

/****************************************************************
 * @brief Open matrix history tab.
 ***************************************************************/
void MainWindow::openMatrixHistory()
{
    ui->mainTabs->setCurrentWidget(ui->tabHistory);
}

/************** End of MainWindow.cpp **************************/

